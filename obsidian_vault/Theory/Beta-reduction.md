Функции можно вычислять, или просто "упрощать". Например выражение `(fn x -> x) y` упрощается до простого `y`, или же после вычисления этого выражения мы получаем `y`. Эта процедура вычисления выражений в литературе называется бета-редукция (beta-reduction). Когда в выражении больше нельзя выполнять подстановки, такое выражение считается нормальной формой начального. Обычно все выражения которые приходят к одной и той же нормальной форме считаются еквивалентными.

Один шаг бета редукции (тоесть подстановку одно параметра в тело) можно считать атомарным и имеющим фиксированную цену вычисления, тогда можно даже формально оценить ефективность каждой стратегии в виде количества требуемых редукций.

Одно и то же выражение может позволять выполнить несколько упрощений в разных местах. А так как порядок упрощений не важен, каждый раз когда у нас несколько вариантов, их можно выполнять паралельно.

Во время упрощения можно принимать во внимание "подсказки" каким образом выполнять упрощение в данном случае:
1. Call by name - сначала разворачиваем определение функции, подставляя параметры, потом выполняем результирующее тело функции. Если параметр используется в нескольких местах, то в каждом из них он будет вычислен отдельно. Интуитивно это часто называют inlining - определение функции подставляется на месте вызова, убирая излишние вызовы, когда они стоят больше чем вычисление на месте. Подходит например для вычисления функций которые могут не использоваться один из своих аргументов, например как if statement - он всегда упрощается до одной из веток, что позволяет "выбросить" вторую не пытаясь вычислить ее даже. В некоторых случаях заменяемо оборачиванием\\разворачиванием значения в функцию при Call by value. 
2. Call by value - обратное к Call by name, сначала вычисляем параметры, потом подставляем в тело и вычисляем. Интуитивный способ вычисления функций.
3. Call by need - Тоже поведение что и Call by name, но значения параметров кешируются. Если однажды было вычислено значение, то потом другие места переиспользуют его. По сути мемоизированный вариант Call by name.
4. Parallel call by name - Call by name, где параметры вместе с телом функции начинают выполнятся параллельно, пока не потребуется синхронизация, когда тело требует значение параметра, или когда параметры используют общие данные между собой. Каждый доступ к параметру запускает новую паральельную задачу.
4. Parallel call by need - та же логика что и при выведении Parallel call by name из Call by name. Call by need, где параметры вместе с телом функции начинают выполнятся параллельно, пока не потребуется синхронизация, когда тело требует значение параметра, или когда параметры используют общие данные между собой. При повторном доступе к параметру ожидается завершение уже запущеной задачи и берется его результат.

https://axisofeval.blogspot.com/2011/09/kernel-underground.html
https://web.cs.wpi.edu/~jshutt/kernel.html