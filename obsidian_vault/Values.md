variables store values
reference to a value is a pair of getter and setter
variable is a reference for its value associated with some symbol
reference to a variable returns that reference
dereference on assignment's left side calls setter of the reference
dereference in other places calls getter of the reference
declarations take a symbol and a reference and creates a variable in current scope
variable's value is got through its symbol - get reference associated with that symbol, call the getter
variable's value is assigned through its symbol - get reference associated with that symbol, call the setter

assignment's and definition's lhs is transformed into atom if its just a name, or evaluates to a symbol
tranaformantion should happen at evaluation phase, because translated tree would contain names as well, which will create inf loop
`~symbol = value ->  *current_scope[symbol] = value`
`~symbol -> *current_scope[symbol]`
`~symbol := value -> &~symbol := &value`
`&~symbol := ref -> current_scope[symbol] = ref`
`*ref = value -> ref[setter] value`
`*ref -> ref[getter] ()`
`record.name = value ->  *record[:name] = value`
`record.name -> *record[:name]`


Последнее время часто начал встречать так называемые "алгебраические еффекты" в статьях которые читаю по разработке ЯП. Так что решил немного подетальнее изучить чо это за еффекты и почему они алгебраические на примере этой статьи.
Что такие еффекты? Это пошло от термина побочный эффект (side-effect), потому что их ввели какраз что бы удобней описывать их. Как пример часто используют IO:
* Вывод в консоль или запись в файл
* Чтение из файла или ввода консоли

Эти взаимодействия нельзя описать в чистых функциональных языках напрямую, потому что они реализуются системой в которой выполняется программа и для самой программы подобные рутины это способ повлиять на "внешний мир".
Классическое решение для описания подобных рутин в функциональных языках это монады, которые никто кроме самих создателей до конца не понимает, а их использование обычно приводит к цветным функциям, которые между собой сложно композировать. 
Алгебраические еффекты являются более практичной альтернативой и есть частным случаем систем еффектов, которые нацелены на решение данной проблемы более практичными методами. 
Их какраз недавно завезли в Ocaml и на ней реализовали конкурентность в языке, хотел  посмотреть доку как их на практике используют и как оно вообще работает, но нихуя не понял как обычно (это ж фп, на что я надеялся).

Так что же такое эти алгебраические еффекты? Эта система вводит две новые конструкции для создания обработчиков (handler) и их привязки к выражениям, которые от них могут зависеть (`with ... handle ...` синтаксис например).
На уровне типов это означает разширение типа функций, теперь они так же описывают какие "зависимости" использует функция, и если вызывающий не предоставил их, будет ошибка. Из этого мы смова приходим к цветным функциям, пусть и в более удобном для композиции виде.
в статье такие "функции с зависимостями" называли вычислениями, но в даном случае это "деталь реализации" больше, чем основной компонент.
На практике выглядит так: если выражение считывает из консоли ввод, то в зависимостях у нее будет функция которая может выполнить это считывание. 
Обработчики складываются в стек, так же как и стек вызовов, и могут делегировать последующие обработки тем кто выше по стеку, если они не могут сами обработать их до конца.

Как по мне это выглядит как формализация dependency injection (DI), несущая достаточно приятные теоретические гарантии. 
Потому что оно по сути дает те же возможности что и DI - подмена зависимостей в уже существующем коде. 
А как известно это очень полезно для тестирования и модульности. Но в отличии от классических реализаций DI имеет более гибкую семантику, не требует кучи абстракций и позыоляет видеть зависимости на уровне типов

Вообще после прочтения статьи я так и не понял чо там такого алгебраического, но предполагаю что это потому что их можно комбинировать произвольно, аналогично алгебраическим типам.

Думаю в языке реализовать такую же систему, но вместо "операций" использовать интерфейсы. И выглядеть будет примерно так:
```
interface IO {
  read: () -> string
  write string -> ()
}

...

output := []
impl := (read: fn -> "input", write: fn x { output.push x; () })

handleInput := fn input {
  if input == "": IO.write "empty"
  else IO.write "not empty"
}

with impl for IO {
  IO.write "input something"
  input := IO.read()
  handleInput input
}
```

Когда кусок кода использует метод интерфейса напрямую, а не через конкретную реализацию, то если вызывающий подставит реализацию с помощью with ... for ... { ... }, она будет использоваться при вызове методов. Но надо подумать как сделать без упоминания интерфейса, потому что иначе уже не красиво выглядят всякие async\await\yield и тд, которые обычно без префиксов всяких. Можно конечно пойти тем путем что описан в статье, но тогда надо отличать как то когда функция должна обработчика искать, а когда падать, что она не определена. Ещё один вариант который я вижу это определить глобальные обработчики для часто используемых интерфейсов типа async\await, read\write, throw\catch и тд. Тогда они будут доступны везде и всегда, и их наличие в зависимостях предпологать всегда. Что прикольно, в таком случае можно подставлять свои реализации для всех этих обработчиков, и например выжать больше скорости из программы за счет упрощения реализаций всех обработчиков, не меняя сам код приложения нигде.

Как увидим дальше, они не особо решает проблему "цветных" функций, всё ещё если вызывающий не подставляет реализацию, ему придется указывать зависимость в типе, и вот мы снова везде их прописываем, потому что зависимости передаются в самом верху всегда. Но при этом упрощают работу когда много разных "еффектов" должны работать в одном куске кода вместе. С монадами получается тонна дженериков, которые обычно между собой вообще не кооперируются, и код больше превращает один контейнер в другой, чем делает чтото полезное. А тут все переливания пустого в порожнее происходят закулисами в обработчиках, если вообще происходят.

для handleInput можно автоматом вывести тип string -> ()!{ IO }, используя запись таких типов из статьи. Подобный вариант очень удобен для ошибок которые может кинуть код, но всё ещё не очень для например асинхронного кода

Вообще надеюсь что вместо решения проблемы с цветными функциями ее можно будет скрыть за мощным выводом типов, и тогда конечному пользователю не придется самому всё прописывать и обновлять когда где то глубоко в жопе вставили асинк авейт.

Погуглил ещё, как я понял "алгебраичность" у них потому что такие наборы операций read/write описывают свою алгебраическую теорию? А алгебраическая теория это набор операций и равенств между ними, аналогично определению сложения и отрицательных чисел на целых числах. Такое чувство что они на мета-мета уровне рассуждений уже