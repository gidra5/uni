
Последнее время часто начал встречать так называемые "алгебраические еффекты" в статьях которые читаю по разработке ЯП. Так что решил немного подетальнее изучить чо это за еффекты и почему они алгебраические на примере [этой статьи](https://www.sciencedirect.com/science/article/pii/S1571066115000705?ref=pdf_download&fr=RR-2&rr=8786637be9752498).
Что такие еффекты? Это пошло от термина побочный эффект (side-effect), потому что их ввели какраз что бы удобней описывать их. Как пример часто используют IO:
* Вывод в консоль или запись в файл
* Чтение из файла или ввода консоли

Эти взаимодействия нельзя описать в чистых функциональных языках напрямую, потому что они реализуются системой в которой выполняется программа и для самой программы подобные рутины это способ повлиять на "внешний мир".
Классическое решение для описания подобных рутин в функциональных языках это монады, которые никто кроме самих создателей до конца не понимает, а их использование обычно приводит к цветным функциям, которые между собой сложно композировать. 
Алгебраические еффекты являются более практичной альтернативой и есть частным случаем систем еффектов, которые нацелены на решение данной проблемы более практичными методами. 
Их какраз недавно завезли в Ocaml и на ней реализовали конкурентность в языке, хотел  посмотреть доку как их на практике используют и как оно вообще работает, но нихуя не понял как обычно (это ж фп, на что я надеялся).

Так что же такое эти алгебраические еффекты? Эта система вводит две новые конструкции для создания обработчиков (handler) и их привязки к выражениям, которые от них могут зависеть (`with ... handle ...` синтаксис например).
На уровне типов это означает разширение типа функций, теперь они так же описывают какие "зависимости" использует функция, и если вызывающий не предоставил их, будет ошибка. Из этого мы смова приходим к цветным функциям, пусть и в более удобном для композиции виде.
в статье такие "функции с зависимостями" называли вычислениями, но в даном случае это "деталь реализации" больше, чем основной компонент.
На практике выглядит так: если выражение считывает из консоли ввод, то в зависимостях у нее будет функция которая может выполнить это считывание. 
Обработчики складываются в стек, так же как и стек вызовов, и могут делегировать последующие обработки тем кто выше по стеку, если они не могут сами обработать их до конца.

Как по мне это выглядит как формализация dependency injection (DI), несущая какие нибуть приятные теоретические гарантии. 
Потому что оно по сути дает те же возможности что и DI - подмена зависимостей в уже существующем коде. 
А как известно это очень полезно для тестирования и модульности. Но в отличии от классических реализаций DI имеет более гибкую семантику, не требует кучи абстракций и позволяет видеть зависимости на уровне типов

Думаю в языке реализовать такую же систему, но вместо "операций" использовать интерфейсы. И выглядеть будет примерно так:
```
interface IO {
  read: () -> string
  write: string -> ()
}

...

output := []
impl := (read: fn -> "input", write: fn x { output.push x; () })

handleInput := fn input {
  if input == "": IO.write "empty"
  else IO.write "not empty"
}

with impl for IO {
  IO.write "input something"
  input := IO.read()
  handleInput input
}
```

Когда кусок кода использует метод интерфейса напрямую, а не через конкретную реализацию, то если вызывающий подставит реализацию с помощью `with ... for ... { ... }`, она будет использоваться при вызове методов. Но надо подумать как сделать без упоминания интерфейса, потому что иначе уже не красиво выглядят всякие async\await\yield и тд, которые обычно без префиксов всяких. Можно конечно пойти тем путем что описан в статье, но тогда надо отличать как то когда функция должна обработчика искать, а когда падать, что она не определена. Ещё один вариант который я вижу это определить глобальные обработчики для часто используемых интерфейсов типа async\await, read\write, throw\catch и тд. Тогда они будут доступны везде и всегда, и их наличие в зависимостях предпологать всегда. Что прикольно, в таком случае можно подставлять свои реализации для всех этих обработчиков, и например выжать больше скорости из программы за счет упрощения реализаций всех обработчиков, не меняя сам код приложения нигде.

Как я уже написал выше, еффекты не особо решают проблему "цветных" функций, всё ещё если вызывающий не подставляет реализацию, ему придется указывать зависимость в типе, и вот мы снова везде их прописываем, потому что зависимости передаются в самом верху всегда. Но при этом упрощают работу когда много разных "еффектов" должны работать в одном куске кода вместе. И так же нет ограничений кто должен передавать обработчик - если библиотека не хочет обременять этим пользователя, то она может сама передавать свою реализацию всем функциям и избавить их от "цвета". С монадами же получается тонна дженериков, которые обычно между собой вообще не кооперируются, а даже если кооперируются, то добавляют бойлерплейта, и код больше превращает один контейнер в другой, чем делает чтото полезное. А тут все переливания пустого в порожнее происходят закулисами в обработчиках, если вообще происходят.

Тип какого нить кастомного логгера может выглядеть как `[IO]string -> ()`, где `[IO]` обозначает что где то в стеке должен быть установлен обработчик данного интерфейса. Подобный вариант очень удобен для ошибок которые может кинуть код, но всё ещё не очень для например асинхронного кода. Но как я написал выше это неудобство можно обойти теперь при желании. В случае async\await наш обработчик должен целый рантайм встроить, что бы менеджить асинхронность, и гипотетическая библиотека может создать себе синглтон такого рантайма и установить его глобально, не требуя от юзера самому где то вверху приложения пробрасывать его. Теперь можно выбирать!

Вообще надеюсь что вместо решения проблемы с цветными функциями ее можно будет скрыть за мощным выводом типов, и тогда конечному пользователю не придется самому всё прописывать и обновлять когда где то глубоко в жопе вставили асинк авейт.

Что же "алгебраичного" такого в этих эффектах? Почитав детальнее ещё одну статью, которая немого глубже в матан уходит, понял что похоже на одну идею которая была у меня в голове как то. А конкретнее - модули в програмировании и теории в математике имеют схожую структуру:
1. Оба описывают некоторый инструмент для решения задач (в проге обычно чтото прикладное, в матане оно прикладное только для самих математиков)
2. Часто оперируют конкретно определенными терминами или сущностями (в проге это какие то типы данных или классы, в матане это просто "обьекты" с некоторой семантикой)
3. Имеют набор операций над данными сущностями (в проге это функции или методы на сущностях обычно, в матане операторы или функции)
4. Иногда предпологают конкретный стиль решения задач с помощью базовых операций или готового шаблона.
5. Могут предпологать некоторые инварианты (енкапсуляция в классах, равенства между разными выражениями в матане)

С такой точки зрения терминология которую придумали авторы этих алгебраических эффектов начинает обретать смысл - все конструкции которые они хотят эффектами описать можно легко сложить в самодостаточные модули, что часто наблюдается в стандартных библиотеках многих языков. А эти модули в свою очередь можно интерпретировать как алгебраические теории, которые как они показали следуют тем же принципам и имеют те же свойства что мы ожидаем от таких модулей, где и вылазит "алгебраичность" этих еффектов. И в [статье из которой всё пошло](https://www.sciencedirect.com/science/article/pii/S0304397506002659?via%3Dihub) они сфокусированы чисто на матане, периодически вбрасывая что какая то формула описывает IO, State или Exceptions или кобинацию их. Выводят какие то теоремы даже, так как теперь у этого есть четкая теория, а не рандомная програмная реализация которая не понятно какие свойства и гарантии имеет, помимо тех что заранее планоровались. Такое чувство что они на мета-мета уровне рассуждений уже, изза чего простым смертным далеким от матана сложно понять что за бред они написали.

Fuck, даже [реакт](https://overreacted.io/algebraic-effects-for-the-rest-of-us/) как то связан с этими еффектами, а пример из поста уже закинули в [пропоузал](https://github.com/macabeus/js-proposal-algebraic-effects). Этот пост даже упоминает вещи которые я описал выше о плюсах и минусах такого подхода.
Если подумать, то весь реакт подходит под описание еффектов - это "библиотека" (модуль) для манипулирования юи, которая дает хуки для взаимодействия с состоянием приложения (функции аналогичные read\write), которые под капотом делают магию свою. Прищурится, и можно подумать что компоненты это тоже цветные функции как и async, потому что никто кроме `ReactDom.render` не может их всех обработать, и вне других компонентов они юзлес, и не факт что вообще ожидаемо работать будут. В статье тоже об этом упомянули, но на деле всё немного сложнее, потому что джс не поддерживает еффекты, а значит они симулируют их через костыли какие то)))
Сигналы тоже подходят походу. Их даже проще представить таковыми, потому что они намного проще концептуально, чем ебучий реакт. Та наверно все системы реактивности подойдут, но это ещё надо посмотреть...

Ну вот, теперь я буду их везде видеть, так же как везде вижу монады(

TL;DR математики изобрели dependency injection в фп.

Надеюсь как то смог обьяснить это дерьмо, эта дыра оказалась глубже чем я ожидал.

[do be do be do](https://arxiv.org/pdf/1611.09259.pdf)
[modal effect types](https://arxiv.org/abs/2407.11816)
[effect systems](https://vhyrro.github.io/posts/effect-systems/)
[koka](https://koka-lang.github.io/koka/doc/book.html#why)

```
result, logs := fn {
	result, logs := fn {
		inject 
			log: handler fn (callback, msg) {
				result, logs := callback()
				result, (msg, ...logs)
			},
			[return_handler]: handler fn x do x, ()
		{
			123, fn {
			    injected.log 789
			    234
			} ()
		}
	} ()
	result, (456, ...logs)
} ()
result, (123, ...logs)
```