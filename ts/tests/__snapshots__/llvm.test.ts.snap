// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`data structures compilation > atom (global symbol) > compiled 1`] = `
"@const_27 = constant i64 0
@const_33 = constant [7 x i8] c"atom_a\\00"
@symbols_metadata_array = constant [1 x { i8* }] [{ i8* } { i8* @const_33 }]
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_11 = alloca {  }
    %var_12 = load {  }, ptr %var_11
    store {  } %var_12, ptr %var_11
    %var_23 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_24 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_23
    %var_25 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_24, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_26 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_25, {  } %var_12, 1
    store { void (i64*, {  }, i64)*, {  } } %var_26, ptr %var_23
    %var_28 = load i64, ptr @const_27
    %var_29 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_26, 0
    %var_30 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_26, 1
    %var_31 = alloca i64
    call void %var_29(i64* %var_31, {  } %var_30, i64 %var_28)
    %var_32 = load i64, ptr %var_31
    ret i32 0
}
define void @"generated_print_symbol"(ptr sret(i64) %arg_0, {  } %arg_1, i64 %arg_2) {
  entry_0: 
    %var_13 = alloca {  }
    %var_14 = load {  }, ptr %var_13
    store {  } %var_14, ptr %var_13
    %var_15 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_16 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_15
    %var_17 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_16, void (i64*, {  }, i64)* @print_symbol_wrap, 0
    %var_18 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_17, {  } %var_14, 1
    store { void (i64*, {  }, i64)*, {  } } %var_18, ptr %var_15
    %var_19 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_18, 0
    %var_20 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_18, 1
    %var_21 = alloca i64
    call void %var_19(i64* %var_21, {  } %var_20, i64 %arg_2)
    %var_22 = load i64, ptr %var_21
    store i64 %arg_2, ptr %arg_0
    ret void
}
declare void @print_symbol(i64)
define void @print_symbol_wrap(ptr sret(i64) %arg_0, {  } %arg_1, i64 %arg_2) {
  entry_0: 
    call void @print_symbol(i64 %arg_2)
    store i64 %arg_2, ptr %arg_0
    ret void
}
"
`;

exports[`data structures compilation > atom (global symbol) > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_27 = local_unnamed_addr constant i64 0
@const_33 = constant [7 x i8] c"atom_a\\00"
@symbols_metadata_array = constant [1 x { ptr }] [{ ptr } { ptr @const_33 }]
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @print_symbol(i64 0)
  ret i32 0
}

define void @generated_print_symbol(ptr nocapture writeonly sret(i64) %arg_0, {} %arg_1, i64 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @print_symbol(i64 %arg_2)
  store i64 %arg_2, ptr %arg_0, align 8
  ret void
}

declare void @print_symbol(i64) local_unnamed_addr

define void @print_symbol_wrap(ptr nocapture writeonly sret(i64) %arg_0, {} %arg_1, i64 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @print_symbol(i64 %arg_2)
  store i64 %arg_2, ptr %arg_0, align 8
  ret void
}
"
`;

exports[`data structures compilation > atom (global symbol) > stderr 1`] = `[]`;

exports[`data structures compilation > atom (global symbol) > stdout 1`] = `
[
  "symbol(atom_a)",
]
`;

exports[`data structures compilation > boolean false > compiled 1`] = `
"@const_13 = constant [5 x i8] c"true\\00"
@const_14 = constant [6 x i8] c"false\\00"
@const_16 = constant [3 x i8] c"%s\\00"
@const_21 = constant i1 0
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_11 = alloca {  }
    %var_12 = load {  }, ptr %var_11
    store {  } %var_12, ptr %var_11
    %var_17 = alloca { void (i1*, {  }, i1)*, {  } }
    %var_18 = load { void (i1*, {  }, i1)*, {  } }, ptr %var_17
    %var_19 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_18, void (i1*, {  }, i1)* @"generated_print_i1", 0
    %var_20 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_19, {  } %var_12, 1
    store { void (i1*, {  }, i1)*, {  } } %var_20, ptr %var_17
    %var_22 = load i1, ptr @const_21
    %var_23 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_20, 0
    %var_24 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_20, 1
    %var_25 = alloca i1
    call void %var_23(i1* %var_25, {  } %var_24, i1 %var_22)
    %var_26 = load i1, ptr %var_25
    ret i32 0
}
define void @"generated_print_i1"(ptr sret(i1) %arg_0, {  } %arg_1, i1 %arg_2) {
  entry_0: 
    %var_15 = select i1 %arg_2, [5 x i8]* @const_13, [5 x i8]* @const_14
    call void @printf(i8* @const_16, [5 x i8]* %var_15)
    store i1 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`data structures compilation > boolean false > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_13 = constant [5 x i8] c"true\\00"
@const_14 = constant [6 x i8] c"false\\00"
@const_16 = constant [3 x i8] c"%s\\00"
@const_21 = local_unnamed_addr constant i1 false
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_16, ptr nonnull @const_14)
  ret i32 0
}

define void @generated_print_i1(ptr nocapture writeonly sret(i1) %arg_0, {} %arg_1, i1 %arg_2) local_unnamed_addr {
entry_0:
  %var_15 = select i1 %arg_2, ptr @const_13, ptr @const_14
  tail call void @printf(ptr nonnull @const_16, ptr nonnull %var_15)
  store i1 %arg_2, ptr %arg_0, align 1
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`data structures compilation > boolean false > stderr 1`] = `[]`;

exports[`data structures compilation > boolean false > stdout 1`] = `
[
  "false",
]
`;

exports[`data structures compilation > boolean true > compiled 1`] = `
"@const_13 = constant [5 x i8] c"true\\00"
@const_14 = constant [6 x i8] c"false\\00"
@const_16 = constant [3 x i8] c"%s\\00"
@const_21 = constant i1 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_11 = alloca {  }
    %var_12 = load {  }, ptr %var_11
    store {  } %var_12, ptr %var_11
    %var_17 = alloca { void (i1*, {  }, i1)*, {  } }
    %var_18 = load { void (i1*, {  }, i1)*, {  } }, ptr %var_17
    %var_19 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_18, void (i1*, {  }, i1)* @"generated_print_i1", 0
    %var_20 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_19, {  } %var_12, 1
    store { void (i1*, {  }, i1)*, {  } } %var_20, ptr %var_17
    %var_22 = load i1, ptr @const_21
    %var_23 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_20, 0
    %var_24 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_20, 1
    %var_25 = alloca i1
    call void %var_23(i1* %var_25, {  } %var_24, i1 %var_22)
    %var_26 = load i1, ptr %var_25
    ret i32 0
}
define void @"generated_print_i1"(ptr sret(i1) %arg_0, {  } %arg_1, i1 %arg_2) {
  entry_0: 
    %var_15 = select i1 %arg_2, [5 x i8]* @const_13, [5 x i8]* @const_14
    call void @printf(i8* @const_16, [5 x i8]* %var_15)
    store i1 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`data structures compilation > boolean true > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_13 = constant [5 x i8] c"true\\00"
@const_14 = constant [6 x i8] c"false\\00"
@const_16 = constant [3 x i8] c"%s\\00"
@const_21 = local_unnamed_addr constant i1 true
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_16, ptr nonnull @const_13)
  ret i32 0
}

define void @generated_print_i1(ptr nocapture writeonly sret(i1) %arg_0, {} %arg_1, i1 %arg_2) local_unnamed_addr {
entry_0:
  %var_15 = select i1 %arg_2, ptr @const_13, ptr @const_14
  tail call void @printf(ptr nonnull @const_16, ptr nonnull %var_15)
  store i1 %arg_2, ptr %arg_0, align 1
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`data structures compilation > boolean true > stderr 1`] = `[]`;

exports[`data structures compilation > boolean true > stdout 1`] = `
[
  "true",
]
`;

exports[`data structures compilation > symbol > compiled 1`] = `
"@const_27 = constant i64 0
@const_33 = constant [10 x i8] c"symbol_ab\\00"
@symbols_metadata_array = constant [1 x { i8* }] [{ i8* } { i8* @const_33 }]
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_11 = alloca {  }
    %var_12 = load {  }, ptr %var_11
    store {  } %var_12, ptr %var_11
    %var_23 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_24 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_23
    %var_25 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_24, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_26 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_25, {  } %var_12, 1
    store { void (i64*, {  }, i64)*, {  } } %var_26, ptr %var_23
    %var_28 = load i64, ptr @const_27
    %var_29 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_26, 0
    %var_30 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_26, 1
    %var_31 = alloca i64
    call void %var_29(i64* %var_31, {  } %var_30, i64 %var_28)
    %var_32 = load i64, ptr %var_31
    ret i32 0
}
define void @"generated_print_symbol"(ptr sret(i64) %arg_0, {  } %arg_1, i64 %arg_2) {
  entry_0: 
    %var_13 = alloca {  }
    %var_14 = load {  }, ptr %var_13
    store {  } %var_14, ptr %var_13
    %var_15 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_16 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_15
    %var_17 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_16, void (i64*, {  }, i64)* @print_symbol_wrap, 0
    %var_18 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_17, {  } %var_14, 1
    store { void (i64*, {  }, i64)*, {  } } %var_18, ptr %var_15
    %var_19 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_18, 0
    %var_20 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_18, 1
    %var_21 = alloca i64
    call void %var_19(i64* %var_21, {  } %var_20, i64 %arg_2)
    %var_22 = load i64, ptr %var_21
    store i64 %arg_2, ptr %arg_0
    ret void
}
declare void @print_symbol(i64)
define void @print_symbol_wrap(ptr sret(i64) %arg_0, {  } %arg_1, i64 %arg_2) {
  entry_0: 
    call void @print_symbol(i64 %arg_2)
    store i64 %arg_2, ptr %arg_0
    ret void
}
"
`;

exports[`data structures compilation > symbol > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_27 = local_unnamed_addr constant i64 0
@const_33 = constant [10 x i8] c"symbol_ab\\00"
@symbols_metadata_array = constant [1 x { ptr }] [{ ptr } { ptr @const_33 }]
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @print_symbol(i64 0)
  ret i32 0
}

define void @generated_print_symbol(ptr nocapture writeonly sret(i64) %arg_0, {} %arg_1, i64 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @print_symbol(i64 %arg_2)
  store i64 %arg_2, ptr %arg_0, align 8
  ret void
}

declare void @print_symbol(i64) local_unnamed_addr

define void @print_symbol_wrap(ptr nocapture writeonly sret(i64) %arg_0, {} %arg_1, i64 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @print_symbol(i64 %arg_2)
  store i64 %arg_2, ptr %arg_0, align 8
  ret void
}
"
`;

exports[`data structures compilation > symbol > stderr 1`] = `[]`;

exports[`data structures compilation > symbol > stdout 1`] = `
[
  "symbol(symbol_ab)",
]
`;

exports[`data structures compilation > tuple > compiled 1`] = `
"@const_16 = constant [7 x i8] c"tuple(\\00"
@const_17 = constant [3 x i8] c"%s\\00"
@const_21 = constant [3 x i8] c"%i\\00"
@const_30 = constant [3 x i8] c", \\00"
@const_42 = constant [2 x i8] c")\\00"
@const_47 = constant i32 1
@const_52 = constant [3 x i8] c"ab\\00"
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_14 = alloca {  }
    %var_15 = load {  }, ptr %var_14
    store {  } %var_15, ptr %var_14
    %var_43 = alloca { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } }
    %var_44 = load { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } }, ptr %var_43
    %var_45 = insertvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_44, void ({ i32, i8* }*, {  }, { i32, i8* })* @"generated_print_(i32, i8*)", 0
    %var_46 = insertvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_45, {  } %var_15, 1
    store { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_46, ptr %var_43
    %var_48 = load i32, ptr @const_47
    %var_49 = alloca { i32 }
    %var_50 = load { i32 }, ptr %var_49
    %var_51 = insertvalue { i32 } %var_50, i32 %var_48, 0
    store { i32 } %var_51, ptr %var_49
    %var_53 = extractvalue { i32 } %var_51, 0
    %var_54 = alloca { i32, [3 x i8]* }
    %var_55 = load { i32, [3 x i8]* }, ptr %var_54
    %var_56 = insertvalue { i32, [3 x i8]* } %var_55, i32 %var_53, 0
    %var_57 = insertvalue { i32, [3 x i8]* } %var_56, [3 x i8]* @const_52, 1
    store { i32, [3 x i8]* } %var_57, ptr %var_54
    %var_58 = extractvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_46, 0
    %var_59 = extractvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_46, 1
    %var_60 = alloca { i32, i8* }
    call void %var_58({ i32, i8* }* %var_60, {  } %var_59, { i32, i8* } %var_57)
    %var_61 = load { i32, i8* }, ptr %var_60
    ret i32 0
}
define void @"generated_print_(i32, i8*)"(ptr sret({ i32, i8* }) %arg_0, {  } %arg_1, { i32, i8* } %arg_2) {
  entry_0: 
    call void @printf(i8* @const_17, [7 x i8]* @const_16)
    %var_18 = extractvalue { i32, i8* } %arg_2, 0
    %var_19 = alloca {  }
    %var_20 = load {  }, ptr %var_19
    store {  } %var_20, ptr %var_19
    %var_22 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_23 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_22
    %var_24 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_23, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_25 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_24, {  } %var_20, 1
    store { void (i32*, {  }, i32)*, {  } } %var_25, ptr %var_22
    %var_26 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_25, 0
    %var_27 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_25, 1
    %var_28 = alloca i32
    call void %var_26(i32* %var_28, {  } %var_27, i32 %var_18)
    %var_29 = load i32, ptr %var_28
    call void @printf(i8* @const_17, [3 x i8]* @const_30)
    %var_31 = extractvalue { i32, i8* } %arg_2, 1
    %var_32 = alloca {  }
    %var_33 = load {  }, ptr %var_32
    store {  } %var_33, ptr %var_32
    %var_34 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_35 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_34
    %var_36 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_35, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_37 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_36, {  } %var_33, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_37, ptr %var_34
    %var_38 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_37, 0
    %var_39 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_37, 1
    %var_40 = alloca i8*
    call void %var_38(i8** %var_40, {  } %var_39, i8* %var_31)
    %var_41 = load i8*, ptr %var_40
    call void @printf(i8* @const_17, [2 x i8]* @const_42)
    store { i32, i8* } %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_21, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
define void @"generated_print_i8*"(ptr sret(i8*) %arg_0, {  } %arg_1, i8* %arg_2) {
  entry_0: 
    call void @printf(i8* @const_17, i8* %arg_2)
    store i8* %arg_2, ptr %arg_0
    ret void
}
"
`;

exports[`data structures compilation > tuple > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_16 = constant [7 x i8] c"tuple(\\00"
@const_17 = constant [3 x i8] c"%s\\00"
@const_21 = constant [3 x i8] c"%i\\00"
@const_30 = constant [3 x i8] c", \\00"
@const_42 = constant [2 x i8] c")\\00"
@const_47 = local_unnamed_addr constant i32 1
@const_52 = constant [3 x i8] c"ab\\00"
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_17, ptr nonnull @const_16)
  tail call void @printf(ptr nonnull @const_21, i32 1)
  tail call void @printf(ptr nonnull @const_17, ptr nonnull @const_30)
  tail call void @printf(ptr nonnull @const_17, ptr nonnull @const_52)
  tail call void @printf(ptr nonnull @const_17, ptr nonnull @const_42)
  ret i32 0
}

define void @"generated_print_(i32, i8*)"(ptr nocapture writeonly sret({ i32, ptr }) %arg_0, {} %arg_1, { i32, ptr } %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_17, ptr nonnull @const_16)
  %var_18 = extractvalue { i32, ptr } %arg_2, 0
  tail call void @printf(ptr nonnull @const_21, i32 %var_18)
  tail call void @printf(ptr nonnull @const_17, ptr nonnull @const_30)
  %var_31 = extractvalue { i32, ptr } %arg_2, 1
  tail call void @printf(ptr nonnull @const_17, ptr %var_31)
  tail call void @printf(ptr nonnull @const_17, ptr nonnull @const_42)
  store { i32, ptr } %arg_2, ptr %arg_0, align 8
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_21, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

define void @"generated_print_i8*"(ptr nocapture writeonly sret(ptr) %arg_0, {} %arg_1, ptr %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_17, ptr %arg_2)
  store ptr %arg_2, ptr %arg_0, align 8
  ret void
}

attributes #0 = { nofree nounwind }
"
`;

exports[`data structures compilation > tuple > stderr 1`] = `[]`;

exports[`data structures compilation > tuple > stdout 1`] = `
[
  "tuple(1, ab)",
]
`;

exports[`data structures compilation > unit > compiled 1`] = `
"@const_27 = constant i64 0
@const_33 = constant [5 x i8] c"unit\\00"
@symbols_metadata_array = constant [1 x { i8* }] [{ i8* } { i8* @const_33 }]
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_11 = alloca {  }
    %var_12 = load {  }, ptr %var_11
    store {  } %var_12, ptr %var_11
    %var_23 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_24 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_23
    %var_25 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_24, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_26 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_25, {  } %var_12, 1
    store { void (i64*, {  }, i64)*, {  } } %var_26, ptr %var_23
    %var_28 = load i64, ptr @const_27
    %var_29 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_26, 0
    %var_30 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_26, 1
    %var_31 = alloca i64
    call void %var_29(i64* %var_31, {  } %var_30, i64 %var_28)
    %var_32 = load i64, ptr %var_31
    ret i32 0
}
define void @"generated_print_symbol"(ptr sret(i64) %arg_0, {  } %arg_1, i64 %arg_2) {
  entry_0: 
    %var_13 = alloca {  }
    %var_14 = load {  }, ptr %var_13
    store {  } %var_14, ptr %var_13
    %var_15 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_16 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_15
    %var_17 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_16, void (i64*, {  }, i64)* @print_symbol_wrap, 0
    %var_18 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_17, {  } %var_14, 1
    store { void (i64*, {  }, i64)*, {  } } %var_18, ptr %var_15
    %var_19 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_18, 0
    %var_20 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_18, 1
    %var_21 = alloca i64
    call void %var_19(i64* %var_21, {  } %var_20, i64 %arg_2)
    %var_22 = load i64, ptr %var_21
    store i64 %arg_2, ptr %arg_0
    ret void
}
declare void @print_symbol(i64)
define void @print_symbol_wrap(ptr sret(i64) %arg_0, {  } %arg_1, i64 %arg_2) {
  entry_0: 
    call void @print_symbol(i64 %arg_2)
    store i64 %arg_2, ptr %arg_0
    ret void
}
"
`;

exports[`data structures compilation > unit > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_27 = local_unnamed_addr constant i64 0
@const_33 = constant [5 x i8] c"unit\\00"
@symbols_metadata_array = constant [1 x { ptr }] [{ ptr } { ptr @const_33 }]
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @print_symbol(i64 0)
  ret i32 0
}

define void @generated_print_symbol(ptr nocapture writeonly sret(i64) %arg_0, {} %arg_1, i64 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @print_symbol(i64 %arg_2)
  store i64 %arg_2, ptr %arg_0, align 8
  ret void
}

declare void @print_symbol(i64) local_unnamed_addr

define void @print_symbol_wrap(ptr nocapture writeonly sret(i64) %arg_0, {} %arg_1, i64 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @print_symbol(i64 %arg_2)
  store i64 %arg_2, ptr %arg_0, align 8
  ret void
}
"
`;

exports[`data structures compilation > unit > stderr 1`] = `[]`;

exports[`data structures compilation > unit > stdout 1`] = `
[
  "symbol(unit)",
]
`;

exports[`generic print > compiled 1`] = `
"@const_94 = constant [4 x i8] c"fn[\\00"
@const_95 = constant [3 x i8] c"%s\\00"
@const_96 = constant [2 x i8] c"]\\00"
@const_118 = constant [2 x i8] c"
\\00"
@const_129 = constant [3 x i8] c"%i\\00"
@const_158 = constant i32 1
@const_208 = constant [7 x i8] c"tuple(\\00"
@const_220 = constant [3 x i8] c", \\00"
@const_232 = constant [2 x i8] c")\\00"
@const_241 = constant [3 x i8] c"ab\\00"
@const_284 = constant [3 x i8] c"%f\\00"
@const_289 = constant float 1.25
@const_327 = constant [5 x i8] c"true\\00"
@const_328 = constant [6 x i8] c"false\\00"
@const_334 = constant i1 1
@const_356 = constant i1 0
@const_388 = constant i64 0
@const_410 = constant i64 1
@const_432 = constant i64 2
@const_438 = constant [5 x i8] c"unit\\00"
@const_439 = constant [12 x i8] c"atom_atom_a\\00"
@const_440 = constant [16 x i8] c"symbol_symbol_a\\00"
@symbols_metadata_array = constant [3 x { i8* }] [{ i8* } { i8* @const_438 }, { i8* } { i8* @const_439 }, { i8* } { i8* @const_440 }]
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_91 = alloca {  }
    %var_92 = load {  }, ptr %var_91
    store {  } %var_92, ptr %var_91
    %var_97 = alloca { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } }
    %var_98 = load { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } }, ptr %var_97
    %var_99 = insertvalue { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_98, void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })* @"generated_print_i32[](i32)", 0
    %var_100 = insertvalue { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_99, {  } %var_92, 1
    store { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_100, ptr %var_97
    %var_102 = alloca {  }
    %var_103 = load {  }, ptr %var_102
    store {  } %var_103, ptr %var_102
    %var_104 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_105 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_104
    %var_106 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_105, void (i32*, {  }, i32)* @fn_101, 0
    %var_107 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_106, {  } %var_103, 1
    store { void (i32*, {  }, i32)*, {  } } %var_107, ptr %var_104
    %var_108 = extractvalue { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_100, 0
    %var_109 = extractvalue { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_100, 1
    %var_110 = alloca { void (i32*, {  }, i32)*, {  } }
    call void %var_108({ void (i32*, {  }, i32)*, {  } }* %var_110, {  } %var_109, { void (i32*, {  }, i32)*, {  } } %var_107)
    %var_111 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_110
    %var_112 = alloca {  }
    %var_113 = load {  }, ptr %var_112
    store {  } %var_113, ptr %var_112
    %var_114 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_115 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_114
    %var_116 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_115, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_117 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_116, {  } %var_113, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_117, ptr %var_114
    %var_119 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_117, 0
    %var_120 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_117, 1
    %var_121 = alloca i8*
    call void %var_119(i8** %var_121, {  } %var_120, i8* @const_118)
    %var_122 = load i8*, ptr %var_121
    %var_123 = alloca {  }
    %var_124 = load {  }, ptr %var_123
    store {  } %var_124, ptr %var_123
    %var_138 = alloca { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } }
    %var_139 = load { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } }, ptr %var_138
    %var_140 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } } %var_139, void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })* @"generated_print_i32[i32](i32)", 0
    %var_141 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } } %var_140, {  } %var_124, 1
    store { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } } %var_141, ptr %var_138
    %var_143 = alloca {  }
    %var_144 = load {  }, ptr %var_143
    store {  } %var_144, ptr %var_143
    %var_154 = alloca { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }
    %var_155 = load { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_154
    %var_156 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_155, void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)* @fn_142, 0
    %var_157 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_156, {  } %var_144, 1
    store { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_157, ptr %var_154
    %var_159 = load i32, ptr @const_158
    %var_160 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_157, 0
    %var_161 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_157, 1
    %var_162 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    call void %var_160({ void (i32*, { i32 }, i32)*, { i32 } }* %var_162, {  } %var_161, i32 %var_159)
    %var_163 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_162
    %var_164 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } } %var_141, 0
    %var_165 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } } %var_141, 1
    %var_166 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    call void %var_164({ void (i32*, { i32 }, i32)*, { i32 } }* %var_166, {  } %var_165, { void (i32*, { i32 }, i32)*, { i32 } } %var_163)
    %var_167 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_166
    %var_168 = alloca {  }
    %var_169 = load {  }, ptr %var_168
    store {  } %var_169, ptr %var_168
    %var_170 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_171 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_170
    %var_172 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_171, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_173 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_172, {  } %var_169, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_173, ptr %var_170
    %var_174 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_173, 0
    %var_175 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_173, 1
    %var_176 = alloca i8*
    call void %var_174(i8** %var_176, {  } %var_175, i8* @const_118)
    %var_177 = load i8*, ptr %var_176
    %var_178 = alloca {  }
    %var_179 = load {  }, ptr %var_178
    store {  } %var_179, ptr %var_178
    %var_181 = alloca { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } }
    %var_182 = load { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } }, ptr %var_181
    %var_183 = insertvalue { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_182, void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })* @"generated_print_i32[](i32, i32)", 0
    %var_184 = insertvalue { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_183, {  } %var_179, 1
    store { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_184, ptr %var_181
    %var_186 = alloca {  }
    %var_187 = load {  }, ptr %var_186
    store {  } %var_187, ptr %var_186
    %var_188 = alloca { void (i32*, {  }, i32, i32)*, {  } }
    %var_189 = load { void (i32*, {  }, i32, i32)*, {  } }, ptr %var_188
    %var_190 = insertvalue { void (i32*, {  }, i32, i32)*, {  } } %var_189, void (i32*, {  }, i32, i32)* @fn_185, 0
    %var_191 = insertvalue { void (i32*, {  }, i32, i32)*, {  } } %var_190, {  } %var_187, 1
    store { void (i32*, {  }, i32, i32)*, {  } } %var_191, ptr %var_188
    %var_192 = extractvalue { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_184, 0
    %var_193 = extractvalue { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_184, 1
    %var_194 = alloca { void (i32*, {  }, i32, i32)*, {  } }
    call void %var_192({ void (i32*, {  }, i32, i32)*, {  } }* %var_194, {  } %var_193, { void (i32*, {  }, i32, i32)*, {  } } %var_191)
    %var_195 = load { void (i32*, {  }, i32, i32)*, {  } }, ptr %var_194
    %var_196 = alloca {  }
    %var_197 = load {  }, ptr %var_196
    store {  } %var_197, ptr %var_196
    %var_198 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_199 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_198
    %var_200 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_199, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_201 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_200, {  } %var_197, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_201, ptr %var_198
    %var_202 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_201, 0
    %var_203 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_201, 1
    %var_204 = alloca i8*
    call void %var_202(i8** %var_204, {  } %var_203, i8* @const_118)
    %var_205 = load i8*, ptr %var_204
    %var_206 = alloca {  }
    %var_207 = load {  }, ptr %var_206
    store {  } %var_207, ptr %var_206
    %var_233 = alloca { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } }
    %var_234 = load { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } }, ptr %var_233
    %var_235 = insertvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_234, void ({ i32, i8* }*, {  }, { i32, i8* })* @"generated_print_(i32, i8*)", 0
    %var_236 = insertvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_235, {  } %var_207, 1
    store { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_236, ptr %var_233
    %var_237 = load i32, ptr @const_158
    %var_238 = alloca { i32 }
    %var_239 = load { i32 }, ptr %var_238
    %var_240 = insertvalue { i32 } %var_239, i32 %var_237, 0
    store { i32 } %var_240, ptr %var_238
    %var_242 = extractvalue { i32 } %var_240, 0
    %var_243 = alloca { i32, [3 x i8]* }
    %var_244 = load { i32, [3 x i8]* }, ptr %var_243
    %var_245 = insertvalue { i32, [3 x i8]* } %var_244, i32 %var_242, 0
    %var_246 = insertvalue { i32, [3 x i8]* } %var_245, [3 x i8]* @const_241, 1
    store { i32, [3 x i8]* } %var_246, ptr %var_243
    %var_247 = extractvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_236, 0
    %var_248 = extractvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_236, 1
    %var_249 = alloca { i32, i8* }
    call void %var_247({ i32, i8* }* %var_249, {  } %var_248, { i32, i8* } %var_246)
    %var_250 = load { i32, i8* }, ptr %var_249
    %var_251 = alloca {  }
    %var_252 = load {  }, ptr %var_251
    store {  } %var_252, ptr %var_251
    %var_253 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_254 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_253
    %var_255 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_254, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_256 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_255, {  } %var_252, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_256, ptr %var_253
    %var_257 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_256, 0
    %var_258 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_256, 1
    %var_259 = alloca i8*
    call void %var_257(i8** %var_259, {  } %var_258, i8* @const_118)
    %var_260 = load i8*, ptr %var_259
    %var_261 = alloca {  }
    %var_262 = load {  }, ptr %var_261
    store {  } %var_262, ptr %var_261
    %var_263 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_264 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_263
    %var_265 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_264, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_266 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_265, {  } %var_262, 1
    store { void (i32*, {  }, i32)*, {  } } %var_266, ptr %var_263
    %var_267 = load i32, ptr @const_158
    %var_268 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_266, 0
    %var_269 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_266, 1
    %var_270 = alloca i32
    call void %var_268(i32* %var_270, {  } %var_269, i32 %var_267)
    %var_271 = load i32, ptr %var_270
    %var_272 = alloca {  }
    %var_273 = load {  }, ptr %var_272
    store {  } %var_273, ptr %var_272
    %var_274 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_275 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_274
    %var_276 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_275, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_277 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_276, {  } %var_273, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_277, ptr %var_274
    %var_278 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_277, 0
    %var_279 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_277, 1
    %var_280 = alloca i8*
    call void %var_278(i8** %var_280, {  } %var_279, i8* @const_118)
    %var_281 = load i8*, ptr %var_280
    %var_282 = alloca {  }
    %var_283 = load {  }, ptr %var_282
    store {  } %var_283, ptr %var_282
    %var_285 = alloca { void (float*, {  }, float)*, {  } }
    %var_286 = load { void (float*, {  }, float)*, {  } }, ptr %var_285
    %var_287 = insertvalue { void (float*, {  }, float)*, {  } } %var_286, void (float*, {  }, float)* @"generated_print_f32", 0
    %var_288 = insertvalue { void (float*, {  }, float)*, {  } } %var_287, {  } %var_283, 1
    store { void (float*, {  }, float)*, {  } } %var_288, ptr %var_285
    %var_290 = load float, ptr @const_289
    %var_291 = extractvalue { void (float*, {  }, float)*, {  } } %var_288, 0
    %var_292 = extractvalue { void (float*, {  }, float)*, {  } } %var_288, 1
    %var_293 = alloca float
    call void %var_291(float* %var_293, {  } %var_292, float %var_290)
    %var_294 = load float, ptr %var_293
    %var_295 = alloca {  }
    %var_296 = load {  }, ptr %var_295
    store {  } %var_296, ptr %var_295
    %var_297 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_298 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_297
    %var_299 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_298, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_300 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_299, {  } %var_296, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_300, ptr %var_297
    %var_301 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_300, 0
    %var_302 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_300, 1
    %var_303 = alloca i8*
    call void %var_301(i8** %var_303, {  } %var_302, i8* @const_118)
    %var_304 = load i8*, ptr %var_303
    %var_305 = alloca {  }
    %var_306 = load {  }, ptr %var_305
    store {  } %var_306, ptr %var_305
    %var_307 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_308 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_307
    %var_309 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_308, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_310 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_309, {  } %var_306, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_310, ptr %var_307
    %var_311 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_310, 0
    %var_312 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_310, 1
    %var_313 = alloca i8*
    call void %var_311(i8** %var_313, {  } %var_312, i8* @const_241)
    %var_314 = load i8*, ptr %var_313
    %var_315 = alloca {  }
    %var_316 = load {  }, ptr %var_315
    store {  } %var_316, ptr %var_315
    %var_317 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_318 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_317
    %var_319 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_318, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_320 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_319, {  } %var_316, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_320, ptr %var_317
    %var_321 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_320, 0
    %var_322 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_320, 1
    %var_323 = alloca i8*
    call void %var_321(i8** %var_323, {  } %var_322, i8* @const_118)
    %var_324 = load i8*, ptr %var_323
    %var_325 = alloca {  }
    %var_326 = load {  }, ptr %var_325
    store {  } %var_326, ptr %var_325
    %var_330 = alloca { void (i1*, {  }, i1)*, {  } }
    %var_331 = load { void (i1*, {  }, i1)*, {  } }, ptr %var_330
    %var_332 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_331, void (i1*, {  }, i1)* @"generated_print_i1", 0
    %var_333 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_332, {  } %var_326, 1
    store { void (i1*, {  }, i1)*, {  } } %var_333, ptr %var_330
    %var_335 = load i1, ptr @const_334
    %var_336 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_333, 0
    %var_337 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_333, 1
    %var_338 = alloca i1
    call void %var_336(i1* %var_338, {  } %var_337, i1 %var_335)
    %var_339 = load i1, ptr %var_338
    %var_340 = alloca {  }
    %var_341 = load {  }, ptr %var_340
    store {  } %var_341, ptr %var_340
    %var_342 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_343 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_342
    %var_344 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_343, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_345 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_344, {  } %var_341, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_345, ptr %var_342
    %var_346 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_345, 0
    %var_347 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_345, 1
    %var_348 = alloca i8*
    call void %var_346(i8** %var_348, {  } %var_347, i8* @const_118)
    %var_349 = load i8*, ptr %var_348
    %var_350 = alloca {  }
    %var_351 = load {  }, ptr %var_350
    store {  } %var_351, ptr %var_350
    %var_352 = alloca { void (i1*, {  }, i1)*, {  } }
    %var_353 = load { void (i1*, {  }, i1)*, {  } }, ptr %var_352
    %var_354 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_353, void (i1*, {  }, i1)* @"generated_print_i1", 0
    %var_355 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_354, {  } %var_351, 1
    store { void (i1*, {  }, i1)*, {  } } %var_355, ptr %var_352
    %var_357 = load i1, ptr @const_356
    %var_358 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_355, 0
    %var_359 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_355, 1
    %var_360 = alloca i1
    call void %var_358(i1* %var_360, {  } %var_359, i1 %var_357)
    %var_361 = load i1, ptr %var_360
    %var_362 = alloca {  }
    %var_363 = load {  }, ptr %var_362
    store {  } %var_363, ptr %var_362
    %var_364 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_365 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_364
    %var_366 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_365, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_367 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_366, {  } %var_363, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_367, ptr %var_364
    %var_368 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_367, 0
    %var_369 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_367, 1
    %var_370 = alloca i8*
    call void %var_368(i8** %var_370, {  } %var_369, i8* @const_118)
    %var_371 = load i8*, ptr %var_370
    %var_372 = alloca {  }
    %var_373 = load {  }, ptr %var_372
    store {  } %var_373, ptr %var_372
    %var_384 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_385 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_384
    %var_386 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_385, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_387 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_386, {  } %var_373, 1
    store { void (i64*, {  }, i64)*, {  } } %var_387, ptr %var_384
    %var_389 = load i64, ptr @const_388
    %var_390 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_387, 0
    %var_391 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_387, 1
    %var_392 = alloca i64
    call void %var_390(i64* %var_392, {  } %var_391, i64 %var_389)
    %var_393 = load i64, ptr %var_392
    %var_394 = alloca {  }
    %var_395 = load {  }, ptr %var_394
    store {  } %var_395, ptr %var_394
    %var_396 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_397 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_396
    %var_398 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_397, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_399 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_398, {  } %var_395, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_399, ptr %var_396
    %var_400 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_399, 0
    %var_401 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_399, 1
    %var_402 = alloca i8*
    call void %var_400(i8** %var_402, {  } %var_401, i8* @const_118)
    %var_403 = load i8*, ptr %var_402
    %var_404 = alloca {  }
    %var_405 = load {  }, ptr %var_404
    store {  } %var_405, ptr %var_404
    %var_406 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_407 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_406
    %var_408 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_407, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_409 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_408, {  } %var_405, 1
    store { void (i64*, {  }, i64)*, {  } } %var_409, ptr %var_406
    %var_411 = load i64, ptr @const_410
    %var_412 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_409, 0
    %var_413 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_409, 1
    %var_414 = alloca i64
    call void %var_412(i64* %var_414, {  } %var_413, i64 %var_411)
    %var_415 = load i64, ptr %var_414
    %var_416 = alloca {  }
    %var_417 = load {  }, ptr %var_416
    store {  } %var_417, ptr %var_416
    %var_418 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_419 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_418
    %var_420 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_419, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_421 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_420, {  } %var_417, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_421, ptr %var_418
    %var_422 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_421, 0
    %var_423 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_421, 1
    %var_424 = alloca i8*
    call void %var_422(i8** %var_424, {  } %var_423, i8* @const_118)
    %var_425 = load i8*, ptr %var_424
    %var_426 = alloca {  }
    %var_427 = load {  }, ptr %var_426
    store {  } %var_427, ptr %var_426
    %var_428 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_429 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_428
    %var_430 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_429, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_431 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_430, {  } %var_427, 1
    store { void (i64*, {  }, i64)*, {  } } %var_431, ptr %var_428
    %var_433 = load i64, ptr @const_432
    %var_434 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_431, 0
    %var_435 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_431, 1
    %var_436 = alloca i64
    call void %var_434(i64* %var_436, {  } %var_435, i64 %var_433)
    %var_437 = load i64, ptr %var_436
    ret i32 0
}
define void @"generated_print_i32[](i32)"(ptr sret({ void (i32*, {  }, i32)*, {  } }) %arg_0, {  } %arg_1, { void (i32*, {  }, i32)*, {  } } %arg_2) {
  entry_0: 
    %var_93 = extractvalue { void (i32*, {  }, i32)*, {  } } %arg_2, 1
    call void @printf(i8* @const_95, [4 x i8]* @const_94)
    call void @printf(i8* @const_95, [2 x i8]* @const_96)
    store { void (i32*, {  }, i32)*, {  } } %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_101(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    store i32 %arg_2, ptr %arg_0
    ret void
}
define void @"generated_print_i8*"(ptr sret(i8*) %arg_0, {  } %arg_1, i8* %arg_2) {
  entry_0: 
    call void @printf(i8* @const_95, i8* %arg_2)
    store i8* %arg_2, ptr %arg_0
    ret void
}
define void @"generated_print_i32[i32](i32)"(ptr sret({ void (i32*, { i32 }, i32)*, { i32 } }) %arg_0, {  } %arg_1, { void (i32*, { i32 }, i32)*, { i32 } } %arg_2) {
  entry_0: 
    %var_125 = extractvalue { void (i32*, { i32 }, i32)*, { i32 } } %arg_2, 1
    call void @printf(i8* @const_95, [4 x i8]* @const_94)
    %var_126 = extractvalue { i32 } %var_125, 0
    %var_127 = alloca {  }
    %var_128 = load {  }, ptr %var_127
    store {  } %var_128, ptr %var_127
    %var_130 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_131 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_130
    %var_132 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_131, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_133 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_132, {  } %var_128, 1
    store { void (i32*, {  }, i32)*, {  } } %var_133, ptr %var_130
    %var_134 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_133, 0
    %var_135 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_133, 1
    %var_136 = alloca i32
    call void %var_134(i32* %var_136, {  } %var_135, i32 %var_126)
    %var_137 = load i32, ptr %var_136
    call void @printf(i8* @const_95, [2 x i8]* @const_96)
    store { void (i32*, { i32 }, i32)*, { i32 } } %arg_2, ptr %arg_0
    ret void
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_129, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
define void @fn_142(ptr sret({ void (i32*, { i32 }, i32)*, { i32 } }) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_146 = alloca { i32 }
    %var_147 = load { i32 }, ptr %var_146
    %var_148 = insertvalue { i32 } %var_147, i32 %arg_2, 0
    store { i32 } %var_148, ptr %var_146
    %var_150 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    %var_151 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_150
    %var_152 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_151, void (i32*, { i32 }, i32)* @fn_145, 0
    %var_153 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_152, { i32 } %var_148, 1
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_153, ptr %var_150
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_153, ptr %arg_0
    ret void
}
define void @fn_145(ptr sret(i32) %arg_0, { i32 } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_149 = extractvalue { i32 } %arg_1, 0
    store i32 %var_149, ptr %arg_0
    ret void
}
define void @"generated_print_i32[](i32, i32)"(ptr sret({ void (i32*, {  }, i32, i32)*, {  } }) %arg_0, {  } %arg_1, { void (i32*, {  }, i32, i32)*, {  } } %arg_2) {
  entry_0: 
    %var_180 = extractvalue { void (i32*, {  }, i32, i32)*, {  } } %arg_2, 1
    call void @printf(i8* @const_95, [4 x i8]* @const_94)
    call void @printf(i8* @const_95, [2 x i8]* @const_96)
    store { void (i32*, {  }, i32, i32)*, {  } } %arg_2, ptr %arg_0
    ret void
}
define void @fn_185(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2, i32 %arg_3) {
  entry_0: 
    store i32 %arg_2, ptr %arg_0
    ret void
}
define void @"generated_print_(i32, i8*)"(ptr sret({ i32, i8* }) %arg_0, {  } %arg_1, { i32, i8* } %arg_2) {
  entry_0: 
    call void @printf(i8* @const_95, [7 x i8]* @const_208)
    %var_209 = extractvalue { i32, i8* } %arg_2, 0
    %var_210 = alloca {  }
    %var_211 = load {  }, ptr %var_210
    store {  } %var_211, ptr %var_210
    %var_212 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_213 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_212
    %var_214 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_213, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_215 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_214, {  } %var_211, 1
    store { void (i32*, {  }, i32)*, {  } } %var_215, ptr %var_212
    %var_216 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_215, 0
    %var_217 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_215, 1
    %var_218 = alloca i32
    call void %var_216(i32* %var_218, {  } %var_217, i32 %var_209)
    %var_219 = load i32, ptr %var_218
    call void @printf(i8* @const_95, [3 x i8]* @const_220)
    %var_221 = extractvalue { i32, i8* } %arg_2, 1
    %var_222 = alloca {  }
    %var_223 = load {  }, ptr %var_222
    store {  } %var_223, ptr %var_222
    %var_224 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_225 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_224
    %var_226 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_225, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_227 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_226, {  } %var_223, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_227, ptr %var_224
    %var_228 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_227, 0
    %var_229 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_227, 1
    %var_230 = alloca i8*
    call void %var_228(i8** %var_230, {  } %var_229, i8* %var_221)
    %var_231 = load i8*, ptr %var_230
    call void @printf(i8* @const_95, [2 x i8]* @const_232)
    store { i32, i8* } %arg_2, ptr %arg_0
    ret void
}
define void @"generated_print_f32"(ptr sret(float) %arg_0, {  } %arg_1, float %arg_2) {
  entry_0: 
    call void @printf(i8* @const_284, float %arg_2)
    store float %arg_2, ptr %arg_0
    ret void
}
define void @"generated_print_i1"(ptr sret(i1) %arg_0, {  } %arg_1, i1 %arg_2) {
  entry_0: 
    %var_329 = select i1 %arg_2, [5 x i8]* @const_327, [5 x i8]* @const_328
    call void @printf(i8* @const_95, [5 x i8]* %var_329)
    store i1 %arg_2, ptr %arg_0
    ret void
}
define void @"generated_print_symbol"(ptr sret(i64) %arg_0, {  } %arg_1, i64 %arg_2) {
  entry_0: 
    %var_374 = alloca {  }
    %var_375 = load {  }, ptr %var_374
    store {  } %var_375, ptr %var_374
    %var_376 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_377 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_376
    %var_378 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_377, void (i64*, {  }, i64)* @print_symbol_wrap, 0
    %var_379 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_378, {  } %var_375, 1
    store { void (i64*, {  }, i64)*, {  } } %var_379, ptr %var_376
    %var_380 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_379, 0
    %var_381 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_379, 1
    %var_382 = alloca i64
    call void %var_380(i64* %var_382, {  } %var_381, i64 %arg_2)
    %var_383 = load i64, ptr %var_382
    store i64 %arg_2, ptr %arg_0
    ret void
}
declare void @print_symbol(i64)
define void @print_symbol_wrap(ptr sret(i64) %arg_0, {  } %arg_1, i64 %arg_2) {
  entry_0: 
    call void @print_symbol(i64 %arg_2)
    store i64 %arg_2, ptr %arg_0
    ret void
}
"
`;

exports[`generic print > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_94 = constant [4 x i8] c"fn[\\00"
@const_95 = constant [3 x i8] c"%s\\00"
@const_96 = constant [2 x i8] c"]\\00"
@const_118 = constant [2 x i8] c"\\0A\\00"
@const_129 = constant [3 x i8] c"%i\\00"
@const_158 = local_unnamed_addr constant i32 1
@const_208 = constant [7 x i8] c"tuple(\\00"
@const_220 = constant [3 x i8] c", \\00"
@const_232 = constant [2 x i8] c")\\00"
@const_241 = constant [3 x i8] c"ab\\00"
@const_284 = constant [3 x i8] c"%f\\00"
@const_289 = local_unnamed_addr constant float 1.250000e+00
@const_327 = constant [5 x i8] c"true\\00"
@const_328 = constant [6 x i8] c"false\\00"
@const_334 = local_unnamed_addr constant i1 true
@const_356 = local_unnamed_addr constant i1 false
@const_388 = local_unnamed_addr constant i64 0
@const_410 = local_unnamed_addr constant i64 1
@const_432 = local_unnamed_addr constant i64 2
@const_438 = constant [5 x i8] c"unit\\00"
@const_439 = constant [12 x i8] c"atom_atom_a\\00"
@const_440 = constant [16 x i8] c"symbol_symbol_a\\00"
@symbols_metadata_array = constant [3 x { ptr }] [{ ptr } { ptr @const_438 }, { ptr } { ptr @const_439 }, { ptr } { ptr @const_440 }]
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_94)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_96)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_118)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_94)
  tail call void @printf(ptr nonnull @const_129, i32 1)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_96)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_118)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_94)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_96)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_118)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_208)
  tail call void @printf(ptr nonnull @const_129, i32 1)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_220)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_241)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_232)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_118)
  tail call void @printf(ptr nonnull @const_129, i32 1)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_118)
  tail call void @printf(ptr nonnull @const_284, float 1.250000e+00)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_118)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_241)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_118)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_327)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_118)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_328)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_118)
  tail call void @print_symbol(i64 0)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_118)
  tail call void @print_symbol(i64 1)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_118)
  tail call void @print_symbol(i64 2)
  ret i32 0
}

define void @"generated_print_i32[](i32)"(ptr nocapture writeonly sret({ ptr, {} }) %arg_0, {} %arg_1, { ptr, {} } %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_94)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_96)
  %arg_2.elt = extractvalue { ptr, {} } %arg_2, 0
  store ptr %arg_2.elt, ptr %arg_0, align 8
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_101(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

define void @"generated_print_i8*"(ptr nocapture writeonly sret(ptr) %arg_0, {} %arg_1, ptr %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_95, ptr %arg_2)
  store ptr %arg_2, ptr %arg_0, align 8
  ret void
}

define void @"generated_print_i32[i32](i32)"(ptr nocapture writeonly sret({ ptr, { i32 } }) %arg_0, {} %arg_1, { ptr, { i32 } } %arg_2) local_unnamed_addr {
entry_0:
  %var_125 = extractvalue { ptr, { i32 } } %arg_2, 1
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_94)
  %var_126 = extractvalue { i32 } %var_125, 0
  tail call void @printf(ptr nonnull @const_129, i32 %var_126)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_96)
  store { ptr, { i32 } } %arg_2, ptr %arg_0, align 8
  ret void
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_129, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_142(ptr nocapture writeonly sret({ ptr, { i32 } }) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  %var_148 = insertvalue { i32 } undef, i32 %arg_2, 0
  %var_153 = insertvalue { ptr, { i32 } } { ptr @fn_145, { i32 } undef }, { i32 } %var_148, 1
  store { ptr, { i32 } } %var_153, ptr %arg_0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_145(ptr nocapture writeonly sret(i32) %arg_0, { i32 } %arg_1, i32 %arg_2) #1 {
entry_0:
  %var_149 = extractvalue { i32 } %arg_1, 0
  store i32 %var_149, ptr %arg_0, align 4
  ret void
}

define void @"generated_print_i32[](i32, i32)"(ptr nocapture writeonly sret({ ptr, {} }) %arg_0, {} %arg_1, { ptr, {} } %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_94)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_96)
  %arg_2.elt = extractvalue { ptr, {} } %arg_2, 0
  store ptr %arg_2.elt, ptr %arg_0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_185(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2, i32 %arg_3) local_unnamed_addr #1 {
entry_0:
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

define void @"generated_print_(i32, i8*)"(ptr nocapture writeonly sret({ i32, ptr }) %arg_0, {} %arg_1, { i32, ptr } %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_208)
  %var_209 = extractvalue { i32, ptr } %arg_2, 0
  tail call void @printf(ptr nonnull @const_129, i32 %var_209)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_220)
  %var_221 = extractvalue { i32, ptr } %arg_2, 1
  tail call void @printf(ptr nonnull @const_95, ptr %var_221)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_232)
  store { i32, ptr } %arg_2, ptr %arg_0, align 8
  ret void
}

define void @generated_print_f32(ptr nocapture writeonly sret(float) %arg_0, {} %arg_1, float %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_284, float %arg_2)
  store float %arg_2, ptr %arg_0, align 4
  ret void
}

define void @generated_print_i1(ptr nocapture writeonly sret(i1) %arg_0, {} %arg_1, i1 %arg_2) local_unnamed_addr {
entry_0:
  %var_329 = select i1 %arg_2, ptr @const_327, ptr @const_328
  tail call void @printf(ptr nonnull @const_95, ptr nonnull %var_329)
  store i1 %arg_2, ptr %arg_0, align 1
  ret void
}

define void @generated_print_symbol(ptr nocapture writeonly sret(i64) %arg_0, {} %arg_1, i64 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @print_symbol(i64 %arg_2)
  store i64 %arg_2, ptr %arg_0, align 8
  ret void
}

declare void @print_symbol(i64) local_unnamed_addr

define void @print_symbol_wrap(ptr nocapture writeonly sret(i64) %arg_0, {} %arg_1, i64 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @print_symbol(i64 %arg_2)
  store i64 %arg_2, ptr %arg_0, align 8
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`generic print > stderr 1`] = `[]`;

exports[`generic print > stdout 1`] = `
[
  "fn[]
fn[1]
fn[]
tuple(1, ab)
1
0.000000
ab
true
false
symbol(unit)
symbol(atom_atom_a)
symbol(symbol_symbol_a)",
]
`;

exports[`simply typed lambda calc compilation > apply > compiled 1`] = `
"@const_25 = constant [3 x i8] c"%i\\00"
@const_61 = constant i32 2
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_23 = alloca {  }
    %var_24 = load {  }, ptr %var_23
    store {  } %var_24, ptr %var_23
    %var_26 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_27 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_26
    %var_28 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_27, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_29 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_28, {  } %var_24, 1
    store { void (i32*, {  }, i32)*, {  } } %var_29, ptr %var_26
    %var_31 = alloca {  }
    %var_32 = load {  }, ptr %var_31
    store {  } %var_32, ptr %var_31
    %var_46 = alloca { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } }
    %var_47 = load { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } }, ptr %var_46
    %var_48 = insertvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_47, void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })* @fn_30, 0
    %var_49 = insertvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_48, {  } %var_32, 1
    store { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_49, ptr %var_46
    %var_51 = alloca {  }
    %var_52 = load {  }, ptr %var_51
    store {  } %var_52, ptr %var_51
    %var_53 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_54 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_53
    %var_55 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_54, void (i32*, {  }, i32)* @fn_50, 0
    %var_56 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_55, {  } %var_52, 1
    store { void (i32*, {  }, i32)*, {  } } %var_56, ptr %var_53
    %var_57 = extractvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_49, 0
    %var_58 = extractvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_49, 1
    %var_59 = alloca { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }
    call void %var_57({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }* %var_59, {  } %var_58, { void (i32*, {  }, i32)*, {  } } %var_56)
    %var_60 = load { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }, ptr %var_59
    %var_62 = load i32, ptr @const_61
    %var_63 = extractvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_60, 0
    %var_64 = extractvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_60, 1
    %var_65 = alloca i32
    call void %var_63(i32* %var_65, { { void (i32*, {  }, i32)*, {  } } } %var_64, i32 %var_62)
    %var_66 = load i32, ptr %var_65
    %var_67 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_29, 0
    %var_68 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_29, 1
    %var_69 = alloca i32
    call void %var_67(i32* %var_69, {  } %var_68, i32 %var_66)
    %var_70 = load i32, ptr %var_69
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_25, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_30(ptr sret({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }) %arg_0, {  } %arg_1, { void (i32*, {  }, i32)*, {  } } %arg_2) {
  entry_0: 
    %var_34 = alloca { { void (i32*, {  }, i32)*, {  } } }
    %var_35 = load { { void (i32*, {  }, i32)*, {  } } }, ptr %var_34
    %var_36 = insertvalue { { void (i32*, {  }, i32)*, {  } } } %var_35, { void (i32*, {  }, i32)*, {  } } %arg_2, 0
    store { { void (i32*, {  }, i32)*, {  } } } %var_36, ptr %var_34
    %var_42 = alloca { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }
    %var_43 = load { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }, ptr %var_42
    %var_44 = insertvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_43, void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)* @fn_33, 0
    %var_45 = insertvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_44, { { void (i32*, {  }, i32)*, {  } } } %var_36, 1
    store { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_45, ptr %var_42
    store { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_45, ptr %arg_0
    ret void
}
define void @fn_33(ptr sret(i32) %arg_0, { { void (i32*, {  }, i32)*, {  } } } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_37 = extractvalue { { void (i32*, {  }, i32)*, {  } } } %arg_1, 0
    %var_38 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_37, 0
    %var_39 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_37, 1
    %var_40 = alloca i32
    call void %var_38(i32* %var_40, {  } %var_39, i32 %arg_2)
    %var_41 = load i32, ptr %var_40
    store i32 %var_41, ptr %arg_0
    ret void
}
define void @fn_50(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    store i32 %arg_2, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > apply > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_25 = constant [3 x i8] c"%i\\00"
@const_61 = local_unnamed_addr constant i32 2
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_25, i32 2)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_25, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_30(ptr nocapture writeonly sret({ ptr, { { ptr, {} } } }) %arg_0, {} %arg_1, { ptr, {} } %arg_2) local_unnamed_addr #1 {
entry_0:
  store ptr @fn_33, ptr %arg_0, align 8
  %arg_0.repack1 = getelementptr inbounds { ptr, { { ptr, {} } } }, ptr %arg_0, i64 0, i32 1
  %arg_2.elt = extractvalue { ptr, {} } %arg_2, 0
  store ptr %arg_2.elt, ptr %arg_0.repack1, align 8
  ret void
}

define void @fn_33(ptr nocapture writeonly sret(i32) %arg_0, { { ptr, {} } } %arg_1, i32 %arg_2) {
entry_0:
  %var_37 = extractvalue { { ptr, {} } } %arg_1, 0
  %var_38 = extractvalue { ptr, {} } %var_37, 0
  %var_40 = alloca i32, align 4
  call void %var_38(ptr nonnull %var_40, {} zeroinitializer, i32 %arg_2)
  %var_41 = load i32, ptr %var_40, align 4
  store i32 %var_41, ptr %arg_0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_50(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > apply > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > apply > stdout 1`] = `
[
  "2",
]
`;

exports[`simply typed lambda calc compilation > church tuple > compiled 1`] = `
"@const_33 = constant [3 x i8] c"%i\\00"
@const_73 = constant i32 1
@const_79 = constant i32 2
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_31 = alloca {  }
    %var_32 = load {  }, ptr %var_31
    store {  } %var_32, ptr %var_31
    %var_34 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_35 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_34
    %var_36 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_35, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_37 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_36, {  } %var_32, 1
    store { void (i32*, {  }, i32)*, {  } } %var_37, ptr %var_34
    %var_39 = alloca {  }
    %var_40 = load {  }, ptr %var_39
    store {  } %var_40, ptr %var_39
    %var_69 = alloca { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }
    %var_70 = load { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_69
    %var_71 = insertvalue { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_70, void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)* @fn_38, 0
    %var_72 = insertvalue { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_71, {  } %var_40, 1
    store { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_72, ptr %var_69
    %var_74 = load i32, ptr @const_73
    %var_75 = extractvalue { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_72, 0
    %var_76 = extractvalue { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_72, 1
    %var_77 = alloca { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }
    call void %var_75({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }* %var_77, {  } %var_76, i32 %var_74)
    %var_78 = load { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }, ptr %var_77
    %var_80 = load i32, ptr @const_79
    %var_81 = extractvalue { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_78, 0
    %var_82 = extractvalue { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_78, 1
    %var_83 = alloca { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }
    call void %var_81({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }* %var_83, { i32 } %var_82, i32 %var_80)
    %var_84 = load { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }, ptr %var_83
    %var_86 = alloca {  }
    %var_87 = load {  }, ptr %var_86
    store {  } %var_87, ptr %var_86
    %var_97 = alloca { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }
    %var_98 = load { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_97
    %var_99 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_98, void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)* @fn_85, 0
    %var_100 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_99, {  } %var_87, 1
    store { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_100, ptr %var_97
    %var_101 = extractvalue { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_84, 0
    %var_102 = extractvalue { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_84, 1
    %var_103 = alloca i32
    call void %var_101(i32* %var_103, { i32, i32 } %var_102, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_100)
    %var_104 = load i32, ptr %var_103
    %var_105 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_37, 0
    %var_106 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_37, 1
    %var_107 = alloca i32
    call void %var_105(i32* %var_107, {  } %var_106, i32 %var_104)
    %var_108 = load i32, ptr %var_107
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_33, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_38(ptr sret({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_42 = alloca { i32 }
    %var_43 = load { i32 }, ptr %var_42
    %var_44 = insertvalue { i32 } %var_43, i32 %arg_2, 0
    store { i32 } %var_44, ptr %var_42
    %var_65 = alloca { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }
    %var_66 = load { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }, ptr %var_65
    %var_67 = insertvalue { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_66, void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)* @fn_41, 0
    %var_68 = insertvalue { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_67, { i32 } %var_44, 1
    store { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_68, ptr %var_65
    store { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_68, ptr %arg_0
    ret void
}
define void @fn_41(ptr sret({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }) %arg_0, { i32 } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_45 = extractvalue { i32 } %arg_1, 0
    %var_47 = alloca { i32, i32 }
    %var_48 = load { i32, i32 }, ptr %var_47
    %var_49 = insertvalue { i32, i32 } %var_48, i32 %var_45, 0
    %var_50 = insertvalue { i32, i32 } %var_49, i32 %arg_2, 1
    store { i32, i32 } %var_50, ptr %var_47
    %var_61 = alloca { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }
    %var_62 = load { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }, ptr %var_61
    %var_63 = insertvalue { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_62, void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })* @fn_46, 0
    %var_64 = insertvalue { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_63, { i32, i32 } %var_50, 1
    store { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_64, ptr %var_61
    store { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_64, ptr %arg_0
    ret void
}
define void @fn_46(ptr sret(i32) %arg_0, { i32, i32 } %arg_1, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %arg_2) {
  entry_0: 
    %var_51 = extractvalue { i32, i32 } %arg_1, 0
    %var_52 = extractvalue { i32, i32 } %arg_1, 1
    %var_53 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %arg_2, 0
    %var_54 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %arg_2, 1
    %var_55 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    call void %var_53({ void (i32*, { i32 }, i32)*, { i32 } }* %var_55, {  } %var_54, i32 %var_51)
    %var_56 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_55
    %var_57 = extractvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_56, 0
    %var_58 = extractvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_56, 1
    %var_59 = alloca i32
    call void %var_57(i32* %var_59, { i32 } %var_58, i32 %var_52)
    %var_60 = load i32, ptr %var_59
    store i32 %var_60, ptr %arg_0
    ret void
}
define void @fn_85(ptr sret({ void (i32*, { i32 }, i32)*, { i32 } }) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_89 = alloca { i32 }
    %var_90 = load { i32 }, ptr %var_89
    %var_91 = insertvalue { i32 } %var_90, i32 %arg_2, 0
    store { i32 } %var_91, ptr %var_89
    %var_93 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    %var_94 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_93
    %var_95 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_94, void (i32*, { i32 }, i32)* @fn_88, 0
    %var_96 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_95, { i32 } %var_91, 1
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_96, ptr %var_93
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_96, ptr %arg_0
    ret void
}
define void @fn_88(ptr sret(i32) %arg_0, { i32 } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_92 = extractvalue { i32 } %arg_1, 0
    store i32 %var_92, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > church tuple > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_33 = constant [3 x i8] c"%i\\00"
@const_73 = local_unnamed_addr constant i32 1
@const_79 = local_unnamed_addr constant i32 2
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_33, i32 1)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_33, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_38(ptr nocapture writeonly sret({ ptr, { i32 } }) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  %var_44 = insertvalue { i32 } undef, i32 %arg_2, 0
  %var_68 = insertvalue { ptr, { i32 } } { ptr @fn_41, { i32 } undef }, { i32 } %var_44, 1
  store { ptr, { i32 } } %var_68, ptr %arg_0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_41(ptr nocapture writeonly sret({ ptr, { i32, i32 } }) %arg_0, { i32 } %arg_1, i32 %arg_2) #1 {
entry_0:
  %var_45 = extractvalue { i32 } %arg_1, 0
  store ptr @fn_46, ptr %arg_0, align 8
  %arg_0.repack1 = getelementptr inbounds { ptr, { i32, i32 } }, ptr %arg_0, i64 0, i32 1
  store i32 %var_45, ptr %arg_0.repack1, align 8
  %arg_0.repack1.repack3 = getelementptr inbounds { ptr, { i32, i32 } }, ptr %arg_0, i64 0, i32 1, i32 1
  store i32 %arg_2, ptr %arg_0.repack1.repack3, align 4
  ret void
}

define void @fn_46(ptr nocapture writeonly sret(i32) %arg_0, { i32, i32 } %arg_1, { ptr, {} } %arg_2) {
entry_0:
  %var_51 = extractvalue { i32, i32 } %arg_1, 0
  %var_52 = extractvalue { i32, i32 } %arg_1, 1
  %var_53 = extractvalue { ptr, {} } %arg_2, 0
  %var_55 = alloca { ptr, { i32 } }, align 8
  call void %var_53(ptr nonnull %var_55, {} zeroinitializer, i32 %var_51)
  %var_56.fca.0.load = load ptr, ptr %var_55, align 8
  %var_56.fca.1.0.gep = getelementptr inbounds { ptr, { i32 } }, ptr %var_55, i64 0, i32 1, i32 0
  %var_56.fca.1.0.load = load i32, ptr %var_56.fca.1.0.gep, align 8
  %var_58 = insertvalue { i32 } poison, i32 %var_56.fca.1.0.load, 0
  %var_59 = alloca i32, align 4
  call void %var_56.fca.0.load(ptr nonnull %var_59, { i32 } %var_58, i32 %var_52)
  %var_60 = load i32, ptr %var_59, align 4
  store i32 %var_60, ptr %arg_0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_85(ptr nocapture writeonly sret({ ptr, { i32 } }) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  %var_91 = insertvalue { i32 } undef, i32 %arg_2, 0
  %var_96 = insertvalue { ptr, { i32 } } { ptr @fn_88, { i32 } undef }, { i32 } %var_91, 1
  store { ptr, { i32 } } %var_96, ptr %arg_0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_88(ptr nocapture writeonly sret(i32) %arg_0, { i32 } %arg_1, i32 %arg_2) #1 {
entry_0:
  %var_92 = extractvalue { i32 } %arg_1, 0
  store i32 %var_92, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > church tuple > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > church tuple > stdout 1`] = `
[
  "1",
]
`;

exports[`simply typed lambda calc compilation > church tuple 2 > compiled 1`] = `
"@const_26 = constant [3 x i8] c"%i\\00"
@const_42 = constant i32 1
@const_44 = constant i32 2
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_24 = alloca {  }
    %var_25 = load {  }, ptr %var_24
    store {  } %var_25, ptr %var_24
    %var_27 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_28 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_27
    %var_29 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_28, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_30 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_29, {  } %var_25, 1
    store { void (i32*, {  }, i32)*, {  } } %var_30, ptr %var_27
    %var_32 = alloca {  }
    %var_33 = load {  }, ptr %var_32
    store {  } %var_33, ptr %var_32
    %var_38 = alloca { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } }
    %var_39 = load { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } }, ptr %var_38
    %var_40 = insertvalue { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_39, void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })* @fn_31, 0
    %var_41 = insertvalue { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_40, {  } %var_33, 1
    store { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_41, ptr %var_38
    %var_43 = load i32, ptr @const_42
    %var_45 = load i32, ptr @const_44
    %var_47 = alloca {  }
    %var_48 = load {  }, ptr %var_47
    store {  } %var_48, ptr %var_47
    %var_49 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_50 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_49
    %var_51 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_50, void (i32*, {  }, i32)* @fn_46, 0
    %var_52 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_51, {  } %var_48, 1
    store { void (i32*, {  }, i32)*, {  } } %var_52, ptr %var_49
    %var_53 = extractvalue { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_41, 0
    %var_54 = extractvalue { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_41, 1
    %var_55 = alloca i32
    call void %var_53(i32* %var_55, {  } %var_54, i32 %var_43, i32 %var_45, { void (i32*, {  }, i32, i32)*, {  } } %var_52)
    %var_56 = load i32, ptr %var_55
    %var_57 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_30, 0
    %var_58 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_30, 1
    %var_59 = alloca i32
    call void %var_57(i32* %var_59, {  } %var_58, i32 %var_56)
    %var_60 = load i32, ptr %var_59
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_26, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_31(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2, i32 %arg_3, { void (i32*, {  }, i32, i32)*, {  } } %arg_4) {
  entry_0: 
    %var_34 = extractvalue { void (i32*, {  }, i32, i32)*, {  } } %arg_4, 0
    %var_35 = extractvalue { void (i32*, {  }, i32, i32)*, {  } } %arg_4, 1
    %var_36 = alloca i32
    call void %var_34(i32* %var_36, {  } %var_35, i32 %arg_2, i32 %arg_3)
    %var_37 = load i32, ptr %var_36
    store i32 %var_37, ptr %arg_0
    ret void
}
define void @fn_46(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    store i32 %arg_2, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > church tuple 2 > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_26 = constant [3 x i8] c"%i\\00"
@const_42 = local_unnamed_addr constant i32 1
@const_44 = local_unnamed_addr constant i32 2
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_26, i32 1)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_26, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

define void @fn_31(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2, i32 %arg_3, { ptr, {} } %arg_4) local_unnamed_addr {
entry_0:
  %var_34 = extractvalue { ptr, {} } %arg_4, 0
  %var_36 = alloca i32, align 4
  call void %var_34(ptr nonnull %var_36, {} zeroinitializer, i32 %arg_2, i32 %arg_3)
  %var_37 = load i32, ptr %var_36, align 4
  store i32 %var_37, ptr %arg_0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_46(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > church tuple 2 > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > church tuple 2 > stdout 1`] = `
[
  "1",
]
`;

exports[`simply typed lambda calc compilation > either > compiled 1`] = `
"@const_31 = constant [3 x i8] c"%i\\00"
@const_67 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_29 = alloca {  }
    %var_30 = load {  }, ptr %var_29
    store {  } %var_30, ptr %var_29
    %var_32 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_33 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_32
    %var_34 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_33, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_35 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_34, {  } %var_30, 1
    store { void (i32*, {  }, i32)*, {  } } %var_35, ptr %var_32
    %var_37 = alloca {  }
    %var_38 = load {  }, ptr %var_37
    store {  } %var_38, ptr %var_37
    %var_63 = alloca { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } }
    %var_64 = load { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_63
    %var_65 = insertvalue { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } } %var_64, void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)* @fn_36, 0
    %var_66 = insertvalue { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } } %var_65, {  } %var_38, 1
    store { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } } %var_66, ptr %var_63
    %var_68 = load i32, ptr @const_67
    %var_69 = extractvalue { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } } %var_66, 0
    %var_70 = extractvalue { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } } %var_66, 1
    %var_71 = alloca { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }
    call void %var_69({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }* %var_71, {  } %var_70, i32 %var_68)
    %var_72 = load { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }, ptr %var_71
    %var_74 = alloca {  }
    %var_75 = load {  }, ptr %var_74
    store {  } %var_75, ptr %var_74
    %var_76 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_77 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_76
    %var_78 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_77, void (i32*, {  }, i32)* @fn_73, 0
    %var_79 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_78, {  } %var_75, 1
    store { void (i32*, {  }, i32)*, {  } } %var_79, ptr %var_76
    %var_80 = extractvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_72, 0
    %var_81 = extractvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_72, 1
    %var_82 = alloca { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }
    call void %var_80({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }* %var_82, { i32 } %var_81, { void (i32*, {  }, i32)*, {  } } %var_79)
    %var_83 = load { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }, ptr %var_82
    %var_85 = alloca {  }
    %var_86 = load {  }, ptr %var_85
    store {  } %var_86, ptr %var_85
    %var_87 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_88 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_87
    %var_89 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_88, void (i32*, {  }, i32)* @fn_84, 0
    %var_90 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_89, {  } %var_86, 1
    store { void (i32*, {  }, i32)*, {  } } %var_90, ptr %var_87
    %var_91 = extractvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_83, 0
    %var_92 = extractvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_83, 1
    %var_93 = alloca i32
    call void %var_91(i32* %var_93, { { void (i32*, {  }, i32)*, {  } }, i32 } %var_92, { void (i32*, {  }, i32)*, {  } } %var_90)
    %var_94 = load i32, ptr %var_93
    %var_95 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_35, 0
    %var_96 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_35, 1
    %var_97 = alloca i32
    call void %var_95(i32* %var_97, {  } %var_96, i32 %var_94)
    %var_98 = load i32, ptr %var_97
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_31, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_36(ptr sret({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_40 = alloca { i32 }
    %var_41 = load { i32 }, ptr %var_40
    %var_42 = insertvalue { i32 } %var_41, i32 %arg_2, 0
    store { i32 } %var_42, ptr %var_40
    %var_59 = alloca { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }
    %var_60 = load { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }, ptr %var_59
    %var_61 = insertvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_60, void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })* @fn_39, 0
    %var_62 = insertvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_61, { i32 } %var_42, 1
    store { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_62, ptr %var_59
    store { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_62, ptr %arg_0
    ret void
}
define void @fn_39(ptr sret({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }) %arg_0, { i32 } %arg_1, { void (i32*, {  }, i32)*, {  } } %arg_2) {
  entry_0: 
    %var_43 = extractvalue { i32 } %arg_1, 0
    %var_45 = alloca { { void (i32*, {  }, i32)*, {  } }, i32 }
    %var_46 = load { { void (i32*, {  }, i32)*, {  } }, i32 }, ptr %var_45
    %var_47 = insertvalue { { void (i32*, {  }, i32)*, {  } }, i32 } %var_46, { void (i32*, {  }, i32)*, {  } } %arg_2, 0
    %var_48 = insertvalue { { void (i32*, {  }, i32)*, {  } }, i32 } %var_47, i32 %var_43, 1
    store { { void (i32*, {  }, i32)*, {  } }, i32 } %var_48, ptr %var_45
    %var_55 = alloca { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }
    %var_56 = load { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }, ptr %var_55
    %var_57 = insertvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_56, void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })* @fn_44, 0
    %var_58 = insertvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_57, { { void (i32*, {  }, i32)*, {  } }, i32 } %var_48, 1
    store { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_58, ptr %var_55
    store { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_58, ptr %arg_0
    ret void
}
define void @fn_44(ptr sret(i32) %arg_0, { { void (i32*, {  }, i32)*, {  } }, i32 } %arg_1, { void (i32*, {  }, i32)*, {  } } %arg_2) {
  entry_0: 
    %var_49 = extractvalue { { void (i32*, {  }, i32)*, {  } }, i32 } %arg_1, 0
    %var_50 = extractvalue { { void (i32*, {  }, i32)*, {  } }, i32 } %arg_1, 1
    %var_51 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_49, 0
    %var_52 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_49, 1
    %var_53 = alloca i32
    call void %var_51(i32* %var_53, {  } %var_52, i32 %var_50)
    %var_54 = load i32, ptr %var_53
    store i32 %var_54, ptr %arg_0
    ret void
}
define void @fn_73(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    store i32 %arg_2, ptr %arg_0
    ret void
}
define void @fn_84(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    store i32 %arg_2, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > either > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_31 = constant [3 x i8] c"%i\\00"
@const_67 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_31, i32 1)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_31, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_36(ptr nocapture writeonly sret({ ptr, { i32 } }) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  %var_42 = insertvalue { i32 } undef, i32 %arg_2, 0
  %var_62 = insertvalue { ptr, { i32 } } { ptr @fn_39, { i32 } undef }, { i32 } %var_42, 1
  store { ptr, { i32 } } %var_62, ptr %arg_0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_39(ptr nocapture writeonly sret({ ptr, { { ptr, {} }, i32 } }) %arg_0, { i32 } %arg_1, { ptr, {} } %arg_2) #1 {
entry_0:
  %var_43 = extractvalue { i32 } %arg_1, 0
  %var_47 = insertvalue { { ptr, {} }, i32 } { { ptr, {} } { ptr undef, {} poison }, i32 undef }, { ptr, {} } %arg_2, 0
  %var_48 = insertvalue { { ptr, {} }, i32 } %var_47, i32 %var_43, 1
  store ptr @fn_44, ptr %arg_0, align 8
  %arg_0.repack1 = getelementptr inbounds { ptr, { { ptr, {} }, i32 } }, ptr %arg_0, i64 0, i32 1
  store { { ptr, {} }, i32 } %var_48, ptr %arg_0.repack1, align 8
  ret void
}

define void @fn_44(ptr nocapture writeonly sret(i32) %arg_0, { { ptr, {} }, i32 } %arg_1, { ptr, {} } %arg_2) {
entry_0:
  %var_49 = extractvalue { { ptr, {} }, i32 } %arg_1, 0
  %var_50 = extractvalue { { ptr, {} }, i32 } %arg_1, 1
  %var_51 = extractvalue { ptr, {} } %var_49, 0
  %var_53 = alloca i32, align 4
  call void %var_51(ptr nonnull %var_53, {} zeroinitializer, i32 %var_50)
  %var_54 = load i32, ptr %var_53, align 4
  store i32 %var_54, ptr %arg_0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_73(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_84(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > either > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > either > stdout 1`] = `
[
  "1",
]
`;

exports[`simply typed lambda calc compilation > either 2 > compiled 1`] = `
"@const_27 = constant [3 x i8] c"%i\\00"
@const_43 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_25 = alloca {  }
    %var_26 = load {  }, ptr %var_25
    store {  } %var_26, ptr %var_25
    %var_28 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_29 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_28
    %var_30 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_29, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_31 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_30, {  } %var_26, 1
    store { void (i32*, {  }, i32)*, {  } } %var_31, ptr %var_28
    %var_33 = alloca {  }
    %var_34 = load {  }, ptr %var_33
    store {  } %var_34, ptr %var_33
    %var_39 = alloca { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } }
    %var_40 = load { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } }, ptr %var_39
    %var_41 = insertvalue { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_40, void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })* @fn_32, 0
    %var_42 = insertvalue { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_41, {  } %var_34, 1
    store { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_42, ptr %var_39
    %var_44 = load i32, ptr @const_43
    %var_46 = alloca {  }
    %var_47 = load {  }, ptr %var_46
    store {  } %var_47, ptr %var_46
    %var_48 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_49 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_48
    %var_50 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_49, void (i32*, {  }, i32)* @fn_45, 0
    %var_51 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_50, {  } %var_47, 1
    store { void (i32*, {  }, i32)*, {  } } %var_51, ptr %var_48
    %var_53 = alloca {  }
    %var_54 = load {  }, ptr %var_53
    store {  } %var_54, ptr %var_53
    %var_55 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_56 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_55
    %var_57 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_56, void (i32*, {  }, i32)* @fn_52, 0
    %var_58 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_57, {  } %var_54, 1
    store { void (i32*, {  }, i32)*, {  } } %var_58, ptr %var_55
    %var_59 = extractvalue { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_42, 0
    %var_60 = extractvalue { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_42, 1
    %var_61 = alloca i32
    call void %var_59(i32* %var_61, {  } %var_60, i32 %var_44, { void (i32*, {  }, i32)*, {  } } %var_51, { void (i32*, {  }, i32)*, {  } } %var_58)
    %var_62 = load i32, ptr %var_61
    %var_63 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_31, 0
    %var_64 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_31, 1
    %var_65 = alloca i32
    call void %var_63(i32* %var_65, {  } %var_64, i32 %var_62)
    %var_66 = load i32, ptr %var_65
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_27, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_32(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2, { void (i32*, {  }, i32)*, {  } } %arg_3, { void (i32*, {  }, i32)*, {  } } %arg_4) {
  entry_0: 
    %var_35 = extractvalue { void (i32*, {  }, i32)*, {  } } %arg_3, 0
    %var_36 = extractvalue { void (i32*, {  }, i32)*, {  } } %arg_3, 1
    %var_37 = alloca i32
    call void %var_35(i32* %var_37, {  } %var_36, i32 %arg_2)
    %var_38 = load i32, ptr %var_37
    store i32 %var_38, ptr %arg_0
    ret void
}
define void @fn_45(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    store i32 %arg_2, ptr %arg_0
    ret void
}
define void @fn_52(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    store i32 %arg_2, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > either 2 > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_27 = constant [3 x i8] c"%i\\00"
@const_43 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_27, i32 1)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_27, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

define void @fn_32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2, { ptr, {} } %arg_3, { ptr, {} } %arg_4) local_unnamed_addr {
entry_0:
  %var_35 = extractvalue { ptr, {} } %arg_3, 0
  %var_37 = alloca i32, align 4
  call void %var_35(ptr nonnull %var_37, {} zeroinitializer, i32 %arg_2)
  %var_38 = load i32, ptr %var_37, align 4
  store i32 %var_38, ptr %arg_0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_45(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_52(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > either 2 > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > either 2 > stdout 1`] = `
[
  "1",
]
`;

exports[`simply typed lambda calc compilation > function application and literal print > compiled 1`] = `
"@const_19 = constant [3 x i8] c"%i\\00"
@const_32 = constant i32 2
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_17 = alloca {  }
    %var_18 = load {  }, ptr %var_17
    store {  } %var_18, ptr %var_17
    %var_20 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_21 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_20
    %var_22 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_21, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_23 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_22, {  } %var_18, 1
    store { void (i32*, {  }, i32)*, {  } } %var_23, ptr %var_20
    %var_25 = alloca {  }
    %var_26 = load {  }, ptr %var_25
    store {  } %var_26, ptr %var_25
    %var_28 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_29 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_28
    %var_30 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_29, void (i32*, {  }, i32)* @fn_24, 0
    %var_31 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_30, {  } %var_26, 1
    store { void (i32*, {  }, i32)*, {  } } %var_31, ptr %var_28
    %var_33 = load i32, ptr @const_32
    %var_34 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_31, 0
    %var_35 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_31, 1
    %var_36 = alloca i32
    call void %var_34(i32* %var_36, {  } %var_35, i32 %var_33)
    %var_37 = load i32, ptr %var_36
    %var_38 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_23, 0
    %var_39 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_23, 1
    %var_40 = alloca i32
    call void %var_38(i32* %var_40, {  } %var_39, i32 %var_37)
    %var_41 = load i32, ptr %var_40
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_19, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_24(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_27 = add i32 %arg_2, %arg_2
    store i32 %var_27, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > function application and literal print > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_19 = constant [3 x i8] c"%i\\00"
@const_32 = local_unnamed_addr constant i32 2
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_19, i32 4)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_19, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_24(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  %var_27 = shl i32 %arg_2, 1
  store i32 %var_27, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > function application and literal print > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > function application and literal print > stdout 1`] = `
[
  "4",
]
`;

exports[`simply typed lambda calc compilation > function closure > compiled 1`] = `
"@const_25 = constant [3 x i8] c"%i\\00"
@const_38 = constant i32 2
@const_50 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_23 = alloca {  }
    %var_24 = load {  }, ptr %var_23
    store {  } %var_24, ptr %var_23
    %var_26 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_27 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_26
    %var_28 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_27, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_29 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_28, {  } %var_24, 1
    store { void (i32*, {  }, i32)*, {  } } %var_29, ptr %var_26
    %var_31 = alloca {  }
    %var_32 = load {  }, ptr %var_31
    store {  } %var_32, ptr %var_31
    %var_46 = alloca { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }
    %var_47 = load { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_46
    %var_48 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_47, void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)* @fn_30, 0
    %var_49 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_48, {  } %var_32, 1
    store { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_49, ptr %var_46
    %var_51 = load i32, ptr @const_50
    %var_52 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_49, 0
    %var_53 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_49, 1
    %var_54 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    call void %var_52({ void (i32*, { i32 }, i32)*, { i32 } }* %var_54, {  } %var_53, i32 %var_51)
    %var_55 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_54
    %var_56 = load i32, ptr @const_38
    %var_57 = extractvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_55, 0
    %var_58 = extractvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_55, 1
    %var_59 = alloca i32
    call void %var_57(i32* %var_59, { i32 } %var_58, i32 %var_56)
    %var_60 = load i32, ptr %var_59
    %var_61 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_29, 0
    %var_62 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_29, 1
    %var_63 = alloca i32
    call void %var_61(i32* %var_63, {  } %var_62, i32 %var_60)
    %var_64 = load i32, ptr %var_63
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_25, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_30(ptr sret({ void (i32*, { i32 }, i32)*, { i32 } }) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_34 = alloca { i32 }
    %var_35 = load { i32 }, ptr %var_34
    %var_36 = insertvalue { i32 } %var_35, i32 %arg_2, 0
    store { i32 } %var_36, ptr %var_34
    %var_42 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    %var_43 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_42
    %var_44 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_43, void (i32*, { i32 }, i32)* @fn_33, 0
    %var_45 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_44, { i32 } %var_36, 1
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_45, ptr %var_42
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_45, ptr %arg_0
    ret void
}
define void @fn_33(ptr sret(i32) %arg_0, { i32 } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_37 = extractvalue { i32 } %arg_1, 0
    %var_39 = load i32, ptr @const_38
    %var_40 = mul i32 %var_39, %var_37
    %var_41 = add i32 %arg_2, %var_40
    store i32 %var_41, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > function closure > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_25 = constant [3 x i8] c"%i\\00"
@const_38 = local_unnamed_addr constant i32 2
@const_50 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_25, i32 4)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_25, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_30(ptr nocapture writeonly sret({ ptr, { i32 } }) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  %var_36 = insertvalue { i32 } undef, i32 %arg_2, 0
  %var_45 = insertvalue { ptr, { i32 } } { ptr @fn_33, { i32 } undef }, { i32 } %var_36, 1
  store { ptr, { i32 } } %var_45, ptr %arg_0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_33(ptr nocapture writeonly sret(i32) %arg_0, { i32 } %arg_1, i32 %arg_2) #1 {
entry_0:
  %var_37 = extractvalue { i32 } %arg_1, 0
  %var_40 = shl i32 %var_37, 1
  %var_41 = add i32 %var_40, %arg_2
  store i32 %var_41, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > function closure > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > function closure > stdout 1`] = `
[
  "4",
]
`;

exports[`simply typed lambda calc compilation > function deep closure > compiled 1`] = `
"@const_29 = constant [3 x i8] c"%i\\00"
@const_63 = constant i32 1
@const_69 = constant i32 3
@const_75 = constant i32 5
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_27 = alloca {  }
    %var_28 = load {  }, ptr %var_27
    store {  } %var_28, ptr %var_27
    %var_30 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_31 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_30
    %var_32 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_31, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_33 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_32, {  } %var_28, 1
    store { void (i32*, {  }, i32)*, {  } } %var_33, ptr %var_30
    %var_35 = alloca {  }
    %var_36 = load {  }, ptr %var_35
    store {  } %var_36, ptr %var_35
    %var_59 = alloca { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }
    %var_60 = load { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_59
    %var_61 = insertvalue { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_60, void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)* @fn_34, 0
    %var_62 = insertvalue { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_61, {  } %var_36, 1
    store { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_62, ptr %var_59
    %var_64 = load i32, ptr @const_63
    %var_65 = extractvalue { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_62, 0
    %var_66 = extractvalue { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_62, 1
    %var_67 = alloca { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }
    call void %var_65({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }* %var_67, {  } %var_66, i32 %var_64)
    %var_68 = load { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }, ptr %var_67
    %var_70 = load i32, ptr @const_69
    %var_71 = extractvalue { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_68, 0
    %var_72 = extractvalue { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_68, 1
    %var_73 = alloca { void (i32*, { i32, i32 }, i32)*, { i32, i32 } }
    call void %var_71({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }* %var_73, { i32 } %var_72, i32 %var_70)
    %var_74 = load { void (i32*, { i32, i32 }, i32)*, { i32, i32 } }, ptr %var_73
    %var_76 = load i32, ptr @const_75
    %var_77 = extractvalue { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_74, 0
    %var_78 = extractvalue { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_74, 1
    %var_79 = alloca i32
    call void %var_77(i32* %var_79, { i32, i32 } %var_78, i32 %var_76)
    %var_80 = load i32, ptr %var_79
    %var_81 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_33, 0
    %var_82 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_33, 1
    %var_83 = alloca i32
    call void %var_81(i32* %var_83, {  } %var_82, i32 %var_80)
    %var_84 = load i32, ptr %var_83
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_29, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_34(ptr sret({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_38 = alloca { i32 }
    %var_39 = load { i32 }, ptr %var_38
    %var_40 = insertvalue { i32 } %var_39, i32 %arg_2, 0
    store { i32 } %var_40, ptr %var_38
    %var_55 = alloca { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }
    %var_56 = load { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }, ptr %var_55
    %var_57 = insertvalue { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_56, void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)* @fn_37, 0
    %var_58 = insertvalue { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_57, { i32 } %var_40, 1
    store { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_58, ptr %var_55
    store { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_58, ptr %arg_0
    ret void
}
define void @fn_37(ptr sret({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }) %arg_0, { i32 } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_41 = extractvalue { i32 } %arg_1, 0
    %var_43 = alloca { i32, i32 }
    %var_44 = load { i32, i32 }, ptr %var_43
    %var_45 = insertvalue { i32, i32 } %var_44, i32 %var_41, 0
    %var_46 = insertvalue { i32, i32 } %var_45, i32 %arg_2, 1
    store { i32, i32 } %var_46, ptr %var_43
    %var_51 = alloca { void (i32*, { i32, i32 }, i32)*, { i32, i32 } }
    %var_52 = load { void (i32*, { i32, i32 }, i32)*, { i32, i32 } }, ptr %var_51
    %var_53 = insertvalue { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_52, void (i32*, { i32, i32 }, i32)* @fn_42, 0
    %var_54 = insertvalue { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_53, { i32, i32 } %var_46, 1
    store { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_54, ptr %var_51
    store { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_54, ptr %arg_0
    ret void
}
define void @fn_42(ptr sret(i32) %arg_0, { i32, i32 } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_47 = extractvalue { i32, i32 } %arg_1, 0
    %var_48 = extractvalue { i32, i32 } %arg_1, 1
    %var_49 = add i32 %var_48, %arg_2
    %var_50 = add i32 %var_47, %var_49
    store i32 %var_50, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > function deep closure > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_29 = constant [3 x i8] c"%i\\00"
@const_63 = local_unnamed_addr constant i32 1
@const_69 = local_unnamed_addr constant i32 3
@const_75 = local_unnamed_addr constant i32 5
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_29, i32 9)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_29, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_34(ptr nocapture writeonly sret({ ptr, { i32 } }) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  %var_40 = insertvalue { i32 } undef, i32 %arg_2, 0
  %var_58 = insertvalue { ptr, { i32 } } { ptr @fn_37, { i32 } undef }, { i32 } %var_40, 1
  store { ptr, { i32 } } %var_58, ptr %arg_0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_37(ptr nocapture writeonly sret({ ptr, { i32, i32 } }) %arg_0, { i32 } %arg_1, i32 %arg_2) #1 {
entry_0:
  %var_41 = extractvalue { i32 } %arg_1, 0
  store ptr @fn_42, ptr %arg_0, align 8
  %arg_0.repack1 = getelementptr inbounds { ptr, { i32, i32 } }, ptr %arg_0, i64 0, i32 1
  store i32 %var_41, ptr %arg_0.repack1, align 8
  %arg_0.repack1.repack3 = getelementptr inbounds { ptr, { i32, i32 } }, ptr %arg_0, i64 0, i32 1, i32 1
  store i32 %arg_2, ptr %arg_0.repack1.repack3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_42(ptr nocapture writeonly sret(i32) %arg_0, { i32, i32 } %arg_1, i32 %arg_2) #1 {
entry_0:
  %var_47 = extractvalue { i32, i32 } %arg_1, 0
  %var_48 = extractvalue { i32, i32 } %arg_1, 1
  %var_49 = add i32 %var_48, %arg_2
  %var_50 = add i32 %var_49, %var_47
  store i32 %var_50, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > function deep closure > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > function deep closure > stdout 1`] = `
[
  "9",
]
`;

exports[`simply typed lambda calc compilation > function multiple args > compiled 1`] = `
"@const_23 = constant [3 x i8] c"%i\\00"
@const_31 = constant i32 2
@const_39 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_21 = alloca {  }
    %var_22 = load {  }, ptr %var_21
    store {  } %var_22, ptr %var_21
    %var_24 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_25 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_24
    %var_26 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_25, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_27 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_26, {  } %var_22, 1
    store { void (i32*, {  }, i32)*, {  } } %var_27, ptr %var_24
    %var_29 = alloca {  }
    %var_30 = load {  }, ptr %var_29
    store {  } %var_30, ptr %var_29
    %var_35 = alloca { void (i32*, {  }, i32, i32)*, {  } }
    %var_36 = load { void (i32*, {  }, i32, i32)*, {  } }, ptr %var_35
    %var_37 = insertvalue { void (i32*, {  }, i32, i32)*, {  } } %var_36, void (i32*, {  }, i32, i32)* @fn_28, 0
    %var_38 = insertvalue { void (i32*, {  }, i32, i32)*, {  } } %var_37, {  } %var_30, 1
    store { void (i32*, {  }, i32, i32)*, {  } } %var_38, ptr %var_35
    %var_40 = load i32, ptr @const_39
    %var_41 = load i32, ptr @const_31
    %var_42 = extractvalue { void (i32*, {  }, i32, i32)*, {  } } %var_38, 0
    %var_43 = extractvalue { void (i32*, {  }, i32, i32)*, {  } } %var_38, 1
    %var_44 = alloca i32
    call void %var_42(i32* %var_44, {  } %var_43, i32 %var_40, i32 %var_41)
    %var_45 = load i32, ptr %var_44
    %var_46 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_27, 0
    %var_47 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_27, 1
    %var_48 = alloca i32
    call void %var_46(i32* %var_48, {  } %var_47, i32 %var_45)
    %var_49 = load i32, ptr %var_48
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_23, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_28(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2, i32 %arg_3) {
  entry_0: 
    %var_32 = load i32, ptr @const_31
    %var_33 = mul i32 %var_32, %arg_2
    %var_34 = add i32 %arg_3, %var_33
    store i32 %var_34, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > function multiple args > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_23 = constant [3 x i8] c"%i\\00"
@const_31 = local_unnamed_addr constant i32 2
@const_39 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_23, i32 4)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_23, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_28(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2, i32 %arg_3) local_unnamed_addr #1 {
entry_0:
  %var_33 = shl i32 %arg_2, 1
  %var_34 = add i32 %var_33, %arg_3
  store i32 %var_34, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > function multiple args > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > function multiple args > stdout 1`] = `
[
  "4",
]
`;

exports[`simply typed lambda calc compilation > hello world > compiled 1`] = `
"@const_13 = constant [3 x i8] c"%s\\00"
@const_18 = constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_11 = alloca {  }
    %var_12 = load {  }, ptr %var_11
    store {  } %var_12, ptr %var_11
    %var_14 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_15 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_14
    %var_16 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_15, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_17 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_16, {  } %var_12, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_17, ptr %var_14
    %var_19 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_17, 0
    %var_20 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_17, 1
    %var_21 = alloca i8*
    call void %var_19(i8** %var_21, {  } %var_20, i8* @const_18)
    %var_22 = load i8*, ptr %var_21
    ret i32 0
}
define void @"generated_print_i8*"(ptr sret(i8*) %arg_0, {  } %arg_1, i8* %arg_2) {
  entry_0: 
    call void @printf(i8* @const_13, i8* %arg_2)
    store i8* %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`simply typed lambda calc compilation > hello world > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_13 = constant [3 x i8] c"%s\\00"
@const_18 = constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_13, ptr nonnull @const_18)
  ret i32 0
}

define void @"generated_print_i8*"(ptr nocapture writeonly sret(ptr) %arg_0, {} %arg_1, ptr %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_13, ptr %arg_2)
  store ptr %arg_2, ptr %arg_0, align 8
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`simply typed lambda calc compilation > hello world > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > hello world > stdout 1`] = `
[
  "hello world!",
]
`;

exports[`simply typed lambda calc compilation > hello world string > compiled 1`] = `
"@const_9 = constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    ret i32 0
}
"
`;

exports[`simply typed lambda calc compilation > hello world string > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_9 = local_unnamed_addr constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef i32 @main() local_unnamed_addr #0 {
main:
  ret i32 0
}

attributes #0 = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) }
"
`;

exports[`simply typed lambda calc compilation > hello world string > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > hello world string > stdout 1`] = `[]`;

exports[`simply typed lambda calc compilation > print number > compiled 1`] = `
"@const_13 = constant [3 x i8] c"%i\\00"
@const_18 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_11 = alloca {  }
    %var_12 = load {  }, ptr %var_11
    store {  } %var_12, ptr %var_11
    %var_14 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_15 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_14
    %var_16 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_15, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_17 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_16, {  } %var_12, 1
    store { void (i32*, {  }, i32)*, {  } } %var_17, ptr %var_14
    %var_19 = load i32, ptr @const_18
    %var_20 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_17, 0
    %var_21 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_17, 1
    %var_22 = alloca i32
    call void %var_20(i32* %var_22, {  } %var_21, i32 %var_19)
    %var_23 = load i32, ptr %var_22
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_13, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`simply typed lambda calc compilation > print number > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_13 = constant [3 x i8] c"%i\\00"
@const_18 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_13, i32 1)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_13, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`simply typed lambda calc compilation > print number > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > print number > stdout 1`] = `
[
  "1",
]
`;

exports[`structured programming compilation > block > compiled 1`] = `
"@const_18 = constant [3 x i8] c"%i\\00"
@const_23 = constant i32 123
@const_25 = constant i32 234
@const_27 = constant i32 345
@const_29 = constant i32 456
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_16 = alloca {  }
    %var_17 = load {  }, ptr %var_16
    store {  } %var_17, ptr %var_16
    %var_19 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_20 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_19
    %var_21 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_20, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_22 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_21, {  } %var_17, 1
    store { void (i32*, {  }, i32)*, {  } } %var_22, ptr %var_19
    %var_24 = load i32, ptr @const_23
    %var_26 = load i32, ptr @const_25
    %var_28 = load i32, ptr @const_27
    %var_30 = load i32, ptr @const_29
    %var_31 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_22, 0
    %var_32 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_22, 1
    %var_33 = alloca i32
    call void %var_31(i32* %var_33, {  } %var_32, i32 %var_30)
    %var_34 = load i32, ptr %var_33
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_18, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > block > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_18 = constant [3 x i8] c"%i\\00"
@const_23 = local_unnamed_addr constant i32 123
@const_25 = local_unnamed_addr constant i32 234
@const_27 = local_unnamed_addr constant i32 345
@const_29 = local_unnamed_addr constant i32 456
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_18, i32 456)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_18, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > block > stderr 1`] = `[]`;

exports[`structured programming compilation > block > stdout 1`] = `
[
  "456",
]
`;

exports[`structured programming compilation > block variable assingment > compiled 1`] = `
"@const_23 = constant [3 x i8] c"%i\\00"
@const_28 = constant i32 123
@const_30 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_21 = alloca {  }
    %var_22 = load {  }, ptr %var_21
    store {  } %var_22, ptr %var_21
    %var_24 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_25 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_24
    %var_26 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_25, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_27 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_26, {  } %var_22, 1
    store { void (i32*, {  }, i32)*, {  } } %var_27, ptr %var_24
    %var_29 = load i32, ptr @const_28
    %var_31 = load i32, ptr @const_30
    %var_32 = add i32 %var_29, %var_31
    %var_33 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_27, 0
    %var_34 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_27, 1
    %var_35 = alloca i32
    call void %var_33(i32* %var_35, {  } %var_34, i32 %var_32)
    %var_36 = load i32, ptr %var_35
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_23, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > block variable assingment > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_23 = constant [3 x i8] c"%i\\00"
@const_28 = local_unnamed_addr constant i32 123
@const_30 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_23, i32 124)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_23, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > block variable assingment > stderr 1`] = `[]`;

exports[`structured programming compilation > block variable assingment > stdout 1`] = `
[
  "124",
]
`;

exports[`structured programming compilation > block variable declaration > compiled 1`] = `
"@const_18 = constant [3 x i8] c"%i\\00"
@const_23 = constant i32 123
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_16 = alloca {  }
    %var_17 = load {  }, ptr %var_16
    store {  } %var_17, ptr %var_16
    %var_19 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_20 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_19
    %var_21 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_20, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_22 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_21, {  } %var_17, 1
    store { void (i32*, {  }, i32)*, {  } } %var_22, ptr %var_19
    %var_24 = load i32, ptr @const_23
    %var_25 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_22, 0
    %var_26 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_22, 1
    %var_27 = alloca i32
    call void %var_25(i32* %var_27, {  } %var_26, i32 %var_24)
    %var_28 = load i32, ptr %var_27
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_18, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > block variable declaration > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_18 = constant [3 x i8] c"%i\\00"
@const_23 = local_unnamed_addr constant i32 123
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_18, i32 123)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_18, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > block variable declaration > stderr 1`] = `[]`;

exports[`structured programming compilation > block variable declaration > stdout 1`] = `
[
  "123",
]
`;

exports[`structured programming compilation > block variable shadowing > compiled 1`] = `
"@const_21 = constant [3 x i8] c"%i\\00"
@const_26 = constant i32 123
@const_28 = constant i32 234
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_19 = alloca {  }
    %var_20 = load {  }, ptr %var_19
    store {  } %var_20, ptr %var_19
    %var_22 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_23 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_22
    %var_24 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_23, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_25 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_24, {  } %var_20, 1
    store { void (i32*, {  }, i32)*, {  } } %var_25, ptr %var_22
    %var_27 = load i32, ptr @const_26
    %var_29 = load i32, ptr @const_28
    %var_30 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_25, 0
    %var_31 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_25, 1
    %var_32 = alloca i32
    call void %var_30(i32* %var_32, {  } %var_31, i32 %var_29)
    %var_33 = load i32, ptr %var_32
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_21, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > block variable shadowing > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_21 = constant [3 x i8] c"%i\\00"
@const_26 = local_unnamed_addr constant i32 123
@const_28 = local_unnamed_addr constant i32 234
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_21, i32 234)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_21, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > block variable shadowing > stderr 1`] = `[]`;

exports[`structured programming compilation > block variable shadowing > stdout 1`] = `
[
  "234",
]
`;

exports[`structured programming compilation > hello world twice > compiled 1`] = `
"@const_16 = constant [3 x i8] c"%s\\00"
@const_21 = constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_14 = alloca {  }
    %var_15 = load {  }, ptr %var_14
    store {  } %var_15, ptr %var_14
    %var_17 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_18 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_17
    %var_19 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_18, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_20 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_19, {  } %var_15, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_20, ptr %var_17
    %var_22 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_20, 0
    %var_23 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_20, 1
    %var_24 = alloca i8*
    call void %var_22(i8** %var_24, {  } %var_23, i8* @const_21)
    %var_25 = load i8*, ptr %var_24
    %var_26 = alloca {  }
    %var_27 = load {  }, ptr %var_26
    store {  } %var_27, ptr %var_26
    %var_28 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_29 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_28
    %var_30 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_29, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_31 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_30, {  } %var_27, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_31, ptr %var_28
    %var_32 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_31, 0
    %var_33 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_31, 1
    %var_34 = alloca i8*
    call void %var_32(i8** %var_34, {  } %var_33, i8* @const_21)
    %var_35 = load i8*, ptr %var_34
    ret i32 0
}
define void @"generated_print_i8*"(ptr sret(i8*) %arg_0, {  } %arg_1, i8* %arg_2) {
  entry_0: 
    call void @printf(i8* @const_16, i8* %arg_2)
    store i8* %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > hello world twice > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_16 = constant [3 x i8] c"%s\\00"
@const_21 = constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_16, ptr nonnull @const_21)
  tail call void @printf(ptr nonnull @const_16, ptr nonnull @const_21)
  ret i32 0
}

define void @"generated_print_i8*"(ptr nocapture writeonly sret(ptr) %arg_0, {} %arg_1, ptr %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_16, ptr %arg_2)
  store ptr %arg_2, ptr %arg_0, align 8
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > hello world twice > stderr 1`] = `[]`;

exports[`structured programming compilation > hello world twice > stdout 1`] = `
[
  "hello world!hello world!",
]
`;

exports[`structured programming compilation > if-then > compiled 1`] = `
"@const_17 = constant [3 x i8] c"%i\\00"
@const_22 = constant i1 1
@const_25 = constant i32 123
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_15 = alloca {  }
    %var_16 = load {  }, ptr %var_15
    store {  } %var_16, ptr %var_15
    %var_18 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_19 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_18
    %var_20 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_19, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_21 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_20, {  } %var_16, 1
    store { void (i32*, {  }, i32)*, {  } } %var_21, ptr %var_18
    %var_23 = load i1, ptr @const_22
    br i1 %var_23, label %then_1, label %if_rest24
  then_1: 
    %var_26 = load i32, ptr @const_25
    br label %if_rest24
  if_rest24: 
    %var_27 = phi i32 [%var_26, %then_1], [undef, %main]
    %var_28 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_21, 0
    %var_29 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_21, 1
    %var_30 = alloca i32
    call void %var_28(i32* %var_30, {  } %var_29, i32 %var_27)
    %var_31 = load i32, ptr %var_30
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_17, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > if-then > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_17 = constant [3 x i8] c"%i\\00"
@const_22 = local_unnamed_addr constant i1 true
@const_25 = local_unnamed_addr constant i32 123
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_17, i32 123)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_17, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > if-then > stderr 1`] = `[]`;

exports[`structured programming compilation > if-then > stdout 1`] = `
[
  "123",
]
`;

exports[`structured programming compilation > if-then-else > compiled 1`] = `
"@const_20 = constant [3 x i8] c"%i\\00"
@const_25 = constant i1 0
@const_28 = constant i32 123
@const_30 = constant i32 456
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_18 = alloca {  }
    %var_19 = load {  }, ptr %var_18
    store {  } %var_19, ptr %var_18
    %var_21 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_22 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_21
    %var_23 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_22, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_24 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_23, {  } %var_19, 1
    store { void (i32*, {  }, i32)*, {  } } %var_24, ptr %var_21
    %var_26 = load i1, ptr @const_25
    br i1 %var_26, label %then_1, label %else_2
  then_1: 
    %var_29 = load i32, ptr @const_28
    br label %if_rest27
  else_2: 
    %var_31 = load i32, ptr @const_30
    br label %if_rest27
  if_rest27: 
    %var_32 = phi i32 [%var_29, %then_1], [%var_31, %else_2]
    %var_33 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_24, 0
    %var_34 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_24, 1
    %var_35 = alloca i32
    call void %var_33(i32* %var_35, {  } %var_34, i32 %var_32)
    %var_36 = load i32, ptr %var_35
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_20, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > if-then-else > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_20 = constant [3 x i8] c"%i\\00"
@const_25 = local_unnamed_addr constant i1 false
@const_28 = local_unnamed_addr constant i32 123
@const_30 = local_unnamed_addr constant i32 456
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_20, i32 456)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_20, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > if-then-else > stderr 1`] = `[]`;

exports[`structured programming compilation > if-then-else > stdout 1`] = `
[
  "456",
]
`;

exports[`structured programming compilation > sequence > compiled 1`] = `
"@const_17 = constant [3 x i8] c"%i\\00"
@const_22 = constant i32 123
@const_24 = constant i32 234
@const_26 = constant i32 345
@const_28 = constant i32 456
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_15 = alloca {  }
    %var_16 = load {  }, ptr %var_15
    store {  } %var_16, ptr %var_15
    %var_18 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_19 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_18
    %var_20 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_19, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_21 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_20, {  } %var_16, 1
    store { void (i32*, {  }, i32)*, {  } } %var_21, ptr %var_18
    %var_23 = load i32, ptr @const_22
    %var_25 = load i32, ptr @const_24
    %var_27 = load i32, ptr @const_26
    %var_29 = load i32, ptr @const_28
    %var_30 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_21, 0
    %var_31 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_21, 1
    %var_32 = alloca i32
    call void %var_30(i32* %var_32, {  } %var_31, i32 %var_29)
    %var_33 = load i32, ptr %var_32
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_17, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > sequence > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_17 = constant [3 x i8] c"%i\\00"
@const_22 = local_unnamed_addr constant i32 123
@const_24 = local_unnamed_addr constant i32 234
@const_26 = local_unnamed_addr constant i32 345
@const_28 = local_unnamed_addr constant i32 456
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_17, i32 456)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_17, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > sequence > stderr 1`] = `[]`;

exports[`structured programming compilation > sequence > stdout 1`] = `
[
  "456",
]
`;

exports[`structured programming compilation > two prints > compiled 1`] = `
"@const_16 = constant [3 x i8] c"%s\\00"
@const_21 = constant [13 x i8] c"hello world!\\00"
@const_32 = constant [15 x i8] c"hello world 2!\\00"
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_14 = alloca {  }
    %var_15 = load {  }, ptr %var_14
    store {  } %var_15, ptr %var_14
    %var_17 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_18 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_17
    %var_19 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_18, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_20 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_19, {  } %var_15, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_20, ptr %var_17
    %var_22 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_20, 0
    %var_23 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_20, 1
    %var_24 = alloca i8*
    call void %var_22(i8** %var_24, {  } %var_23, i8* @const_21)
    %var_25 = load i8*, ptr %var_24
    %var_26 = alloca {  }
    %var_27 = load {  }, ptr %var_26
    store {  } %var_27, ptr %var_26
    %var_28 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_29 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_28
    %var_30 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_29, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_31 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_30, {  } %var_27, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_31, ptr %var_28
    %var_33 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_31, 0
    %var_34 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_31, 1
    %var_35 = alloca i8*
    call void %var_33(i8** %var_35, {  } %var_34, i8* @const_32)
    %var_36 = load i8*, ptr %var_35
    ret i32 0
}
define void @"generated_print_i8*"(ptr sret(i8*) %arg_0, {  } %arg_1, i8* %arg_2) {
  entry_0: 
    call void @printf(i8* @const_16, i8* %arg_2)
    store i8* %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > two prints > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_16 = constant [3 x i8] c"%s\\00"
@const_21 = constant [13 x i8] c"hello world!\\00"
@const_32 = constant [15 x i8] c"hello world 2!\\00"
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_16, ptr nonnull @const_21)
  tail call void @printf(ptr nonnull @const_16, ptr nonnull @const_32)
  ret i32 0
}

define void @"generated_print_i8*"(ptr nocapture writeonly sret(ptr) %arg_0, {} %arg_1, ptr %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_16, ptr %arg_2)
  store ptr %arg_2, ptr %arg_0, align 8
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > two prints > stderr 1`] = `[]`;

exports[`structured programming compilation > two prints > stdout 1`] = `
[
  "hello world!hello world 2!",
]
`;
