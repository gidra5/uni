// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`data structures compilation > atom (global symbol) > compiled 1`] = `
"@const_25 = constant i64 0
@const_31 = constant [7 x i8] c"atom_a\\00"
@symbols_metadata_array = constant [1 x { i8* }] [{ i8* } { i8* @const_31 }]
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_9 = alloca {  }
    %var_10 = load {  }, ptr %var_9
    store {  } %var_10, ptr %var_9
    %var_21 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_22 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_21
    %var_23 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_22, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_24 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_23, {  } %var_10, 1
    store { void (i64*, {  }, i64)*, {  } } %var_24, ptr %var_21
    %var_26 = load i64, ptr @const_25
    %var_27 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_24, 0
    %var_28 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_24, 1
    %var_29 = alloca i64
    call void %var_27(i64* %var_29, {  } %var_28, i64 %var_26)
    %var_30 = load i64, ptr %var_29
    ret i32 0
}
define void @"generated_print_symbol"(ptr sret(i64) %arg_0, {  } %arg_1, i64 %arg_2) {
  entry_0: 
    %var_11 = alloca {  }
    %var_12 = load {  }, ptr %var_11
    store {  } %var_12, ptr %var_11
    %var_13 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_14 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_13
    %var_15 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_14, void (i64*, {  }, i64)* @print_symbol_wrap, 0
    %var_16 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_15, {  } %var_12, 1
    store { void (i64*, {  }, i64)*, {  } } %var_16, ptr %var_13
    %var_17 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_16, 0
    %var_18 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_16, 1
    %var_19 = alloca i64
    call void %var_17(i64* %var_19, {  } %var_18, i64 %arg_2)
    %var_20 = load i64, ptr %var_19
    store i64 %arg_2, ptr %arg_0
    ret void
}
declare void @print_symbol(i64)
define void @print_symbol_wrap(ptr sret(i64) %arg_0, {  } %arg_1, i64 %arg_2) {
  entry_0: 
    call void @print_symbol(i64 %arg_2)
    store i64 %arg_2, ptr %arg_0
    ret void
}
"
`;

exports[`data structures compilation > atom (global symbol) > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_25 = local_unnamed_addr constant i64 0
@const_31 = constant [7 x i8] c"atom_a\\00"
@symbols_metadata_array = constant [1 x { ptr }] [{ ptr } { ptr @const_31 }]
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @print_symbol(i64 0)
  ret i32 0
}

define void @generated_print_symbol(ptr nocapture writeonly sret(i64) %arg_0, {} %arg_1, i64 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @print_symbol(i64 %arg_2)
  store i64 %arg_2, ptr %arg_0, align 8
  ret void
}

declare void @print_symbol(i64) local_unnamed_addr

define void @print_symbol_wrap(ptr nocapture writeonly sret(i64) %arg_0, {} %arg_1, i64 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @print_symbol(i64 %arg_2)
  store i64 %arg_2, ptr %arg_0, align 8
  ret void
}
"
`;

exports[`data structures compilation > atom (global symbol) > stderr 1`] = `[]`;

exports[`data structures compilation > atom (global symbol) > stdout 1`] = `
[
  "symbol(atom_a)",
]
`;

exports[`data structures compilation > boolean false > compiled 1`] = `
"@const_11 = constant [5 x i8] c"true\\00"
@const_12 = constant [6 x i8] c"false\\00"
@const_14 = constant [3 x i8] c"%s\\00"
@const_19 = constant i1 0
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_9 = alloca {  }
    %var_10 = load {  }, ptr %var_9
    store {  } %var_10, ptr %var_9
    %var_15 = alloca { void (i1*, {  }, i1)*, {  } }
    %var_16 = load { void (i1*, {  }, i1)*, {  } }, ptr %var_15
    %var_17 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_16, void (i1*, {  }, i1)* @"generated_print_i1", 0
    %var_18 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_17, {  } %var_10, 1
    store { void (i1*, {  }, i1)*, {  } } %var_18, ptr %var_15
    %var_20 = load i1, ptr @const_19
    %var_21 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_18, 0
    %var_22 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_18, 1
    %var_23 = alloca i1
    call void %var_21(i1* %var_23, {  } %var_22, i1 %var_20)
    %var_24 = load i1, ptr %var_23
    ret i32 0
}
define void @"generated_print_i1"(ptr sret(i1) %arg_0, {  } %arg_1, i1 %arg_2) {
  entry_0: 
    %var_13 = select i1 %arg_2, [5 x i8]* @const_11, [5 x i8]* @const_12
    call void @printf(i8* @const_14, [5 x i8]* %var_13)
    store i1 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`data structures compilation > boolean false > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_11 = constant [5 x i8] c"true\\00"
@const_12 = constant [6 x i8] c"false\\00"
@const_14 = constant [3 x i8] c"%s\\00"
@const_19 = local_unnamed_addr constant i1 false
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_14, ptr nonnull @const_12)
  ret i32 0
}

define void @generated_print_i1(ptr nocapture writeonly sret(i1) %arg_0, {} %arg_1, i1 %arg_2) local_unnamed_addr {
entry_0:
  %var_13 = select i1 %arg_2, ptr @const_11, ptr @const_12
  tail call void @printf(ptr nonnull @const_14, ptr nonnull %var_13)
  store i1 %arg_2, ptr %arg_0, align 1
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`data structures compilation > boolean false > stderr 1`] = `[]`;

exports[`data structures compilation > boolean false > stdout 1`] = `
[
  "false",
]
`;

exports[`data structures compilation > boolean true > compiled 1`] = `
"@const_11 = constant [5 x i8] c"true\\00"
@const_12 = constant [6 x i8] c"false\\00"
@const_14 = constant [3 x i8] c"%s\\00"
@const_19 = constant i1 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_9 = alloca {  }
    %var_10 = load {  }, ptr %var_9
    store {  } %var_10, ptr %var_9
    %var_15 = alloca { void (i1*, {  }, i1)*, {  } }
    %var_16 = load { void (i1*, {  }, i1)*, {  } }, ptr %var_15
    %var_17 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_16, void (i1*, {  }, i1)* @"generated_print_i1", 0
    %var_18 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_17, {  } %var_10, 1
    store { void (i1*, {  }, i1)*, {  } } %var_18, ptr %var_15
    %var_20 = load i1, ptr @const_19
    %var_21 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_18, 0
    %var_22 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_18, 1
    %var_23 = alloca i1
    call void %var_21(i1* %var_23, {  } %var_22, i1 %var_20)
    %var_24 = load i1, ptr %var_23
    ret i32 0
}
define void @"generated_print_i1"(ptr sret(i1) %arg_0, {  } %arg_1, i1 %arg_2) {
  entry_0: 
    %var_13 = select i1 %arg_2, [5 x i8]* @const_11, [5 x i8]* @const_12
    call void @printf(i8* @const_14, [5 x i8]* %var_13)
    store i1 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`data structures compilation > boolean true > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_11 = constant [5 x i8] c"true\\00"
@const_12 = constant [6 x i8] c"false\\00"
@const_14 = constant [3 x i8] c"%s\\00"
@const_19 = local_unnamed_addr constant i1 true
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_14, ptr nonnull @const_11)
  ret i32 0
}

define void @generated_print_i1(ptr nocapture writeonly sret(i1) %arg_0, {} %arg_1, i1 %arg_2) local_unnamed_addr {
entry_0:
  %var_13 = select i1 %arg_2, ptr @const_11, ptr @const_12
  tail call void @printf(ptr nonnull @const_14, ptr nonnull %var_13)
  store i1 %arg_2, ptr %arg_0, align 1
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`data structures compilation > boolean true > stderr 1`] = `[]`;

exports[`data structures compilation > boolean true > stdout 1`] = `
[
  "true",
]
`;

exports[`data structures compilation > symbol > compiled 1`] = `
"@const_25 = constant i64 0
@const_31 = constant [10 x i8] c"symbol_ab\\00"
@symbols_metadata_array = constant [1 x { i8* }] [{ i8* } { i8* @const_31 }]
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_9 = alloca {  }
    %var_10 = load {  }, ptr %var_9
    store {  } %var_10, ptr %var_9
    %var_21 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_22 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_21
    %var_23 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_22, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_24 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_23, {  } %var_10, 1
    store { void (i64*, {  }, i64)*, {  } } %var_24, ptr %var_21
    %var_26 = load i64, ptr @const_25
    %var_27 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_24, 0
    %var_28 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_24, 1
    %var_29 = alloca i64
    call void %var_27(i64* %var_29, {  } %var_28, i64 %var_26)
    %var_30 = load i64, ptr %var_29
    ret i32 0
}
define void @"generated_print_symbol"(ptr sret(i64) %arg_0, {  } %arg_1, i64 %arg_2) {
  entry_0: 
    %var_11 = alloca {  }
    %var_12 = load {  }, ptr %var_11
    store {  } %var_12, ptr %var_11
    %var_13 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_14 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_13
    %var_15 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_14, void (i64*, {  }, i64)* @print_symbol_wrap, 0
    %var_16 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_15, {  } %var_12, 1
    store { void (i64*, {  }, i64)*, {  } } %var_16, ptr %var_13
    %var_17 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_16, 0
    %var_18 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_16, 1
    %var_19 = alloca i64
    call void %var_17(i64* %var_19, {  } %var_18, i64 %arg_2)
    %var_20 = load i64, ptr %var_19
    store i64 %arg_2, ptr %arg_0
    ret void
}
declare void @print_symbol(i64)
define void @print_symbol_wrap(ptr sret(i64) %arg_0, {  } %arg_1, i64 %arg_2) {
  entry_0: 
    call void @print_symbol(i64 %arg_2)
    store i64 %arg_2, ptr %arg_0
    ret void
}
"
`;

exports[`data structures compilation > symbol > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_25 = local_unnamed_addr constant i64 0
@const_31 = constant [10 x i8] c"symbol_ab\\00"
@symbols_metadata_array = constant [1 x { ptr }] [{ ptr } { ptr @const_31 }]
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @print_symbol(i64 0)
  ret i32 0
}

define void @generated_print_symbol(ptr nocapture writeonly sret(i64) %arg_0, {} %arg_1, i64 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @print_symbol(i64 %arg_2)
  store i64 %arg_2, ptr %arg_0, align 8
  ret void
}

declare void @print_symbol(i64) local_unnamed_addr

define void @print_symbol_wrap(ptr nocapture writeonly sret(i64) %arg_0, {} %arg_1, i64 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @print_symbol(i64 %arg_2)
  store i64 %arg_2, ptr %arg_0, align 8
  ret void
}
"
`;

exports[`data structures compilation > symbol > stderr 1`] = `[]`;

exports[`data structures compilation > symbol > stdout 1`] = `
[
  "symbol(symbol_ab)",
]
`;

exports[`data structures compilation > tuple > compiled 1`] = `
"@const_14 = constant [7 x i8] c"tuple(\\00"
@const_15 = constant [3 x i8] c"%s\\00"
@const_19 = constant [3 x i8] c"%i\\00"
@const_28 = constant [3 x i8] c", \\00"
@const_40 = constant [2 x i8] c")\\00"
@const_45 = constant i32 1
@const_50 = constant [3 x i8] c"ab\\00"
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_12 = alloca {  }
    %var_13 = load {  }, ptr %var_12
    store {  } %var_13, ptr %var_12
    %var_41 = alloca { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } }
    %var_42 = load { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } }, ptr %var_41
    %var_43 = insertvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_42, void ({ i32, i8* }*, {  }, { i32, i8* })* @"generated_print_(i32, i8*)", 0
    %var_44 = insertvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_43, {  } %var_13, 1
    store { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_44, ptr %var_41
    %var_46 = load i32, ptr @const_45
    %var_47 = alloca { i32 }
    %var_48 = load { i32 }, ptr %var_47
    %var_49 = insertvalue { i32 } %var_48, i32 %var_46, 0
    store { i32 } %var_49, ptr %var_47
    %var_51 = extractvalue { i32 } %var_49, 0
    %var_52 = alloca { i32, [3 x i8]* }
    %var_53 = load { i32, [3 x i8]* }, ptr %var_52
    %var_54 = insertvalue { i32, [3 x i8]* } %var_53, i32 %var_51, 0
    %var_55 = insertvalue { i32, [3 x i8]* } %var_54, [3 x i8]* @const_50, 1
    store { i32, [3 x i8]* } %var_55, ptr %var_52
    %var_56 = extractvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_44, 0
    %var_57 = extractvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_44, 1
    %var_58 = alloca { i32, i8* }
    call void %var_56({ i32, i8* }* %var_58, {  } %var_57, { i32, i8* } %var_55)
    %var_59 = load { i32, i8* }, ptr %var_58
    ret i32 0
}
define void @"generated_print_(i32, i8*)"(ptr sret({ i32, i8* }) %arg_0, {  } %arg_1, { i32, i8* } %arg_2) {
  entry_0: 
    call void @printf(i8* @const_15, [7 x i8]* @const_14)
    %var_16 = extractvalue { i32, i8* } %arg_2, 0
    %var_17 = alloca {  }
    %var_18 = load {  }, ptr %var_17
    store {  } %var_18, ptr %var_17
    %var_20 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_21 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_20
    %var_22 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_21, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_23 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_22, {  } %var_18, 1
    store { void (i32*, {  }, i32)*, {  } } %var_23, ptr %var_20
    %var_24 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_23, 0
    %var_25 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_23, 1
    %var_26 = alloca i32
    call void %var_24(i32* %var_26, {  } %var_25, i32 %var_16)
    %var_27 = load i32, ptr %var_26
    call void @printf(i8* @const_15, [3 x i8]* @const_28)
    %var_29 = extractvalue { i32, i8* } %arg_2, 1
    %var_30 = alloca {  }
    %var_31 = load {  }, ptr %var_30
    store {  } %var_31, ptr %var_30
    %var_32 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_33 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_32
    %var_34 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_33, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_35 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_34, {  } %var_31, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_35, ptr %var_32
    %var_36 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_35, 0
    %var_37 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_35, 1
    %var_38 = alloca i8*
    call void %var_36(i8** %var_38, {  } %var_37, i8* %var_29)
    %var_39 = load i8*, ptr %var_38
    call void @printf(i8* @const_15, [2 x i8]* @const_40)
    store { i32, i8* } %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_19, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
define void @"generated_print_i8*"(ptr sret(i8*) %arg_0, {  } %arg_1, i8* %arg_2) {
  entry_0: 
    call void @printf(i8* @const_15, i8* %arg_2)
    store i8* %arg_2, ptr %arg_0
    ret void
}
"
`;

exports[`data structures compilation > tuple > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_14 = constant [7 x i8] c"tuple(\\00"
@const_15 = constant [3 x i8] c"%s\\00"
@const_19 = constant [3 x i8] c"%i\\00"
@const_28 = constant [3 x i8] c", \\00"
@const_40 = constant [2 x i8] c")\\00"
@const_45 = local_unnamed_addr constant i32 1
@const_50 = constant [3 x i8] c"ab\\00"
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_15, ptr nonnull @const_14)
  tail call void @printf(ptr nonnull @const_19, i32 1)
  tail call void @printf(ptr nonnull @const_15, ptr nonnull @const_28)
  tail call void @printf(ptr nonnull @const_15, ptr nonnull @const_50)
  tail call void @printf(ptr nonnull @const_15, ptr nonnull @const_40)
  ret i32 0
}

define void @"generated_print_(i32, i8*)"(ptr nocapture writeonly sret({ i32, ptr }) %arg_0, {} %arg_1, { i32, ptr } %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_15, ptr nonnull @const_14)
  %var_16 = extractvalue { i32, ptr } %arg_2, 0
  tail call void @printf(ptr nonnull @const_19, i32 %var_16)
  tail call void @printf(ptr nonnull @const_15, ptr nonnull @const_28)
  %var_29 = extractvalue { i32, ptr } %arg_2, 1
  tail call void @printf(ptr nonnull @const_15, ptr %var_29)
  tail call void @printf(ptr nonnull @const_15, ptr nonnull @const_40)
  store { i32, ptr } %arg_2, ptr %arg_0, align 8
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_19, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

define void @"generated_print_i8*"(ptr nocapture writeonly sret(ptr) %arg_0, {} %arg_1, ptr %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_15, ptr %arg_2)
  store ptr %arg_2, ptr %arg_0, align 8
  ret void
}

attributes #0 = { nofree nounwind }
"
`;

exports[`data structures compilation > tuple > stderr 1`] = `[]`;

exports[`data structures compilation > tuple > stdout 1`] = `
[
  "tuple(1, ab)",
]
`;

exports[`data structures compilation > unit > compiled 1`] = `
"@const_25 = constant i64 0
@const_31 = constant [5 x i8] c"unit\\00"
@symbols_metadata_array = constant [1 x { i8* }] [{ i8* } { i8* @const_31 }]
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_9 = alloca {  }
    %var_10 = load {  }, ptr %var_9
    store {  } %var_10, ptr %var_9
    %var_21 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_22 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_21
    %var_23 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_22, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_24 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_23, {  } %var_10, 1
    store { void (i64*, {  }, i64)*, {  } } %var_24, ptr %var_21
    %var_26 = load i64, ptr @const_25
    %var_27 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_24, 0
    %var_28 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_24, 1
    %var_29 = alloca i64
    call void %var_27(i64* %var_29, {  } %var_28, i64 %var_26)
    %var_30 = load i64, ptr %var_29
    ret i32 0
}
define void @"generated_print_symbol"(ptr sret(i64) %arg_0, {  } %arg_1, i64 %arg_2) {
  entry_0: 
    %var_11 = alloca {  }
    %var_12 = load {  }, ptr %var_11
    store {  } %var_12, ptr %var_11
    %var_13 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_14 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_13
    %var_15 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_14, void (i64*, {  }, i64)* @print_symbol_wrap, 0
    %var_16 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_15, {  } %var_12, 1
    store { void (i64*, {  }, i64)*, {  } } %var_16, ptr %var_13
    %var_17 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_16, 0
    %var_18 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_16, 1
    %var_19 = alloca i64
    call void %var_17(i64* %var_19, {  } %var_18, i64 %arg_2)
    %var_20 = load i64, ptr %var_19
    store i64 %arg_2, ptr %arg_0
    ret void
}
declare void @print_symbol(i64)
define void @print_symbol_wrap(ptr sret(i64) %arg_0, {  } %arg_1, i64 %arg_2) {
  entry_0: 
    call void @print_symbol(i64 %arg_2)
    store i64 %arg_2, ptr %arg_0
    ret void
}
"
`;

exports[`data structures compilation > unit > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_25 = local_unnamed_addr constant i64 0
@const_31 = constant [5 x i8] c"unit\\00"
@symbols_metadata_array = constant [1 x { ptr }] [{ ptr } { ptr @const_31 }]
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @print_symbol(i64 0)
  ret i32 0
}

define void @generated_print_symbol(ptr nocapture writeonly sret(i64) %arg_0, {} %arg_1, i64 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @print_symbol(i64 %arg_2)
  store i64 %arg_2, ptr %arg_0, align 8
  ret void
}

declare void @print_symbol(i64) local_unnamed_addr

define void @print_symbol_wrap(ptr nocapture writeonly sret(i64) %arg_0, {} %arg_1, i64 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @print_symbol(i64 %arg_2)
  store i64 %arg_2, ptr %arg_0, align 8
  ret void
}
"
`;

exports[`data structures compilation > unit > stderr 1`] = `[]`;

exports[`data structures compilation > unit > stdout 1`] = `
[
  "symbol(unit)",
]
`;

exports[`generic print > compiled 1`] = `
"@const_92 = constant [4 x i8] c"fn[\\00"
@const_93 = constant [3 x i8] c"%s\\00"
@const_94 = constant [2 x i8] c"]\\00"
@const_116 = constant [2 x i8] c"
\\00"
@const_127 = constant [3 x i8] c"%i\\00"
@const_156 = constant i32 1
@const_206 = constant [7 x i8] c"tuple(\\00"
@const_218 = constant [3 x i8] c", \\00"
@const_230 = constant [2 x i8] c")\\00"
@const_239 = constant [3 x i8] c"ab\\00"
@const_282 = constant [3 x i8] c"%f\\00"
@const_287 = constant float 1.25
@const_325 = constant [5 x i8] c"true\\00"
@const_326 = constant [6 x i8] c"false\\00"
@const_332 = constant i1 1
@const_354 = constant i1 0
@const_386 = constant i64 0
@const_408 = constant i64 1
@const_430 = constant i64 2
@const_436 = constant [5 x i8] c"unit\\00"
@const_437 = constant [12 x i8] c"atom_atom_a\\00"
@const_438 = constant [16 x i8] c"symbol_symbol_a\\00"
@symbols_metadata_array = constant [3 x { i8* }] [{ i8* } { i8* @const_436 }, { i8* } { i8* @const_437 }, { i8* } { i8* @const_438 }]
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_89 = alloca {  }
    %var_90 = load {  }, ptr %var_89
    store {  } %var_90, ptr %var_89
    %var_95 = alloca { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } }
    %var_96 = load { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } }, ptr %var_95
    %var_97 = insertvalue { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_96, void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })* @"generated_print_i32[](i32)", 0
    %var_98 = insertvalue { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_97, {  } %var_90, 1
    store { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_98, ptr %var_95
    %var_100 = alloca {  }
    %var_101 = load {  }, ptr %var_100
    store {  } %var_101, ptr %var_100
    %var_102 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_103 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_102
    %var_104 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_103, void (i32*, {  }, i32)* @fn_99, 0
    %var_105 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_104, {  } %var_101, 1
    store { void (i32*, {  }, i32)*, {  } } %var_105, ptr %var_102
    %var_106 = extractvalue { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_98, 0
    %var_107 = extractvalue { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_98, 1
    %var_108 = alloca { void (i32*, {  }, i32)*, {  } }
    call void %var_106({ void (i32*, {  }, i32)*, {  } }* %var_108, {  } %var_107, { void (i32*, {  }, i32)*, {  } } %var_105)
    %var_109 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_108
    %var_110 = alloca {  }
    %var_111 = load {  }, ptr %var_110
    store {  } %var_111, ptr %var_110
    %var_112 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_113 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_112
    %var_114 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_113, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_115 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_114, {  } %var_111, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_115, ptr %var_112
    %var_117 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_115, 0
    %var_118 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_115, 1
    %var_119 = alloca i8*
    call void %var_117(i8** %var_119, {  } %var_118, i8* @const_116)
    %var_120 = load i8*, ptr %var_119
    %var_121 = alloca {  }
    %var_122 = load {  }, ptr %var_121
    store {  } %var_122, ptr %var_121
    %var_136 = alloca { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } }
    %var_137 = load { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } }, ptr %var_136
    %var_138 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } } %var_137, void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })* @"generated_print_i32[i32](i32)", 0
    %var_139 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } } %var_138, {  } %var_122, 1
    store { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } } %var_139, ptr %var_136
    %var_141 = alloca {  }
    %var_142 = load {  }, ptr %var_141
    store {  } %var_142, ptr %var_141
    %var_152 = alloca { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }
    %var_153 = load { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_152
    %var_154 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_153, void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)* @fn_140, 0
    %var_155 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_154, {  } %var_142, 1
    store { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_155, ptr %var_152
    %var_157 = load i32, ptr @const_156
    %var_158 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_155, 0
    %var_159 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_155, 1
    %var_160 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    call void %var_158({ void (i32*, { i32 }, i32)*, { i32 } }* %var_160, {  } %var_159, i32 %var_157)
    %var_161 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_160
    %var_162 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } } %var_139, 0
    %var_163 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } } %var_139, 1
    %var_164 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    call void %var_162({ void (i32*, { i32 }, i32)*, { i32 } }* %var_164, {  } %var_163, { void (i32*, { i32 }, i32)*, { i32 } } %var_161)
    %var_165 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_164
    %var_166 = alloca {  }
    %var_167 = load {  }, ptr %var_166
    store {  } %var_167, ptr %var_166
    %var_168 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_169 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_168
    %var_170 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_169, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_171 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_170, {  } %var_167, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_171, ptr %var_168
    %var_172 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_171, 0
    %var_173 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_171, 1
    %var_174 = alloca i8*
    call void %var_172(i8** %var_174, {  } %var_173, i8* @const_116)
    %var_175 = load i8*, ptr %var_174
    %var_176 = alloca {  }
    %var_177 = load {  }, ptr %var_176
    store {  } %var_177, ptr %var_176
    %var_179 = alloca { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } }
    %var_180 = load { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } }, ptr %var_179
    %var_181 = insertvalue { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_180, void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })* @"generated_print_i32[](i32, i32)", 0
    %var_182 = insertvalue { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_181, {  } %var_177, 1
    store { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_182, ptr %var_179
    %var_184 = alloca {  }
    %var_185 = load {  }, ptr %var_184
    store {  } %var_185, ptr %var_184
    %var_186 = alloca { void (i32*, {  }, i32, i32)*, {  } }
    %var_187 = load { void (i32*, {  }, i32, i32)*, {  } }, ptr %var_186
    %var_188 = insertvalue { void (i32*, {  }, i32, i32)*, {  } } %var_187, void (i32*, {  }, i32, i32)* @fn_183, 0
    %var_189 = insertvalue { void (i32*, {  }, i32, i32)*, {  } } %var_188, {  } %var_185, 1
    store { void (i32*, {  }, i32, i32)*, {  } } %var_189, ptr %var_186
    %var_190 = extractvalue { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_182, 0
    %var_191 = extractvalue { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_182, 1
    %var_192 = alloca { void (i32*, {  }, i32, i32)*, {  } }
    call void %var_190({ void (i32*, {  }, i32, i32)*, {  } }* %var_192, {  } %var_191, { void (i32*, {  }, i32, i32)*, {  } } %var_189)
    %var_193 = load { void (i32*, {  }, i32, i32)*, {  } }, ptr %var_192
    %var_194 = alloca {  }
    %var_195 = load {  }, ptr %var_194
    store {  } %var_195, ptr %var_194
    %var_196 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_197 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_196
    %var_198 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_197, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_199 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_198, {  } %var_195, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_199, ptr %var_196
    %var_200 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_199, 0
    %var_201 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_199, 1
    %var_202 = alloca i8*
    call void %var_200(i8** %var_202, {  } %var_201, i8* @const_116)
    %var_203 = load i8*, ptr %var_202
    %var_204 = alloca {  }
    %var_205 = load {  }, ptr %var_204
    store {  } %var_205, ptr %var_204
    %var_231 = alloca { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } }
    %var_232 = load { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } }, ptr %var_231
    %var_233 = insertvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_232, void ({ i32, i8* }*, {  }, { i32, i8* })* @"generated_print_(i32, i8*)", 0
    %var_234 = insertvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_233, {  } %var_205, 1
    store { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_234, ptr %var_231
    %var_235 = load i32, ptr @const_156
    %var_236 = alloca { i32 }
    %var_237 = load { i32 }, ptr %var_236
    %var_238 = insertvalue { i32 } %var_237, i32 %var_235, 0
    store { i32 } %var_238, ptr %var_236
    %var_240 = extractvalue { i32 } %var_238, 0
    %var_241 = alloca { i32, [3 x i8]* }
    %var_242 = load { i32, [3 x i8]* }, ptr %var_241
    %var_243 = insertvalue { i32, [3 x i8]* } %var_242, i32 %var_240, 0
    %var_244 = insertvalue { i32, [3 x i8]* } %var_243, [3 x i8]* @const_239, 1
    store { i32, [3 x i8]* } %var_244, ptr %var_241
    %var_245 = extractvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_234, 0
    %var_246 = extractvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_234, 1
    %var_247 = alloca { i32, i8* }
    call void %var_245({ i32, i8* }* %var_247, {  } %var_246, { i32, i8* } %var_244)
    %var_248 = load { i32, i8* }, ptr %var_247
    %var_249 = alloca {  }
    %var_250 = load {  }, ptr %var_249
    store {  } %var_250, ptr %var_249
    %var_251 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_252 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_251
    %var_253 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_252, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_254 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_253, {  } %var_250, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_254, ptr %var_251
    %var_255 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_254, 0
    %var_256 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_254, 1
    %var_257 = alloca i8*
    call void %var_255(i8** %var_257, {  } %var_256, i8* @const_116)
    %var_258 = load i8*, ptr %var_257
    %var_259 = alloca {  }
    %var_260 = load {  }, ptr %var_259
    store {  } %var_260, ptr %var_259
    %var_261 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_262 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_261
    %var_263 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_262, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_264 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_263, {  } %var_260, 1
    store { void (i32*, {  }, i32)*, {  } } %var_264, ptr %var_261
    %var_265 = load i32, ptr @const_156
    %var_266 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_264, 0
    %var_267 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_264, 1
    %var_268 = alloca i32
    call void %var_266(i32* %var_268, {  } %var_267, i32 %var_265)
    %var_269 = load i32, ptr %var_268
    %var_270 = alloca {  }
    %var_271 = load {  }, ptr %var_270
    store {  } %var_271, ptr %var_270
    %var_272 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_273 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_272
    %var_274 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_273, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_275 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_274, {  } %var_271, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_275, ptr %var_272
    %var_276 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_275, 0
    %var_277 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_275, 1
    %var_278 = alloca i8*
    call void %var_276(i8** %var_278, {  } %var_277, i8* @const_116)
    %var_279 = load i8*, ptr %var_278
    %var_280 = alloca {  }
    %var_281 = load {  }, ptr %var_280
    store {  } %var_281, ptr %var_280
    %var_283 = alloca { void (float*, {  }, float)*, {  } }
    %var_284 = load { void (float*, {  }, float)*, {  } }, ptr %var_283
    %var_285 = insertvalue { void (float*, {  }, float)*, {  } } %var_284, void (float*, {  }, float)* @"generated_print_f32", 0
    %var_286 = insertvalue { void (float*, {  }, float)*, {  } } %var_285, {  } %var_281, 1
    store { void (float*, {  }, float)*, {  } } %var_286, ptr %var_283
    %var_288 = load float, ptr @const_287
    %var_289 = extractvalue { void (float*, {  }, float)*, {  } } %var_286, 0
    %var_290 = extractvalue { void (float*, {  }, float)*, {  } } %var_286, 1
    %var_291 = alloca float
    call void %var_289(float* %var_291, {  } %var_290, float %var_288)
    %var_292 = load float, ptr %var_291
    %var_293 = alloca {  }
    %var_294 = load {  }, ptr %var_293
    store {  } %var_294, ptr %var_293
    %var_295 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_296 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_295
    %var_297 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_296, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_298 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_297, {  } %var_294, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_298, ptr %var_295
    %var_299 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_298, 0
    %var_300 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_298, 1
    %var_301 = alloca i8*
    call void %var_299(i8** %var_301, {  } %var_300, i8* @const_116)
    %var_302 = load i8*, ptr %var_301
    %var_303 = alloca {  }
    %var_304 = load {  }, ptr %var_303
    store {  } %var_304, ptr %var_303
    %var_305 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_306 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_305
    %var_307 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_306, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_308 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_307, {  } %var_304, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_308, ptr %var_305
    %var_309 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_308, 0
    %var_310 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_308, 1
    %var_311 = alloca i8*
    call void %var_309(i8** %var_311, {  } %var_310, i8* @const_239)
    %var_312 = load i8*, ptr %var_311
    %var_313 = alloca {  }
    %var_314 = load {  }, ptr %var_313
    store {  } %var_314, ptr %var_313
    %var_315 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_316 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_315
    %var_317 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_316, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_318 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_317, {  } %var_314, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_318, ptr %var_315
    %var_319 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_318, 0
    %var_320 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_318, 1
    %var_321 = alloca i8*
    call void %var_319(i8** %var_321, {  } %var_320, i8* @const_116)
    %var_322 = load i8*, ptr %var_321
    %var_323 = alloca {  }
    %var_324 = load {  }, ptr %var_323
    store {  } %var_324, ptr %var_323
    %var_328 = alloca { void (i1*, {  }, i1)*, {  } }
    %var_329 = load { void (i1*, {  }, i1)*, {  } }, ptr %var_328
    %var_330 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_329, void (i1*, {  }, i1)* @"generated_print_i1", 0
    %var_331 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_330, {  } %var_324, 1
    store { void (i1*, {  }, i1)*, {  } } %var_331, ptr %var_328
    %var_333 = load i1, ptr @const_332
    %var_334 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_331, 0
    %var_335 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_331, 1
    %var_336 = alloca i1
    call void %var_334(i1* %var_336, {  } %var_335, i1 %var_333)
    %var_337 = load i1, ptr %var_336
    %var_338 = alloca {  }
    %var_339 = load {  }, ptr %var_338
    store {  } %var_339, ptr %var_338
    %var_340 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_341 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_340
    %var_342 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_341, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_343 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_342, {  } %var_339, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_343, ptr %var_340
    %var_344 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_343, 0
    %var_345 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_343, 1
    %var_346 = alloca i8*
    call void %var_344(i8** %var_346, {  } %var_345, i8* @const_116)
    %var_347 = load i8*, ptr %var_346
    %var_348 = alloca {  }
    %var_349 = load {  }, ptr %var_348
    store {  } %var_349, ptr %var_348
    %var_350 = alloca { void (i1*, {  }, i1)*, {  } }
    %var_351 = load { void (i1*, {  }, i1)*, {  } }, ptr %var_350
    %var_352 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_351, void (i1*, {  }, i1)* @"generated_print_i1", 0
    %var_353 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_352, {  } %var_349, 1
    store { void (i1*, {  }, i1)*, {  } } %var_353, ptr %var_350
    %var_355 = load i1, ptr @const_354
    %var_356 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_353, 0
    %var_357 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_353, 1
    %var_358 = alloca i1
    call void %var_356(i1* %var_358, {  } %var_357, i1 %var_355)
    %var_359 = load i1, ptr %var_358
    %var_360 = alloca {  }
    %var_361 = load {  }, ptr %var_360
    store {  } %var_361, ptr %var_360
    %var_362 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_363 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_362
    %var_364 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_363, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_365 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_364, {  } %var_361, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_365, ptr %var_362
    %var_366 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_365, 0
    %var_367 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_365, 1
    %var_368 = alloca i8*
    call void %var_366(i8** %var_368, {  } %var_367, i8* @const_116)
    %var_369 = load i8*, ptr %var_368
    %var_370 = alloca {  }
    %var_371 = load {  }, ptr %var_370
    store {  } %var_371, ptr %var_370
    %var_382 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_383 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_382
    %var_384 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_383, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_385 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_384, {  } %var_371, 1
    store { void (i64*, {  }, i64)*, {  } } %var_385, ptr %var_382
    %var_387 = load i64, ptr @const_386
    %var_388 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_385, 0
    %var_389 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_385, 1
    %var_390 = alloca i64
    call void %var_388(i64* %var_390, {  } %var_389, i64 %var_387)
    %var_391 = load i64, ptr %var_390
    %var_392 = alloca {  }
    %var_393 = load {  }, ptr %var_392
    store {  } %var_393, ptr %var_392
    %var_394 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_395 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_394
    %var_396 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_395, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_397 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_396, {  } %var_393, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_397, ptr %var_394
    %var_398 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_397, 0
    %var_399 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_397, 1
    %var_400 = alloca i8*
    call void %var_398(i8** %var_400, {  } %var_399, i8* @const_116)
    %var_401 = load i8*, ptr %var_400
    %var_402 = alloca {  }
    %var_403 = load {  }, ptr %var_402
    store {  } %var_403, ptr %var_402
    %var_404 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_405 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_404
    %var_406 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_405, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_407 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_406, {  } %var_403, 1
    store { void (i64*, {  }, i64)*, {  } } %var_407, ptr %var_404
    %var_409 = load i64, ptr @const_408
    %var_410 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_407, 0
    %var_411 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_407, 1
    %var_412 = alloca i64
    call void %var_410(i64* %var_412, {  } %var_411, i64 %var_409)
    %var_413 = load i64, ptr %var_412
    %var_414 = alloca {  }
    %var_415 = load {  }, ptr %var_414
    store {  } %var_415, ptr %var_414
    %var_416 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_417 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_416
    %var_418 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_417, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_419 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_418, {  } %var_415, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_419, ptr %var_416
    %var_420 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_419, 0
    %var_421 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_419, 1
    %var_422 = alloca i8*
    call void %var_420(i8** %var_422, {  } %var_421, i8* @const_116)
    %var_423 = load i8*, ptr %var_422
    %var_424 = alloca {  }
    %var_425 = load {  }, ptr %var_424
    store {  } %var_425, ptr %var_424
    %var_426 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_427 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_426
    %var_428 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_427, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_429 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_428, {  } %var_425, 1
    store { void (i64*, {  }, i64)*, {  } } %var_429, ptr %var_426
    %var_431 = load i64, ptr @const_430
    %var_432 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_429, 0
    %var_433 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_429, 1
    %var_434 = alloca i64
    call void %var_432(i64* %var_434, {  } %var_433, i64 %var_431)
    %var_435 = load i64, ptr %var_434
    ret i32 0
}
define void @"generated_print_i32[](i32)"(ptr sret({ void (i32*, {  }, i32)*, {  } }) %arg_0, {  } %arg_1, { void (i32*, {  }, i32)*, {  } } %arg_2) {
  entry_0: 
    %var_91 = extractvalue { void (i32*, {  }, i32)*, {  } } %arg_2, 1
    call void @printf(i8* @const_93, [4 x i8]* @const_92)
    call void @printf(i8* @const_93, [2 x i8]* @const_94)
    store { void (i32*, {  }, i32)*, {  } } %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_99(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    store i32 %arg_2, ptr %arg_0
    ret void
}
define void @"generated_print_i8*"(ptr sret(i8*) %arg_0, {  } %arg_1, i8* %arg_2) {
  entry_0: 
    call void @printf(i8* @const_93, i8* %arg_2)
    store i8* %arg_2, ptr %arg_0
    ret void
}
define void @"generated_print_i32[i32](i32)"(ptr sret({ void (i32*, { i32 }, i32)*, { i32 } }) %arg_0, {  } %arg_1, { void (i32*, { i32 }, i32)*, { i32 } } %arg_2) {
  entry_0: 
    %var_123 = extractvalue { void (i32*, { i32 }, i32)*, { i32 } } %arg_2, 1
    call void @printf(i8* @const_93, [4 x i8]* @const_92)
    %var_124 = extractvalue { i32 } %var_123, 0
    %var_125 = alloca {  }
    %var_126 = load {  }, ptr %var_125
    store {  } %var_126, ptr %var_125
    %var_128 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_129 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_128
    %var_130 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_129, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_131 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_130, {  } %var_126, 1
    store { void (i32*, {  }, i32)*, {  } } %var_131, ptr %var_128
    %var_132 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_131, 0
    %var_133 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_131, 1
    %var_134 = alloca i32
    call void %var_132(i32* %var_134, {  } %var_133, i32 %var_124)
    %var_135 = load i32, ptr %var_134
    call void @printf(i8* @const_93, [2 x i8]* @const_94)
    store { void (i32*, { i32 }, i32)*, { i32 } } %arg_2, ptr %arg_0
    ret void
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_127, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
define void @fn_140(ptr sret({ void (i32*, { i32 }, i32)*, { i32 } }) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_144 = alloca { i32 }
    %var_145 = load { i32 }, ptr %var_144
    %var_146 = insertvalue { i32 } %var_145, i32 %arg_2, 0
    store { i32 } %var_146, ptr %var_144
    %var_148 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    %var_149 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_148
    %var_150 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_149, void (i32*, { i32 }, i32)* @fn_143, 0
    %var_151 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_150, { i32 } %var_146, 1
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_151, ptr %var_148
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_151, ptr %arg_0
    ret void
}
define void @fn_143(ptr sret(i32) %arg_0, { i32 } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_147 = extractvalue { i32 } %arg_1, 0
    store i32 %var_147, ptr %arg_0
    ret void
}
define void @"generated_print_i32[](i32, i32)"(ptr sret({ void (i32*, {  }, i32, i32)*, {  } }) %arg_0, {  } %arg_1, { void (i32*, {  }, i32, i32)*, {  } } %arg_2) {
  entry_0: 
    %var_178 = extractvalue { void (i32*, {  }, i32, i32)*, {  } } %arg_2, 1
    call void @printf(i8* @const_93, [4 x i8]* @const_92)
    call void @printf(i8* @const_93, [2 x i8]* @const_94)
    store { void (i32*, {  }, i32, i32)*, {  } } %arg_2, ptr %arg_0
    ret void
}
define void @fn_183(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2, i32 %arg_3) {
  entry_0: 
    store i32 %arg_2, ptr %arg_0
    ret void
}
define void @"generated_print_(i32, i8*)"(ptr sret({ i32, i8* }) %arg_0, {  } %arg_1, { i32, i8* } %arg_2) {
  entry_0: 
    call void @printf(i8* @const_93, [7 x i8]* @const_206)
    %var_207 = extractvalue { i32, i8* } %arg_2, 0
    %var_208 = alloca {  }
    %var_209 = load {  }, ptr %var_208
    store {  } %var_209, ptr %var_208
    %var_210 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_211 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_210
    %var_212 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_211, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_213 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_212, {  } %var_209, 1
    store { void (i32*, {  }, i32)*, {  } } %var_213, ptr %var_210
    %var_214 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_213, 0
    %var_215 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_213, 1
    %var_216 = alloca i32
    call void %var_214(i32* %var_216, {  } %var_215, i32 %var_207)
    %var_217 = load i32, ptr %var_216
    call void @printf(i8* @const_93, [3 x i8]* @const_218)
    %var_219 = extractvalue { i32, i8* } %arg_2, 1
    %var_220 = alloca {  }
    %var_221 = load {  }, ptr %var_220
    store {  } %var_221, ptr %var_220
    %var_222 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_223 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_222
    %var_224 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_223, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_225 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_224, {  } %var_221, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_225, ptr %var_222
    %var_226 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_225, 0
    %var_227 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_225, 1
    %var_228 = alloca i8*
    call void %var_226(i8** %var_228, {  } %var_227, i8* %var_219)
    %var_229 = load i8*, ptr %var_228
    call void @printf(i8* @const_93, [2 x i8]* @const_230)
    store { i32, i8* } %arg_2, ptr %arg_0
    ret void
}
define void @"generated_print_f32"(ptr sret(float) %arg_0, {  } %arg_1, float %arg_2) {
  entry_0: 
    call void @printf(i8* @const_282, float %arg_2)
    store float %arg_2, ptr %arg_0
    ret void
}
define void @"generated_print_i1"(ptr sret(i1) %arg_0, {  } %arg_1, i1 %arg_2) {
  entry_0: 
    %var_327 = select i1 %arg_2, [5 x i8]* @const_325, [5 x i8]* @const_326
    call void @printf(i8* @const_93, [5 x i8]* %var_327)
    store i1 %arg_2, ptr %arg_0
    ret void
}
define void @"generated_print_symbol"(ptr sret(i64) %arg_0, {  } %arg_1, i64 %arg_2) {
  entry_0: 
    %var_372 = alloca {  }
    %var_373 = load {  }, ptr %var_372
    store {  } %var_373, ptr %var_372
    %var_374 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_375 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_374
    %var_376 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_375, void (i64*, {  }, i64)* @print_symbol_wrap, 0
    %var_377 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_376, {  } %var_373, 1
    store { void (i64*, {  }, i64)*, {  } } %var_377, ptr %var_374
    %var_378 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_377, 0
    %var_379 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_377, 1
    %var_380 = alloca i64
    call void %var_378(i64* %var_380, {  } %var_379, i64 %arg_2)
    %var_381 = load i64, ptr %var_380
    store i64 %arg_2, ptr %arg_0
    ret void
}
declare void @print_symbol(i64)
define void @print_symbol_wrap(ptr sret(i64) %arg_0, {  } %arg_1, i64 %arg_2) {
  entry_0: 
    call void @print_symbol(i64 %arg_2)
    store i64 %arg_2, ptr %arg_0
    ret void
}
"
`;

exports[`generic print > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_92 = constant [4 x i8] c"fn[\\00"
@const_93 = constant [3 x i8] c"%s\\00"
@const_94 = constant [2 x i8] c"]\\00"
@const_116 = constant [2 x i8] c"\\0A\\00"
@const_127 = constant [3 x i8] c"%i\\00"
@const_156 = local_unnamed_addr constant i32 1
@const_206 = constant [7 x i8] c"tuple(\\00"
@const_218 = constant [3 x i8] c", \\00"
@const_230 = constant [2 x i8] c")\\00"
@const_239 = constant [3 x i8] c"ab\\00"
@const_282 = constant [3 x i8] c"%f\\00"
@const_287 = local_unnamed_addr constant float 1.250000e+00
@const_325 = constant [5 x i8] c"true\\00"
@const_326 = constant [6 x i8] c"false\\00"
@const_332 = local_unnamed_addr constant i1 true
@const_354 = local_unnamed_addr constant i1 false
@const_386 = local_unnamed_addr constant i64 0
@const_408 = local_unnamed_addr constant i64 1
@const_430 = local_unnamed_addr constant i64 2
@const_436 = constant [5 x i8] c"unit\\00"
@const_437 = constant [12 x i8] c"atom_atom_a\\00"
@const_438 = constant [16 x i8] c"symbol_symbol_a\\00"
@symbols_metadata_array = constant [3 x { ptr }] [{ ptr } { ptr @const_436 }, { ptr } { ptr @const_437 }, { ptr } { ptr @const_438 }]
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_93, ptr nonnull @const_92)
  tail call void @printf(ptr nonnull @const_93, ptr nonnull @const_94)
  tail call void @printf(ptr nonnull @const_93, ptr nonnull @const_116)
  tail call void @printf(ptr nonnull @const_93, ptr nonnull @const_92)
  tail call void @printf(ptr nonnull @const_127, i32 1)
  tail call void @printf(ptr nonnull @const_93, ptr nonnull @const_94)
  tail call void @printf(ptr nonnull @const_93, ptr nonnull @const_116)
  tail call void @printf(ptr nonnull @const_93, ptr nonnull @const_92)
  tail call void @printf(ptr nonnull @const_93, ptr nonnull @const_94)
  tail call void @printf(ptr nonnull @const_93, ptr nonnull @const_116)
  tail call void @printf(ptr nonnull @const_93, ptr nonnull @const_206)
  tail call void @printf(ptr nonnull @const_127, i32 1)
  tail call void @printf(ptr nonnull @const_93, ptr nonnull @const_218)
  tail call void @printf(ptr nonnull @const_93, ptr nonnull @const_239)
  tail call void @printf(ptr nonnull @const_93, ptr nonnull @const_230)
  tail call void @printf(ptr nonnull @const_93, ptr nonnull @const_116)
  tail call void @printf(ptr nonnull @const_127, i32 1)
  tail call void @printf(ptr nonnull @const_93, ptr nonnull @const_116)
  tail call void @printf(ptr nonnull @const_282, float 1.250000e+00)
  tail call void @printf(ptr nonnull @const_93, ptr nonnull @const_116)
  tail call void @printf(ptr nonnull @const_93, ptr nonnull @const_239)
  tail call void @printf(ptr nonnull @const_93, ptr nonnull @const_116)
  tail call void @printf(ptr nonnull @const_93, ptr nonnull @const_325)
  tail call void @printf(ptr nonnull @const_93, ptr nonnull @const_116)
  tail call void @printf(ptr nonnull @const_93, ptr nonnull @const_326)
  tail call void @printf(ptr nonnull @const_93, ptr nonnull @const_116)
  tail call void @print_symbol(i64 0)
  tail call void @printf(ptr nonnull @const_93, ptr nonnull @const_116)
  tail call void @print_symbol(i64 1)
  tail call void @printf(ptr nonnull @const_93, ptr nonnull @const_116)
  tail call void @print_symbol(i64 2)
  ret i32 0
}

define void @"generated_print_i32[](i32)"(ptr nocapture writeonly sret({ ptr, {} }) %arg_0, {} %arg_1, { ptr, {} } %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_93, ptr nonnull @const_92)
  tail call void @printf(ptr nonnull @const_93, ptr nonnull @const_94)
  %arg_2.elt = extractvalue { ptr, {} } %arg_2, 0
  store ptr %arg_2.elt, ptr %arg_0, align 8
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_99(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

define void @"generated_print_i8*"(ptr nocapture writeonly sret(ptr) %arg_0, {} %arg_1, ptr %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_93, ptr %arg_2)
  store ptr %arg_2, ptr %arg_0, align 8
  ret void
}

define void @"generated_print_i32[i32](i32)"(ptr nocapture writeonly sret({ ptr, { i32 } }) %arg_0, {} %arg_1, { ptr, { i32 } } %arg_2) local_unnamed_addr {
entry_0:
  %var_123 = extractvalue { ptr, { i32 } } %arg_2, 1
  tail call void @printf(ptr nonnull @const_93, ptr nonnull @const_92)
  %var_124 = extractvalue { i32 } %var_123, 0
  tail call void @printf(ptr nonnull @const_127, i32 %var_124)
  tail call void @printf(ptr nonnull @const_93, ptr nonnull @const_94)
  store { ptr, { i32 } } %arg_2, ptr %arg_0, align 8
  ret void
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_127, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_140(ptr nocapture writeonly sret({ ptr, { i32 } }) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  %var_146 = insertvalue { i32 } undef, i32 %arg_2, 0
  %var_151 = insertvalue { ptr, { i32 } } { ptr @fn_143, { i32 } undef }, { i32 } %var_146, 1
  store { ptr, { i32 } } %var_151, ptr %arg_0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_143(ptr nocapture writeonly sret(i32) %arg_0, { i32 } %arg_1, i32 %arg_2) #1 {
entry_0:
  %var_147 = extractvalue { i32 } %arg_1, 0
  store i32 %var_147, ptr %arg_0, align 4
  ret void
}

define void @"generated_print_i32[](i32, i32)"(ptr nocapture writeonly sret({ ptr, {} }) %arg_0, {} %arg_1, { ptr, {} } %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_93, ptr nonnull @const_92)
  tail call void @printf(ptr nonnull @const_93, ptr nonnull @const_94)
  %arg_2.elt = extractvalue { ptr, {} } %arg_2, 0
  store ptr %arg_2.elt, ptr %arg_0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_183(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2, i32 %arg_3) local_unnamed_addr #1 {
entry_0:
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

define void @"generated_print_(i32, i8*)"(ptr nocapture writeonly sret({ i32, ptr }) %arg_0, {} %arg_1, { i32, ptr } %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_93, ptr nonnull @const_206)
  %var_207 = extractvalue { i32, ptr } %arg_2, 0
  tail call void @printf(ptr nonnull @const_127, i32 %var_207)
  tail call void @printf(ptr nonnull @const_93, ptr nonnull @const_218)
  %var_219 = extractvalue { i32, ptr } %arg_2, 1
  tail call void @printf(ptr nonnull @const_93, ptr %var_219)
  tail call void @printf(ptr nonnull @const_93, ptr nonnull @const_230)
  store { i32, ptr } %arg_2, ptr %arg_0, align 8
  ret void
}

define void @generated_print_f32(ptr nocapture writeonly sret(float) %arg_0, {} %arg_1, float %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_282, float %arg_2)
  store float %arg_2, ptr %arg_0, align 4
  ret void
}

define void @generated_print_i1(ptr nocapture writeonly sret(i1) %arg_0, {} %arg_1, i1 %arg_2) local_unnamed_addr {
entry_0:
  %var_327 = select i1 %arg_2, ptr @const_325, ptr @const_326
  tail call void @printf(ptr nonnull @const_93, ptr nonnull %var_327)
  store i1 %arg_2, ptr %arg_0, align 1
  ret void
}

define void @generated_print_symbol(ptr nocapture writeonly sret(i64) %arg_0, {} %arg_1, i64 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @print_symbol(i64 %arg_2)
  store i64 %arg_2, ptr %arg_0, align 8
  ret void
}

declare void @print_symbol(i64) local_unnamed_addr

define void @print_symbol_wrap(ptr nocapture writeonly sret(i64) %arg_0, {} %arg_1, i64 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @print_symbol(i64 %arg_2)
  store i64 %arg_2, ptr %arg_0, align 8
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`generic print > stderr 1`] = `[]`;

exports[`generic print > stdout 1`] = `
[
  "fn[]
fn[1]
fn[]
tuple(1, ab)
1
0.000000
ab
true
false
symbol(unit)
symbol(atom_atom_a)
symbol(symbol_symbol_a)",
]
`;

exports[`simply typed lambda calc compilation > apply > compiled 1`] = `
"@const_23 = constant [3 x i8] c"%i\\00"
@const_59 = constant i32 2
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_21 = alloca {  }
    %var_22 = load {  }, ptr %var_21
    store {  } %var_22, ptr %var_21
    %var_24 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_25 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_24
    %var_26 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_25, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_27 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_26, {  } %var_22, 1
    store { void (i32*, {  }, i32)*, {  } } %var_27, ptr %var_24
    %var_29 = alloca {  }
    %var_30 = load {  }, ptr %var_29
    store {  } %var_30, ptr %var_29
    %var_44 = alloca { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } }
    %var_45 = load { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } }, ptr %var_44
    %var_46 = insertvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_45, void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })* @fn_28, 0
    %var_47 = insertvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_46, {  } %var_30, 1
    store { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_47, ptr %var_44
    %var_49 = alloca {  }
    %var_50 = load {  }, ptr %var_49
    store {  } %var_50, ptr %var_49
    %var_51 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_52 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_51
    %var_53 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_52, void (i32*, {  }, i32)* @fn_48, 0
    %var_54 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_53, {  } %var_50, 1
    store { void (i32*, {  }, i32)*, {  } } %var_54, ptr %var_51
    %var_55 = extractvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_47, 0
    %var_56 = extractvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_47, 1
    %var_57 = alloca { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }
    call void %var_55({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }* %var_57, {  } %var_56, { void (i32*, {  }, i32)*, {  } } %var_54)
    %var_58 = load { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }, ptr %var_57
    %var_60 = load i32, ptr @const_59
    %var_61 = extractvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_58, 0
    %var_62 = extractvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_58, 1
    %var_63 = alloca i32
    call void %var_61(i32* %var_63, { { void (i32*, {  }, i32)*, {  } } } %var_62, i32 %var_60)
    %var_64 = load i32, ptr %var_63
    %var_65 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_27, 0
    %var_66 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_27, 1
    %var_67 = alloca i32
    call void %var_65(i32* %var_67, {  } %var_66, i32 %var_64)
    %var_68 = load i32, ptr %var_67
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_23, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_28(ptr sret({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }) %arg_0, {  } %arg_1, { void (i32*, {  }, i32)*, {  } } %arg_2) {
  entry_0: 
    %var_32 = alloca { { void (i32*, {  }, i32)*, {  } } }
    %var_33 = load { { void (i32*, {  }, i32)*, {  } } }, ptr %var_32
    %var_34 = insertvalue { { void (i32*, {  }, i32)*, {  } } } %var_33, { void (i32*, {  }, i32)*, {  } } %arg_2, 0
    store { { void (i32*, {  }, i32)*, {  } } } %var_34, ptr %var_32
    %var_40 = alloca { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }
    %var_41 = load { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }, ptr %var_40
    %var_42 = insertvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_41, void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)* @fn_31, 0
    %var_43 = insertvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_42, { { void (i32*, {  }, i32)*, {  } } } %var_34, 1
    store { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_43, ptr %var_40
    store { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_43, ptr %arg_0
    ret void
}
define void @fn_31(ptr sret(i32) %arg_0, { { void (i32*, {  }, i32)*, {  } } } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_35 = extractvalue { { void (i32*, {  }, i32)*, {  } } } %arg_1, 0
    %var_36 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_35, 0
    %var_37 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_35, 1
    %var_38 = alloca i32
    call void %var_36(i32* %var_38, {  } %var_37, i32 %arg_2)
    %var_39 = load i32, ptr %var_38
    store i32 %var_39, ptr %arg_0
    ret void
}
define void @fn_48(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    store i32 %arg_2, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > apply > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_23 = constant [3 x i8] c"%i\\00"
@const_59 = local_unnamed_addr constant i32 2
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_23, i32 2)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_23, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_28(ptr nocapture writeonly sret({ ptr, { { ptr, {} } } }) %arg_0, {} %arg_1, { ptr, {} } %arg_2) local_unnamed_addr #1 {
entry_0:
  store ptr @fn_31, ptr %arg_0, align 8
  %arg_0.repack1 = getelementptr inbounds { ptr, { { ptr, {} } } }, ptr %arg_0, i64 0, i32 1
  %arg_2.elt = extractvalue { ptr, {} } %arg_2, 0
  store ptr %arg_2.elt, ptr %arg_0.repack1, align 8
  ret void
}

define void @fn_31(ptr nocapture writeonly sret(i32) %arg_0, { { ptr, {} } } %arg_1, i32 %arg_2) {
entry_0:
  %var_35 = extractvalue { { ptr, {} } } %arg_1, 0
  %var_36 = extractvalue { ptr, {} } %var_35, 0
  %var_38 = alloca i32, align 4
  call void %var_36(ptr nonnull %var_38, {} zeroinitializer, i32 %arg_2)
  %var_39 = load i32, ptr %var_38, align 4
  store i32 %var_39, ptr %arg_0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_48(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > apply > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > apply > stdout 1`] = `
[
  "2",
]
`;

exports[`simply typed lambda calc compilation > church tuple > compiled 1`] = `
"@const_31 = constant [3 x i8] c"%i\\00"
@const_71 = constant i32 1
@const_77 = constant i32 2
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_29 = alloca {  }
    %var_30 = load {  }, ptr %var_29
    store {  } %var_30, ptr %var_29
    %var_32 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_33 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_32
    %var_34 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_33, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_35 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_34, {  } %var_30, 1
    store { void (i32*, {  }, i32)*, {  } } %var_35, ptr %var_32
    %var_37 = alloca {  }
    %var_38 = load {  }, ptr %var_37
    store {  } %var_38, ptr %var_37
    %var_67 = alloca { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }
    %var_68 = load { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_67
    %var_69 = insertvalue { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_68, void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)* @fn_36, 0
    %var_70 = insertvalue { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_69, {  } %var_38, 1
    store { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_70, ptr %var_67
    %var_72 = load i32, ptr @const_71
    %var_73 = extractvalue { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_70, 0
    %var_74 = extractvalue { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_70, 1
    %var_75 = alloca { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }
    call void %var_73({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }* %var_75, {  } %var_74, i32 %var_72)
    %var_76 = load { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }, ptr %var_75
    %var_78 = load i32, ptr @const_77
    %var_79 = extractvalue { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_76, 0
    %var_80 = extractvalue { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_76, 1
    %var_81 = alloca { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }
    call void %var_79({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }* %var_81, { i32 } %var_80, i32 %var_78)
    %var_82 = load { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }, ptr %var_81
    %var_84 = alloca {  }
    %var_85 = load {  }, ptr %var_84
    store {  } %var_85, ptr %var_84
    %var_95 = alloca { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }
    %var_96 = load { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_95
    %var_97 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_96, void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)* @fn_83, 0
    %var_98 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_97, {  } %var_85, 1
    store { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_98, ptr %var_95
    %var_99 = extractvalue { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_82, 0
    %var_100 = extractvalue { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_82, 1
    %var_101 = alloca i32
    call void %var_99(i32* %var_101, { i32, i32 } %var_100, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_98)
    %var_102 = load i32, ptr %var_101
    %var_103 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_35, 0
    %var_104 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_35, 1
    %var_105 = alloca i32
    call void %var_103(i32* %var_105, {  } %var_104, i32 %var_102)
    %var_106 = load i32, ptr %var_105
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_31, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_36(ptr sret({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_40 = alloca { i32 }
    %var_41 = load { i32 }, ptr %var_40
    %var_42 = insertvalue { i32 } %var_41, i32 %arg_2, 0
    store { i32 } %var_42, ptr %var_40
    %var_63 = alloca { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }
    %var_64 = load { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }, ptr %var_63
    %var_65 = insertvalue { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_64, void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)* @fn_39, 0
    %var_66 = insertvalue { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_65, { i32 } %var_42, 1
    store { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_66, ptr %var_63
    store { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_66, ptr %arg_0
    ret void
}
define void @fn_39(ptr sret({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }) %arg_0, { i32 } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_43 = extractvalue { i32 } %arg_1, 0
    %var_45 = alloca { i32, i32 }
    %var_46 = load { i32, i32 }, ptr %var_45
    %var_47 = insertvalue { i32, i32 } %var_46, i32 %var_43, 0
    %var_48 = insertvalue { i32, i32 } %var_47, i32 %arg_2, 1
    store { i32, i32 } %var_48, ptr %var_45
    %var_59 = alloca { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }
    %var_60 = load { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }, ptr %var_59
    %var_61 = insertvalue { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_60, void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })* @fn_44, 0
    %var_62 = insertvalue { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_61, { i32, i32 } %var_48, 1
    store { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_62, ptr %var_59
    store { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_62, ptr %arg_0
    ret void
}
define void @fn_44(ptr sret(i32) %arg_0, { i32, i32 } %arg_1, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %arg_2) {
  entry_0: 
    %var_49 = extractvalue { i32, i32 } %arg_1, 0
    %var_50 = extractvalue { i32, i32 } %arg_1, 1
    %var_51 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %arg_2, 0
    %var_52 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %arg_2, 1
    %var_53 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    call void %var_51({ void (i32*, { i32 }, i32)*, { i32 } }* %var_53, {  } %var_52, i32 %var_49)
    %var_54 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_53
    %var_55 = extractvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_54, 0
    %var_56 = extractvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_54, 1
    %var_57 = alloca i32
    call void %var_55(i32* %var_57, { i32 } %var_56, i32 %var_50)
    %var_58 = load i32, ptr %var_57
    store i32 %var_58, ptr %arg_0
    ret void
}
define void @fn_83(ptr sret({ void (i32*, { i32 }, i32)*, { i32 } }) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_87 = alloca { i32 }
    %var_88 = load { i32 }, ptr %var_87
    %var_89 = insertvalue { i32 } %var_88, i32 %arg_2, 0
    store { i32 } %var_89, ptr %var_87
    %var_91 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    %var_92 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_91
    %var_93 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_92, void (i32*, { i32 }, i32)* @fn_86, 0
    %var_94 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_93, { i32 } %var_89, 1
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_94, ptr %var_91
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_94, ptr %arg_0
    ret void
}
define void @fn_86(ptr sret(i32) %arg_0, { i32 } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_90 = extractvalue { i32 } %arg_1, 0
    store i32 %var_90, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > church tuple > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_31 = constant [3 x i8] c"%i\\00"
@const_71 = local_unnamed_addr constant i32 1
@const_77 = local_unnamed_addr constant i32 2
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_31, i32 1)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_31, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_36(ptr nocapture writeonly sret({ ptr, { i32 } }) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  %var_42 = insertvalue { i32 } undef, i32 %arg_2, 0
  %var_66 = insertvalue { ptr, { i32 } } { ptr @fn_39, { i32 } undef }, { i32 } %var_42, 1
  store { ptr, { i32 } } %var_66, ptr %arg_0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_39(ptr nocapture writeonly sret({ ptr, { i32, i32 } }) %arg_0, { i32 } %arg_1, i32 %arg_2) #1 {
entry_0:
  %var_43 = extractvalue { i32 } %arg_1, 0
  store ptr @fn_44, ptr %arg_0, align 8
  %arg_0.repack1 = getelementptr inbounds { ptr, { i32, i32 } }, ptr %arg_0, i64 0, i32 1
  store i32 %var_43, ptr %arg_0.repack1, align 8
  %arg_0.repack1.repack3 = getelementptr inbounds { ptr, { i32, i32 } }, ptr %arg_0, i64 0, i32 1, i32 1
  store i32 %arg_2, ptr %arg_0.repack1.repack3, align 4
  ret void
}

define void @fn_44(ptr nocapture writeonly sret(i32) %arg_0, { i32, i32 } %arg_1, { ptr, {} } %arg_2) {
entry_0:
  %var_49 = extractvalue { i32, i32 } %arg_1, 0
  %var_50 = extractvalue { i32, i32 } %arg_1, 1
  %var_51 = extractvalue { ptr, {} } %arg_2, 0
  %var_53 = alloca { ptr, { i32 } }, align 8
  call void %var_51(ptr nonnull %var_53, {} zeroinitializer, i32 %var_49)
  %var_54.fca.0.load = load ptr, ptr %var_53, align 8
  %var_54.fca.1.0.gep = getelementptr inbounds { ptr, { i32 } }, ptr %var_53, i64 0, i32 1, i32 0
  %var_54.fca.1.0.load = load i32, ptr %var_54.fca.1.0.gep, align 8
  %var_56 = insertvalue { i32 } poison, i32 %var_54.fca.1.0.load, 0
  %var_57 = alloca i32, align 4
  call void %var_54.fca.0.load(ptr nonnull %var_57, { i32 } %var_56, i32 %var_50)
  %var_58 = load i32, ptr %var_57, align 4
  store i32 %var_58, ptr %arg_0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_83(ptr nocapture writeonly sret({ ptr, { i32 } }) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  %var_89 = insertvalue { i32 } undef, i32 %arg_2, 0
  %var_94 = insertvalue { ptr, { i32 } } { ptr @fn_86, { i32 } undef }, { i32 } %var_89, 1
  store { ptr, { i32 } } %var_94, ptr %arg_0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_86(ptr nocapture writeonly sret(i32) %arg_0, { i32 } %arg_1, i32 %arg_2) #1 {
entry_0:
  %var_90 = extractvalue { i32 } %arg_1, 0
  store i32 %var_90, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > church tuple > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > church tuple > stdout 1`] = `
[
  "1",
]
`;

exports[`simply typed lambda calc compilation > church tuple 2 > compiled 1`] = `
"@const_24 = constant [3 x i8] c"%i\\00"
@const_40 = constant i32 1
@const_42 = constant i32 2
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_22 = alloca {  }
    %var_23 = load {  }, ptr %var_22
    store {  } %var_23, ptr %var_22
    %var_25 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_26 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_25
    %var_27 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_26, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_28 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_27, {  } %var_23, 1
    store { void (i32*, {  }, i32)*, {  } } %var_28, ptr %var_25
    %var_30 = alloca {  }
    %var_31 = load {  }, ptr %var_30
    store {  } %var_31, ptr %var_30
    %var_36 = alloca { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } }
    %var_37 = load { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } }, ptr %var_36
    %var_38 = insertvalue { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_37, void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })* @fn_29, 0
    %var_39 = insertvalue { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_38, {  } %var_31, 1
    store { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_39, ptr %var_36
    %var_41 = load i32, ptr @const_40
    %var_43 = load i32, ptr @const_42
    %var_45 = alloca {  }
    %var_46 = load {  }, ptr %var_45
    store {  } %var_46, ptr %var_45
    %var_47 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_48 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_47
    %var_49 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_48, void (i32*, {  }, i32)* @fn_44, 0
    %var_50 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_49, {  } %var_46, 1
    store { void (i32*, {  }, i32)*, {  } } %var_50, ptr %var_47
    %var_51 = extractvalue { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_39, 0
    %var_52 = extractvalue { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_39, 1
    %var_53 = alloca i32
    call void %var_51(i32* %var_53, {  } %var_52, i32 %var_41, i32 %var_43, { void (i32*, {  }, i32, i32)*, {  } } %var_50)
    %var_54 = load i32, ptr %var_53
    %var_55 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_28, 0
    %var_56 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_28, 1
    %var_57 = alloca i32
    call void %var_55(i32* %var_57, {  } %var_56, i32 %var_54)
    %var_58 = load i32, ptr %var_57
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_24, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_29(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2, i32 %arg_3, { void (i32*, {  }, i32, i32)*, {  } } %arg_4) {
  entry_0: 
    %var_32 = extractvalue { void (i32*, {  }, i32, i32)*, {  } } %arg_4, 0
    %var_33 = extractvalue { void (i32*, {  }, i32, i32)*, {  } } %arg_4, 1
    %var_34 = alloca i32
    call void %var_32(i32* %var_34, {  } %var_33, i32 %arg_2, i32 %arg_3)
    %var_35 = load i32, ptr %var_34
    store i32 %var_35, ptr %arg_0
    ret void
}
define void @fn_44(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    store i32 %arg_2, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > church tuple 2 > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_24 = constant [3 x i8] c"%i\\00"
@const_40 = local_unnamed_addr constant i32 1
@const_42 = local_unnamed_addr constant i32 2
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_24, i32 1)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_24, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

define void @fn_29(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2, i32 %arg_3, { ptr, {} } %arg_4) local_unnamed_addr {
entry_0:
  %var_32 = extractvalue { ptr, {} } %arg_4, 0
  %var_34 = alloca i32, align 4
  call void %var_32(ptr nonnull %var_34, {} zeroinitializer, i32 %arg_2, i32 %arg_3)
  %var_35 = load i32, ptr %var_34, align 4
  store i32 %var_35, ptr %arg_0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_44(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > church tuple 2 > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > church tuple 2 > stdout 1`] = `
[
  "1",
]
`;

exports[`simply typed lambda calc compilation > either > compiled 1`] = `
"@const_29 = constant [3 x i8] c"%i\\00"
@const_65 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_27 = alloca {  }
    %var_28 = load {  }, ptr %var_27
    store {  } %var_28, ptr %var_27
    %var_30 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_31 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_30
    %var_32 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_31, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_33 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_32, {  } %var_28, 1
    store { void (i32*, {  }, i32)*, {  } } %var_33, ptr %var_30
    %var_35 = alloca {  }
    %var_36 = load {  }, ptr %var_35
    store {  } %var_36, ptr %var_35
    %var_61 = alloca { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } }
    %var_62 = load { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_61
    %var_63 = insertvalue { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } } %var_62, void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)* @fn_34, 0
    %var_64 = insertvalue { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } } %var_63, {  } %var_36, 1
    store { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } } %var_64, ptr %var_61
    %var_66 = load i32, ptr @const_65
    %var_67 = extractvalue { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } } %var_64, 0
    %var_68 = extractvalue { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } } %var_64, 1
    %var_69 = alloca { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }
    call void %var_67({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }* %var_69, {  } %var_68, i32 %var_66)
    %var_70 = load { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }, ptr %var_69
    %var_72 = alloca {  }
    %var_73 = load {  }, ptr %var_72
    store {  } %var_73, ptr %var_72
    %var_74 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_75 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_74
    %var_76 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_75, void (i32*, {  }, i32)* @fn_71, 0
    %var_77 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_76, {  } %var_73, 1
    store { void (i32*, {  }, i32)*, {  } } %var_77, ptr %var_74
    %var_78 = extractvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_70, 0
    %var_79 = extractvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_70, 1
    %var_80 = alloca { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }
    call void %var_78({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }* %var_80, { i32 } %var_79, { void (i32*, {  }, i32)*, {  } } %var_77)
    %var_81 = load { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }, ptr %var_80
    %var_83 = alloca {  }
    %var_84 = load {  }, ptr %var_83
    store {  } %var_84, ptr %var_83
    %var_85 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_86 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_85
    %var_87 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_86, void (i32*, {  }, i32)* @fn_82, 0
    %var_88 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_87, {  } %var_84, 1
    store { void (i32*, {  }, i32)*, {  } } %var_88, ptr %var_85
    %var_89 = extractvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_81, 0
    %var_90 = extractvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_81, 1
    %var_91 = alloca i32
    call void %var_89(i32* %var_91, { { void (i32*, {  }, i32)*, {  } }, i32 } %var_90, { void (i32*, {  }, i32)*, {  } } %var_88)
    %var_92 = load i32, ptr %var_91
    %var_93 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_33, 0
    %var_94 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_33, 1
    %var_95 = alloca i32
    call void %var_93(i32* %var_95, {  } %var_94, i32 %var_92)
    %var_96 = load i32, ptr %var_95
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_29, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_34(ptr sret({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_38 = alloca { i32 }
    %var_39 = load { i32 }, ptr %var_38
    %var_40 = insertvalue { i32 } %var_39, i32 %arg_2, 0
    store { i32 } %var_40, ptr %var_38
    %var_57 = alloca { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }
    %var_58 = load { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }, ptr %var_57
    %var_59 = insertvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_58, void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })* @fn_37, 0
    %var_60 = insertvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_59, { i32 } %var_40, 1
    store { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_60, ptr %var_57
    store { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_60, ptr %arg_0
    ret void
}
define void @fn_37(ptr sret({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }) %arg_0, { i32 } %arg_1, { void (i32*, {  }, i32)*, {  } } %arg_2) {
  entry_0: 
    %var_41 = extractvalue { i32 } %arg_1, 0
    %var_43 = alloca { { void (i32*, {  }, i32)*, {  } }, i32 }
    %var_44 = load { { void (i32*, {  }, i32)*, {  } }, i32 }, ptr %var_43
    %var_45 = insertvalue { { void (i32*, {  }, i32)*, {  } }, i32 } %var_44, { void (i32*, {  }, i32)*, {  } } %arg_2, 0
    %var_46 = insertvalue { { void (i32*, {  }, i32)*, {  } }, i32 } %var_45, i32 %var_41, 1
    store { { void (i32*, {  }, i32)*, {  } }, i32 } %var_46, ptr %var_43
    %var_53 = alloca { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }
    %var_54 = load { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }, ptr %var_53
    %var_55 = insertvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_54, void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })* @fn_42, 0
    %var_56 = insertvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_55, { { void (i32*, {  }, i32)*, {  } }, i32 } %var_46, 1
    store { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_56, ptr %var_53
    store { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_56, ptr %arg_0
    ret void
}
define void @fn_42(ptr sret(i32) %arg_0, { { void (i32*, {  }, i32)*, {  } }, i32 } %arg_1, { void (i32*, {  }, i32)*, {  } } %arg_2) {
  entry_0: 
    %var_47 = extractvalue { { void (i32*, {  }, i32)*, {  } }, i32 } %arg_1, 0
    %var_48 = extractvalue { { void (i32*, {  }, i32)*, {  } }, i32 } %arg_1, 1
    %var_49 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_47, 0
    %var_50 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_47, 1
    %var_51 = alloca i32
    call void %var_49(i32* %var_51, {  } %var_50, i32 %var_48)
    %var_52 = load i32, ptr %var_51
    store i32 %var_52, ptr %arg_0
    ret void
}
define void @fn_71(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    store i32 %arg_2, ptr %arg_0
    ret void
}
define void @fn_82(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    store i32 %arg_2, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > either > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_29 = constant [3 x i8] c"%i\\00"
@const_65 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_29, i32 1)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_29, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_34(ptr nocapture writeonly sret({ ptr, { i32 } }) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  %var_40 = insertvalue { i32 } undef, i32 %arg_2, 0
  %var_60 = insertvalue { ptr, { i32 } } { ptr @fn_37, { i32 } undef }, { i32 } %var_40, 1
  store { ptr, { i32 } } %var_60, ptr %arg_0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_37(ptr nocapture writeonly sret({ ptr, { { ptr, {} }, i32 } }) %arg_0, { i32 } %arg_1, { ptr, {} } %arg_2) #1 {
entry_0:
  %var_41 = extractvalue { i32 } %arg_1, 0
  %var_45 = insertvalue { { ptr, {} }, i32 } { { ptr, {} } { ptr undef, {} poison }, i32 undef }, { ptr, {} } %arg_2, 0
  %var_46 = insertvalue { { ptr, {} }, i32 } %var_45, i32 %var_41, 1
  store ptr @fn_42, ptr %arg_0, align 8
  %arg_0.repack1 = getelementptr inbounds { ptr, { { ptr, {} }, i32 } }, ptr %arg_0, i64 0, i32 1
  store { { ptr, {} }, i32 } %var_46, ptr %arg_0.repack1, align 8
  ret void
}

define void @fn_42(ptr nocapture writeonly sret(i32) %arg_0, { { ptr, {} }, i32 } %arg_1, { ptr, {} } %arg_2) {
entry_0:
  %var_47 = extractvalue { { ptr, {} }, i32 } %arg_1, 0
  %var_48 = extractvalue { { ptr, {} }, i32 } %arg_1, 1
  %var_49 = extractvalue { ptr, {} } %var_47, 0
  %var_51 = alloca i32, align 4
  call void %var_49(ptr nonnull %var_51, {} zeroinitializer, i32 %var_48)
  %var_52 = load i32, ptr %var_51, align 4
  store i32 %var_52, ptr %arg_0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_71(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_82(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > either > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > either > stdout 1`] = `
[
  "1",
]
`;

exports[`simply typed lambda calc compilation > either 2 > compiled 1`] = `
"@const_25 = constant [3 x i8] c"%i\\00"
@const_41 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_23 = alloca {  }
    %var_24 = load {  }, ptr %var_23
    store {  } %var_24, ptr %var_23
    %var_26 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_27 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_26
    %var_28 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_27, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_29 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_28, {  } %var_24, 1
    store { void (i32*, {  }, i32)*, {  } } %var_29, ptr %var_26
    %var_31 = alloca {  }
    %var_32 = load {  }, ptr %var_31
    store {  } %var_32, ptr %var_31
    %var_37 = alloca { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } }
    %var_38 = load { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } }, ptr %var_37
    %var_39 = insertvalue { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_38, void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })* @fn_30, 0
    %var_40 = insertvalue { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_39, {  } %var_32, 1
    store { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_40, ptr %var_37
    %var_42 = load i32, ptr @const_41
    %var_44 = alloca {  }
    %var_45 = load {  }, ptr %var_44
    store {  } %var_45, ptr %var_44
    %var_46 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_47 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_46
    %var_48 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_47, void (i32*, {  }, i32)* @fn_43, 0
    %var_49 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_48, {  } %var_45, 1
    store { void (i32*, {  }, i32)*, {  } } %var_49, ptr %var_46
    %var_51 = alloca {  }
    %var_52 = load {  }, ptr %var_51
    store {  } %var_52, ptr %var_51
    %var_53 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_54 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_53
    %var_55 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_54, void (i32*, {  }, i32)* @fn_50, 0
    %var_56 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_55, {  } %var_52, 1
    store { void (i32*, {  }, i32)*, {  } } %var_56, ptr %var_53
    %var_57 = extractvalue { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_40, 0
    %var_58 = extractvalue { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_40, 1
    %var_59 = alloca i32
    call void %var_57(i32* %var_59, {  } %var_58, i32 %var_42, { void (i32*, {  }, i32)*, {  } } %var_49, { void (i32*, {  }, i32)*, {  } } %var_56)
    %var_60 = load i32, ptr %var_59
    %var_61 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_29, 0
    %var_62 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_29, 1
    %var_63 = alloca i32
    call void %var_61(i32* %var_63, {  } %var_62, i32 %var_60)
    %var_64 = load i32, ptr %var_63
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_25, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_30(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2, { void (i32*, {  }, i32)*, {  } } %arg_3, { void (i32*, {  }, i32)*, {  } } %arg_4) {
  entry_0: 
    %var_33 = extractvalue { void (i32*, {  }, i32)*, {  } } %arg_3, 0
    %var_34 = extractvalue { void (i32*, {  }, i32)*, {  } } %arg_3, 1
    %var_35 = alloca i32
    call void %var_33(i32* %var_35, {  } %var_34, i32 %arg_2)
    %var_36 = load i32, ptr %var_35
    store i32 %var_36, ptr %arg_0
    ret void
}
define void @fn_43(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    store i32 %arg_2, ptr %arg_0
    ret void
}
define void @fn_50(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    store i32 %arg_2, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > either 2 > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_25 = constant [3 x i8] c"%i\\00"
@const_41 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_25, i32 1)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_25, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

define void @fn_30(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2, { ptr, {} } %arg_3, { ptr, {} } %arg_4) local_unnamed_addr {
entry_0:
  %var_33 = extractvalue { ptr, {} } %arg_3, 0
  %var_35 = alloca i32, align 4
  call void %var_33(ptr nonnull %var_35, {} zeroinitializer, i32 %arg_2)
  %var_36 = load i32, ptr %var_35, align 4
  store i32 %var_36, ptr %arg_0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_43(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_50(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > either 2 > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > either 2 > stdout 1`] = `
[
  "1",
]
`;

exports[`simply typed lambda calc compilation > function application and literal print > compiled 1`] = `
"@const_17 = constant [3 x i8] c"%i\\00"
@const_30 = constant i32 2
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_15 = alloca {  }
    %var_16 = load {  }, ptr %var_15
    store {  } %var_16, ptr %var_15
    %var_18 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_19 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_18
    %var_20 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_19, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_21 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_20, {  } %var_16, 1
    store { void (i32*, {  }, i32)*, {  } } %var_21, ptr %var_18
    %var_23 = alloca {  }
    %var_24 = load {  }, ptr %var_23
    store {  } %var_24, ptr %var_23
    %var_26 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_27 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_26
    %var_28 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_27, void (i32*, {  }, i32)* @fn_22, 0
    %var_29 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_28, {  } %var_24, 1
    store { void (i32*, {  }, i32)*, {  } } %var_29, ptr %var_26
    %var_31 = load i32, ptr @const_30
    %var_32 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_29, 0
    %var_33 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_29, 1
    %var_34 = alloca i32
    call void %var_32(i32* %var_34, {  } %var_33, i32 %var_31)
    %var_35 = load i32, ptr %var_34
    %var_36 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_21, 0
    %var_37 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_21, 1
    %var_38 = alloca i32
    call void %var_36(i32* %var_38, {  } %var_37, i32 %var_35)
    %var_39 = load i32, ptr %var_38
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_17, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_22(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_25 = add i32 %arg_2, %arg_2
    store i32 %var_25, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > function application and literal print > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_17 = constant [3 x i8] c"%i\\00"
@const_30 = local_unnamed_addr constant i32 2
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_17, i32 4)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_17, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_22(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  %var_25 = shl i32 %arg_2, 1
  store i32 %var_25, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > function application and literal print > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > function application and literal print > stdout 1`] = `
[
  "4",
]
`;

exports[`simply typed lambda calc compilation > function closure > compiled 1`] = `
"@const_23 = constant [3 x i8] c"%i\\00"
@const_36 = constant i32 2
@const_48 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_21 = alloca {  }
    %var_22 = load {  }, ptr %var_21
    store {  } %var_22, ptr %var_21
    %var_24 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_25 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_24
    %var_26 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_25, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_27 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_26, {  } %var_22, 1
    store { void (i32*, {  }, i32)*, {  } } %var_27, ptr %var_24
    %var_29 = alloca {  }
    %var_30 = load {  }, ptr %var_29
    store {  } %var_30, ptr %var_29
    %var_44 = alloca { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }
    %var_45 = load { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_44
    %var_46 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_45, void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)* @fn_28, 0
    %var_47 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_46, {  } %var_30, 1
    store { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_47, ptr %var_44
    %var_49 = load i32, ptr @const_48
    %var_50 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_47, 0
    %var_51 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_47, 1
    %var_52 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    call void %var_50({ void (i32*, { i32 }, i32)*, { i32 } }* %var_52, {  } %var_51, i32 %var_49)
    %var_53 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_52
    %var_54 = load i32, ptr @const_36
    %var_55 = extractvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_53, 0
    %var_56 = extractvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_53, 1
    %var_57 = alloca i32
    call void %var_55(i32* %var_57, { i32 } %var_56, i32 %var_54)
    %var_58 = load i32, ptr %var_57
    %var_59 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_27, 0
    %var_60 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_27, 1
    %var_61 = alloca i32
    call void %var_59(i32* %var_61, {  } %var_60, i32 %var_58)
    %var_62 = load i32, ptr %var_61
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_23, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_28(ptr sret({ void (i32*, { i32 }, i32)*, { i32 } }) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_32 = alloca { i32 }
    %var_33 = load { i32 }, ptr %var_32
    %var_34 = insertvalue { i32 } %var_33, i32 %arg_2, 0
    store { i32 } %var_34, ptr %var_32
    %var_40 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    %var_41 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_40
    %var_42 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_41, void (i32*, { i32 }, i32)* @fn_31, 0
    %var_43 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_42, { i32 } %var_34, 1
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_43, ptr %var_40
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_43, ptr %arg_0
    ret void
}
define void @fn_31(ptr sret(i32) %arg_0, { i32 } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_35 = extractvalue { i32 } %arg_1, 0
    %var_37 = load i32, ptr @const_36
    %var_38 = mul i32 %var_37, %var_35
    %var_39 = add i32 %arg_2, %var_38
    store i32 %var_39, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > function closure > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_23 = constant [3 x i8] c"%i\\00"
@const_36 = local_unnamed_addr constant i32 2
@const_48 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_23, i32 4)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_23, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_28(ptr nocapture writeonly sret({ ptr, { i32 } }) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  %var_34 = insertvalue { i32 } undef, i32 %arg_2, 0
  %var_43 = insertvalue { ptr, { i32 } } { ptr @fn_31, { i32 } undef }, { i32 } %var_34, 1
  store { ptr, { i32 } } %var_43, ptr %arg_0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_31(ptr nocapture writeonly sret(i32) %arg_0, { i32 } %arg_1, i32 %arg_2) #1 {
entry_0:
  %var_35 = extractvalue { i32 } %arg_1, 0
  %var_38 = shl i32 %var_35, 1
  %var_39 = add i32 %var_38, %arg_2
  store i32 %var_39, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > function closure > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > function closure > stdout 1`] = `
[
  "4",
]
`;

exports[`simply typed lambda calc compilation > function deep closure > compiled 1`] = `
"@const_27 = constant [3 x i8] c"%i\\00"
@const_61 = constant i32 1
@const_67 = constant i32 3
@const_73 = constant i32 5
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_25 = alloca {  }
    %var_26 = load {  }, ptr %var_25
    store {  } %var_26, ptr %var_25
    %var_28 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_29 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_28
    %var_30 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_29, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_31 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_30, {  } %var_26, 1
    store { void (i32*, {  }, i32)*, {  } } %var_31, ptr %var_28
    %var_33 = alloca {  }
    %var_34 = load {  }, ptr %var_33
    store {  } %var_34, ptr %var_33
    %var_57 = alloca { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }
    %var_58 = load { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_57
    %var_59 = insertvalue { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_58, void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)* @fn_32, 0
    %var_60 = insertvalue { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_59, {  } %var_34, 1
    store { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_60, ptr %var_57
    %var_62 = load i32, ptr @const_61
    %var_63 = extractvalue { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_60, 0
    %var_64 = extractvalue { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_60, 1
    %var_65 = alloca { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }
    call void %var_63({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }* %var_65, {  } %var_64, i32 %var_62)
    %var_66 = load { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }, ptr %var_65
    %var_68 = load i32, ptr @const_67
    %var_69 = extractvalue { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_66, 0
    %var_70 = extractvalue { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_66, 1
    %var_71 = alloca { void (i32*, { i32, i32 }, i32)*, { i32, i32 } }
    call void %var_69({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }* %var_71, { i32 } %var_70, i32 %var_68)
    %var_72 = load { void (i32*, { i32, i32 }, i32)*, { i32, i32 } }, ptr %var_71
    %var_74 = load i32, ptr @const_73
    %var_75 = extractvalue { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_72, 0
    %var_76 = extractvalue { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_72, 1
    %var_77 = alloca i32
    call void %var_75(i32* %var_77, { i32, i32 } %var_76, i32 %var_74)
    %var_78 = load i32, ptr %var_77
    %var_79 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_31, 0
    %var_80 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_31, 1
    %var_81 = alloca i32
    call void %var_79(i32* %var_81, {  } %var_80, i32 %var_78)
    %var_82 = load i32, ptr %var_81
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_27, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_32(ptr sret({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_36 = alloca { i32 }
    %var_37 = load { i32 }, ptr %var_36
    %var_38 = insertvalue { i32 } %var_37, i32 %arg_2, 0
    store { i32 } %var_38, ptr %var_36
    %var_53 = alloca { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }
    %var_54 = load { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }, ptr %var_53
    %var_55 = insertvalue { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_54, void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)* @fn_35, 0
    %var_56 = insertvalue { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_55, { i32 } %var_38, 1
    store { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_56, ptr %var_53
    store { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_56, ptr %arg_0
    ret void
}
define void @fn_35(ptr sret({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }) %arg_0, { i32 } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_39 = extractvalue { i32 } %arg_1, 0
    %var_41 = alloca { i32, i32 }
    %var_42 = load { i32, i32 }, ptr %var_41
    %var_43 = insertvalue { i32, i32 } %var_42, i32 %var_39, 0
    %var_44 = insertvalue { i32, i32 } %var_43, i32 %arg_2, 1
    store { i32, i32 } %var_44, ptr %var_41
    %var_49 = alloca { void (i32*, { i32, i32 }, i32)*, { i32, i32 } }
    %var_50 = load { void (i32*, { i32, i32 }, i32)*, { i32, i32 } }, ptr %var_49
    %var_51 = insertvalue { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_50, void (i32*, { i32, i32 }, i32)* @fn_40, 0
    %var_52 = insertvalue { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_51, { i32, i32 } %var_44, 1
    store { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_52, ptr %var_49
    store { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_52, ptr %arg_0
    ret void
}
define void @fn_40(ptr sret(i32) %arg_0, { i32, i32 } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_45 = extractvalue { i32, i32 } %arg_1, 0
    %var_46 = extractvalue { i32, i32 } %arg_1, 1
    %var_47 = add i32 %var_46, %arg_2
    %var_48 = add i32 %var_45, %var_47
    store i32 %var_48, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > function deep closure > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_27 = constant [3 x i8] c"%i\\00"
@const_61 = local_unnamed_addr constant i32 1
@const_67 = local_unnamed_addr constant i32 3
@const_73 = local_unnamed_addr constant i32 5
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_27, i32 9)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_27, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_32(ptr nocapture writeonly sret({ ptr, { i32 } }) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  %var_38 = insertvalue { i32 } undef, i32 %arg_2, 0
  %var_56 = insertvalue { ptr, { i32 } } { ptr @fn_35, { i32 } undef }, { i32 } %var_38, 1
  store { ptr, { i32 } } %var_56, ptr %arg_0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_35(ptr nocapture writeonly sret({ ptr, { i32, i32 } }) %arg_0, { i32 } %arg_1, i32 %arg_2) #1 {
entry_0:
  %var_39 = extractvalue { i32 } %arg_1, 0
  store ptr @fn_40, ptr %arg_0, align 8
  %arg_0.repack1 = getelementptr inbounds { ptr, { i32, i32 } }, ptr %arg_0, i64 0, i32 1
  store i32 %var_39, ptr %arg_0.repack1, align 8
  %arg_0.repack1.repack3 = getelementptr inbounds { ptr, { i32, i32 } }, ptr %arg_0, i64 0, i32 1, i32 1
  store i32 %arg_2, ptr %arg_0.repack1.repack3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_40(ptr nocapture writeonly sret(i32) %arg_0, { i32, i32 } %arg_1, i32 %arg_2) #1 {
entry_0:
  %var_45 = extractvalue { i32, i32 } %arg_1, 0
  %var_46 = extractvalue { i32, i32 } %arg_1, 1
  %var_47 = add i32 %var_46, %arg_2
  %var_48 = add i32 %var_47, %var_45
  store i32 %var_48, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > function deep closure > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > function deep closure > stdout 1`] = `
[
  "9",
]
`;

exports[`simply typed lambda calc compilation > function multiple args > compiled 1`] = `
"@const_21 = constant [3 x i8] c"%i\\00"
@const_29 = constant i32 2
@const_37 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_19 = alloca {  }
    %var_20 = load {  }, ptr %var_19
    store {  } %var_20, ptr %var_19
    %var_22 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_23 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_22
    %var_24 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_23, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_25 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_24, {  } %var_20, 1
    store { void (i32*, {  }, i32)*, {  } } %var_25, ptr %var_22
    %var_27 = alloca {  }
    %var_28 = load {  }, ptr %var_27
    store {  } %var_28, ptr %var_27
    %var_33 = alloca { void (i32*, {  }, i32, i32)*, {  } }
    %var_34 = load { void (i32*, {  }, i32, i32)*, {  } }, ptr %var_33
    %var_35 = insertvalue { void (i32*, {  }, i32, i32)*, {  } } %var_34, void (i32*, {  }, i32, i32)* @fn_26, 0
    %var_36 = insertvalue { void (i32*, {  }, i32, i32)*, {  } } %var_35, {  } %var_28, 1
    store { void (i32*, {  }, i32, i32)*, {  } } %var_36, ptr %var_33
    %var_38 = load i32, ptr @const_37
    %var_39 = load i32, ptr @const_29
    %var_40 = extractvalue { void (i32*, {  }, i32, i32)*, {  } } %var_36, 0
    %var_41 = extractvalue { void (i32*, {  }, i32, i32)*, {  } } %var_36, 1
    %var_42 = alloca i32
    call void %var_40(i32* %var_42, {  } %var_41, i32 %var_38, i32 %var_39)
    %var_43 = load i32, ptr %var_42
    %var_44 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_25, 0
    %var_45 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_25, 1
    %var_46 = alloca i32
    call void %var_44(i32* %var_46, {  } %var_45, i32 %var_43)
    %var_47 = load i32, ptr %var_46
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_21, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_26(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2, i32 %arg_3) {
  entry_0: 
    %var_30 = load i32, ptr @const_29
    %var_31 = mul i32 %var_30, %arg_2
    %var_32 = add i32 %arg_3, %var_31
    store i32 %var_32, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > function multiple args > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_21 = constant [3 x i8] c"%i\\00"
@const_29 = local_unnamed_addr constant i32 2
@const_37 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_21, i32 4)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_21, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_26(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2, i32 %arg_3) local_unnamed_addr #1 {
entry_0:
  %var_31 = shl i32 %arg_2, 1
  %var_32 = add i32 %var_31, %arg_3
  store i32 %var_32, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > function multiple args > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > function multiple args > stdout 1`] = `
[
  "4",
]
`;

exports[`simply typed lambda calc compilation > hello world > compiled 1`] = `
"@const_11 = constant [3 x i8] c"%s\\00"
@const_16 = constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_9 = alloca {  }
    %var_10 = load {  }, ptr %var_9
    store {  } %var_10, ptr %var_9
    %var_12 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_13 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_12
    %var_14 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_13, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_15 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_14, {  } %var_10, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_15, ptr %var_12
    %var_17 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_15, 0
    %var_18 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_15, 1
    %var_19 = alloca i8*
    call void %var_17(i8** %var_19, {  } %var_18, i8* @const_16)
    %var_20 = load i8*, ptr %var_19
    ret i32 0
}
define void @"generated_print_i8*"(ptr sret(i8*) %arg_0, {  } %arg_1, i8* %arg_2) {
  entry_0: 
    call void @printf(i8* @const_11, i8* %arg_2)
    store i8* %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`simply typed lambda calc compilation > hello world > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_11 = constant [3 x i8] c"%s\\00"
@const_16 = constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_11, ptr nonnull @const_16)
  ret i32 0
}

define void @"generated_print_i8*"(ptr nocapture writeonly sret(ptr) %arg_0, {} %arg_1, ptr %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_11, ptr %arg_2)
  store ptr %arg_2, ptr %arg_0, align 8
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`simply typed lambda calc compilation > hello world > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > hello world > stdout 1`] = `
[
  "hello world!",
]
`;

exports[`simply typed lambda calc compilation > hello world string > compiled 1`] = `
"@const_7 = constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    ret i32 0
}
"
`;

exports[`simply typed lambda calc compilation > hello world string > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_7 = local_unnamed_addr constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef i32 @main() local_unnamed_addr #0 {
main:
  ret i32 0
}

attributes #0 = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) }
"
`;

exports[`simply typed lambda calc compilation > hello world string > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > hello world string > stdout 1`] = `[]`;

exports[`simply typed lambda calc compilation > print number > compiled 1`] = `
"@const_11 = constant [3 x i8] c"%i\\00"
@const_16 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_9 = alloca {  }
    %var_10 = load {  }, ptr %var_9
    store {  } %var_10, ptr %var_9
    %var_12 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_13 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_12
    %var_14 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_13, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_15 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_14, {  } %var_10, 1
    store { void (i32*, {  }, i32)*, {  } } %var_15, ptr %var_12
    %var_17 = load i32, ptr @const_16
    %var_18 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_15, 0
    %var_19 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_15, 1
    %var_20 = alloca i32
    call void %var_18(i32* %var_20, {  } %var_19, i32 %var_17)
    %var_21 = load i32, ptr %var_20
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_11, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`simply typed lambda calc compilation > print number > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_11 = constant [3 x i8] c"%i\\00"
@const_16 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_11, i32 1)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_11, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`simply typed lambda calc compilation > print number > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > print number > stdout 1`] = `
[
  "1",
]
`;

exports[`structured programming compilation > block > compiled 1`] = `
"@const_16 = constant [3 x i8] c"%i\\00"
@const_21 = constant i32 123
@const_23 = constant i32 234
@const_25 = constant i32 345
@const_27 = constant i32 456
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_14 = alloca {  }
    %var_15 = load {  }, ptr %var_14
    store {  } %var_15, ptr %var_14
    %var_17 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_18 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_17
    %var_19 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_18, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_20 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_19, {  } %var_15, 1
    store { void (i32*, {  }, i32)*, {  } } %var_20, ptr %var_17
    %var_22 = load i32, ptr @const_21
    %var_24 = load i32, ptr @const_23
    %var_26 = load i32, ptr @const_25
    %var_28 = load i32, ptr @const_27
    %var_29 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_20, 0
    %var_30 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_20, 1
    %var_31 = alloca i32
    call void %var_29(i32* %var_31, {  } %var_30, i32 %var_28)
    %var_32 = load i32, ptr %var_31
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_16, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > block > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_16 = constant [3 x i8] c"%i\\00"
@const_21 = local_unnamed_addr constant i32 123
@const_23 = local_unnamed_addr constant i32 234
@const_25 = local_unnamed_addr constant i32 345
@const_27 = local_unnamed_addr constant i32 456
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_16, i32 456)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_16, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > block > stderr 1`] = `[]`;

exports[`structured programming compilation > block > stdout 1`] = `
[
  "456",
]
`;

exports[`structured programming compilation > block variable assingment > compiled 1`] = `
"@const_21 = constant [3 x i8] c"%i\\00"
@const_26 = constant i32 123
@const_28 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_19 = alloca {  }
    %var_20 = load {  }, ptr %var_19
    store {  } %var_20, ptr %var_19
    %var_22 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_23 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_22
    %var_24 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_23, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_25 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_24, {  } %var_20, 1
    store { void (i32*, {  }, i32)*, {  } } %var_25, ptr %var_22
    %var_27 = load i32, ptr @const_26
    %var_29 = load i32, ptr @const_28
    %var_30 = add i32 %var_27, %var_29
    %var_31 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_25, 0
    %var_32 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_25, 1
    %var_33 = alloca i32
    call void %var_31(i32* %var_33, {  } %var_32, i32 %var_30)
    %var_34 = load i32, ptr %var_33
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_21, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > block variable assingment > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_21 = constant [3 x i8] c"%i\\00"
@const_26 = local_unnamed_addr constant i32 123
@const_28 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_21, i32 124)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_21, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > block variable assingment > stderr 1`] = `[]`;

exports[`structured programming compilation > block variable assingment > stdout 1`] = `
[
  "124",
]
`;

exports[`structured programming compilation > block variable declaration > compiled 1`] = `
"@const_16 = constant [3 x i8] c"%i\\00"
@const_21 = constant i32 123
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_14 = alloca {  }
    %var_15 = load {  }, ptr %var_14
    store {  } %var_15, ptr %var_14
    %var_17 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_18 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_17
    %var_19 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_18, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_20 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_19, {  } %var_15, 1
    store { void (i32*, {  }, i32)*, {  } } %var_20, ptr %var_17
    %var_22 = load i32, ptr @const_21
    %var_23 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_20, 0
    %var_24 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_20, 1
    %var_25 = alloca i32
    call void %var_23(i32* %var_25, {  } %var_24, i32 %var_22)
    %var_26 = load i32, ptr %var_25
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_16, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > block variable declaration > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_16 = constant [3 x i8] c"%i\\00"
@const_21 = local_unnamed_addr constant i32 123
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_16, i32 123)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_16, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > block variable declaration > stderr 1`] = `[]`;

exports[`structured programming compilation > block variable declaration > stdout 1`] = `
[
  "123",
]
`;

exports[`structured programming compilation > block variable shadowing > compiled 1`] = `
"@const_19 = constant [3 x i8] c"%i\\00"
@const_24 = constant i32 123
@const_26 = constant i32 234
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_17 = alloca {  }
    %var_18 = load {  }, ptr %var_17
    store {  } %var_18, ptr %var_17
    %var_20 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_21 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_20
    %var_22 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_21, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_23 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_22, {  } %var_18, 1
    store { void (i32*, {  }, i32)*, {  } } %var_23, ptr %var_20
    %var_25 = load i32, ptr @const_24
    %var_27 = load i32, ptr @const_26
    %var_28 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_23, 0
    %var_29 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_23, 1
    %var_30 = alloca i32
    call void %var_28(i32* %var_30, {  } %var_29, i32 %var_27)
    %var_31 = load i32, ptr %var_30
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_19, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > block variable shadowing > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_19 = constant [3 x i8] c"%i\\00"
@const_24 = local_unnamed_addr constant i32 123
@const_26 = local_unnamed_addr constant i32 234
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_19, i32 234)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_19, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > block variable shadowing > stderr 1`] = `[]`;

exports[`structured programming compilation > block variable shadowing > stdout 1`] = `
[
  "234",
]
`;

exports[`structured programming compilation > hello world twice > compiled 1`] = `
"@const_14 = constant [3 x i8] c"%s\\00"
@const_19 = constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_12 = alloca {  }
    %var_13 = load {  }, ptr %var_12
    store {  } %var_13, ptr %var_12
    %var_15 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_16 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_15
    %var_17 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_16, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_18 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_17, {  } %var_13, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_18, ptr %var_15
    %var_20 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_18, 0
    %var_21 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_18, 1
    %var_22 = alloca i8*
    call void %var_20(i8** %var_22, {  } %var_21, i8* @const_19)
    %var_23 = load i8*, ptr %var_22
    %var_24 = alloca {  }
    %var_25 = load {  }, ptr %var_24
    store {  } %var_25, ptr %var_24
    %var_26 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_27 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_26
    %var_28 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_27, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_29 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_28, {  } %var_25, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_29, ptr %var_26
    %var_30 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_29, 0
    %var_31 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_29, 1
    %var_32 = alloca i8*
    call void %var_30(i8** %var_32, {  } %var_31, i8* @const_19)
    %var_33 = load i8*, ptr %var_32
    ret i32 0
}
define void @"generated_print_i8*"(ptr sret(i8*) %arg_0, {  } %arg_1, i8* %arg_2) {
  entry_0: 
    call void @printf(i8* @const_14, i8* %arg_2)
    store i8* %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > hello world twice > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_14 = constant [3 x i8] c"%s\\00"
@const_19 = constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_14, ptr nonnull @const_19)
  tail call void @printf(ptr nonnull @const_14, ptr nonnull @const_19)
  ret i32 0
}

define void @"generated_print_i8*"(ptr nocapture writeonly sret(ptr) %arg_0, {} %arg_1, ptr %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_14, ptr %arg_2)
  store ptr %arg_2, ptr %arg_0, align 8
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > hello world twice > stderr 1`] = `[]`;

exports[`structured programming compilation > hello world twice > stdout 1`] = `
[
  "hello world!hello world!",
]
`;

exports[`structured programming compilation > if-then > compiled 1`] = `
"@const_15 = constant [3 x i8] c"%i\\00"
@const_20 = constant i1 1
@const_23 = constant i32 123
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_13 = alloca {  }
    %var_14 = load {  }, ptr %var_13
    store {  } %var_14, ptr %var_13
    %var_16 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_17 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_16
    %var_18 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_17, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_19 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_18, {  } %var_14, 1
    store { void (i32*, {  }, i32)*, {  } } %var_19, ptr %var_16
    %var_21 = load i1, ptr @const_20
    br i1 %var_21, label %then_1, label %if_rest22
  then_1: 
    %var_24 = load i32, ptr @const_23
    br label %if_rest22
  if_rest22: 
    %var_25 = phi i32 [%var_24, %then_1], [undef, %main]
    %var_26 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_19, 0
    %var_27 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_19, 1
    %var_28 = alloca i32
    call void %var_26(i32* %var_28, {  } %var_27, i32 %var_25)
    %var_29 = load i32, ptr %var_28
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_15, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > if-then > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_15 = constant [3 x i8] c"%i\\00"
@const_20 = local_unnamed_addr constant i1 true
@const_23 = local_unnamed_addr constant i32 123
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_15, i32 123)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_15, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > if-then > stderr 1`] = `[]`;

exports[`structured programming compilation > if-then > stdout 1`] = `
[
  "123",
]
`;

exports[`structured programming compilation > if-then-else > compiled 1`] = `
"@const_18 = constant [3 x i8] c"%i\\00"
@const_23 = constant i1 0
@const_26 = constant i32 123
@const_28 = constant i32 456
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_16 = alloca {  }
    %var_17 = load {  }, ptr %var_16
    store {  } %var_17, ptr %var_16
    %var_19 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_20 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_19
    %var_21 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_20, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_22 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_21, {  } %var_17, 1
    store { void (i32*, {  }, i32)*, {  } } %var_22, ptr %var_19
    %var_24 = load i1, ptr @const_23
    br i1 %var_24, label %then_1, label %else_2
  then_1: 
    %var_27 = load i32, ptr @const_26
    br label %if_rest25
  else_2: 
    %var_29 = load i32, ptr @const_28
    br label %if_rest25
  if_rest25: 
    %var_30 = phi i32 [%var_27, %then_1], [%var_29, %else_2]
    %var_31 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_22, 0
    %var_32 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_22, 1
    %var_33 = alloca i32
    call void %var_31(i32* %var_33, {  } %var_32, i32 %var_30)
    %var_34 = load i32, ptr %var_33
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_18, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > if-then-else > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_18 = constant [3 x i8] c"%i\\00"
@const_23 = local_unnamed_addr constant i1 false
@const_26 = local_unnamed_addr constant i32 123
@const_28 = local_unnamed_addr constant i32 456
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_18, i32 456)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_18, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > if-then-else > stderr 1`] = `[]`;

exports[`structured programming compilation > if-then-else > stdout 1`] = `
[
  "456",
]
`;

exports[`structured programming compilation > sequence > compiled 1`] = `
"@const_15 = constant [3 x i8] c"%i\\00"
@const_20 = constant i32 123
@const_22 = constant i32 234
@const_24 = constant i32 345
@const_26 = constant i32 456
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_13 = alloca {  }
    %var_14 = load {  }, ptr %var_13
    store {  } %var_14, ptr %var_13
    %var_16 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_17 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_16
    %var_18 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_17, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_19 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_18, {  } %var_14, 1
    store { void (i32*, {  }, i32)*, {  } } %var_19, ptr %var_16
    %var_21 = load i32, ptr @const_20
    %var_23 = load i32, ptr @const_22
    %var_25 = load i32, ptr @const_24
    %var_27 = load i32, ptr @const_26
    %var_28 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_19, 0
    %var_29 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_19, 1
    %var_30 = alloca i32
    call void %var_28(i32* %var_30, {  } %var_29, i32 %var_27)
    %var_31 = load i32, ptr %var_30
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_15, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > sequence > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_15 = constant [3 x i8] c"%i\\00"
@const_20 = local_unnamed_addr constant i32 123
@const_22 = local_unnamed_addr constant i32 234
@const_24 = local_unnamed_addr constant i32 345
@const_26 = local_unnamed_addr constant i32 456
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_15, i32 456)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_15, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > sequence > stderr 1`] = `[]`;

exports[`structured programming compilation > sequence > stdout 1`] = `
[
  "456",
]
`;

exports[`structured programming compilation > two prints > compiled 1`] = `
"@const_14 = constant [3 x i8] c"%s\\00"
@const_19 = constant [13 x i8] c"hello world!\\00"
@const_30 = constant [15 x i8] c"hello world 2!\\00"
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_12 = alloca {  }
    %var_13 = load {  }, ptr %var_12
    store {  } %var_13, ptr %var_12
    %var_15 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_16 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_15
    %var_17 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_16, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_18 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_17, {  } %var_13, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_18, ptr %var_15
    %var_20 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_18, 0
    %var_21 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_18, 1
    %var_22 = alloca i8*
    call void %var_20(i8** %var_22, {  } %var_21, i8* @const_19)
    %var_23 = load i8*, ptr %var_22
    %var_24 = alloca {  }
    %var_25 = load {  }, ptr %var_24
    store {  } %var_25, ptr %var_24
    %var_26 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_27 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_26
    %var_28 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_27, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_29 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_28, {  } %var_25, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_29, ptr %var_26
    %var_31 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_29, 0
    %var_32 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_29, 1
    %var_33 = alloca i8*
    call void %var_31(i8** %var_33, {  } %var_32, i8* @const_30)
    %var_34 = load i8*, ptr %var_33
    ret i32 0
}
define void @"generated_print_i8*"(ptr sret(i8*) %arg_0, {  } %arg_1, i8* %arg_2) {
  entry_0: 
    call void @printf(i8* @const_14, i8* %arg_2)
    store i8* %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > two prints > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_14 = constant [3 x i8] c"%s\\00"
@const_19 = constant [13 x i8] c"hello world!\\00"
@const_30 = constant [15 x i8] c"hello world 2!\\00"
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_14, ptr nonnull @const_19)
  tail call void @printf(ptr nonnull @const_14, ptr nonnull @const_30)
  ret i32 0
}

define void @"generated_print_i8*"(ptr nocapture writeonly sret(ptr) %arg_0, {} %arg_1, ptr %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_14, ptr %arg_2)
  store ptr %arg_2, ptr %arg_0, align 8
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > two prints > stderr 1`] = `[]`;

exports[`structured programming compilation > two prints > stdout 1`] = `
[
  "hello world!hello world 2!",
]
`;
