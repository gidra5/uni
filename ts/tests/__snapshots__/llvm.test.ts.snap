// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`data structures compilation > atom (global symbol) > compiled 1`] = `
"@const_33 = constant i64 0
@const_39 = constant [7 x i8] c"atom_a\\00"
@symbols_metadata_array = constant [1 x { i8* }] [{ i8* } { i8* @const_39 }]
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_9 = alloca {  }
    %var_10 = load {  }, ptr %var_9
    store {  } %var_10, ptr %var_9
    %var_29 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_30 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_29
    %var_31 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_30, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_32 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_31, {  } %var_10, 1
    store { void (i64*, {  }, i64)*, {  } } %var_32, ptr %var_29
    %var_34 = load i64, ptr @const_33
    %var_35 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_32, 0
    %var_36 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_32, 1
    %var_37 = alloca i64
    call void %var_35(i64* %var_37, {  } %var_36, i64 %var_34)
    %var_38 = load i64, ptr %var_37
    ret i32 0
}
define void @"generated_print_symbol"(ptr sret(i64) %var_11, {  } %var_12, i64 %var_13) {
  entry14: 
    %var_15 = alloca {  }
    %var_16 = load {  }, ptr %var_15
    store {  } %var_16, ptr %var_15
    %var_21 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_22 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_21
    %var_23 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_22, void (i64*, {  }, i64)* @print_symbol_wrap, 0
    %var_24 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_23, {  } %var_16, 1
    store { void (i64*, {  }, i64)*, {  } } %var_24, ptr %var_21
    %var_25 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_24, 0
    %var_26 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_24, 1
    %var_27 = alloca i64
    call void %var_25(i64* %var_27, {  } %var_26, i64 %var_13)
    %var_28 = load i64, ptr %var_27
    store i64 %var_13, ptr %var_11
    ret void
}
declare void @print_symbol(i64)
define void @print_symbol_wrap(ptr sret(i64) %var_17, {  } %var_18, i64 %var_19) {
  entry20: 
    call void @print_symbol(i64 %var_19)
    store i64 %var_19, ptr %var_17
    ret void
}
"
`;

exports[`data structures compilation > atom (global symbol) > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_33 = local_unnamed_addr constant i64 0
@const_39 = constant [7 x i8] c"atom_a\\00"
@symbols_metadata_array = constant [1 x { ptr }] [{ ptr } { ptr @const_39 }]
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @print_symbol(i64 0)
  ret i32 0
}

define void @generated_print_symbol(ptr nocapture writeonly sret(i64) %var_11, {} %var_12, i64 %var_13) local_unnamed_addr {
entry14:
  tail call void @print_symbol(i64 %var_13)
  store i64 %var_13, ptr %var_11, align 8
  ret void
}

declare void @print_symbol(i64) local_unnamed_addr

define void @print_symbol_wrap(ptr nocapture writeonly sret(i64) %var_17, {} %var_18, i64 %var_19) local_unnamed_addr {
entry20:
  tail call void @print_symbol(i64 %var_19)
  store i64 %var_19, ptr %var_17, align 8
  ret void
}
"
`;

exports[`data structures compilation > atom (global symbol) > stderr 1`] = `[]`;

exports[`data structures compilation > atom (global symbol) > stdout 1`] = `
[
  "symbol(atom_a)",
]
`;

exports[`data structures compilation > boolean false > compiled 1`] = `
"@const_15 = constant [5 x i8] c"true\\00"
@const_16 = constant [6 x i8] c"false\\00"
@const_18 = constant [3 x i8] c"%s\\00"
@const_23 = constant i1 0
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_9 = alloca {  }
    %var_10 = load {  }, ptr %var_9
    store {  } %var_10, ptr %var_9
    %var_19 = alloca { void (i1*, {  }, i1)*, {  } }
    %var_20 = load { void (i1*, {  }, i1)*, {  } }, ptr %var_19
    %var_21 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_20, void (i1*, {  }, i1)* @"generated_print_i1", 0
    %var_22 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_21, {  } %var_10, 1
    store { void (i1*, {  }, i1)*, {  } } %var_22, ptr %var_19
    %var_24 = load i1, ptr @const_23
    %var_25 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_22, 0
    %var_26 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_22, 1
    %var_27 = alloca i1
    call void %var_25(i1* %var_27, {  } %var_26, i1 %var_24)
    %var_28 = load i1, ptr %var_27
    ret i32 0
}
define void @"generated_print_i1"(ptr sret(i1) %var_11, {  } %var_12, i1 %var_13) {
  entry14: 
    %var_17 = select i1 %var_13, [5 x i8]* @const_15, [5 x i8]* @const_16
    call void @printf(i8* @const_18, [5 x i8]* %var_17)
    store i1 %var_13, ptr %var_11
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`data structures compilation > boolean false > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_15 = constant [5 x i8] c"true\\00"
@const_16 = constant [6 x i8] c"false\\00"
@const_18 = constant [3 x i8] c"%s\\00"
@const_23 = local_unnamed_addr constant i1 false
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_18, ptr nonnull @const_16)
  ret i32 0
}

define void @generated_print_i1(ptr nocapture writeonly sret(i1) %var_11, {} %var_12, i1 %var_13) local_unnamed_addr {
entry14:
  %var_17 = select i1 %var_13, ptr @const_15, ptr @const_16
  tail call void @printf(ptr nonnull @const_18, ptr nonnull %var_17)
  store i1 %var_13, ptr %var_11, align 1
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`data structures compilation > boolean false > stderr 1`] = `[]`;

exports[`data structures compilation > boolean false > stdout 1`] = `
[
  "false",
]
`;

exports[`data structures compilation > boolean true > compiled 1`] = `
"@const_15 = constant [5 x i8] c"true\\00"
@const_16 = constant [6 x i8] c"false\\00"
@const_18 = constant [3 x i8] c"%s\\00"
@const_23 = constant i1 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_9 = alloca {  }
    %var_10 = load {  }, ptr %var_9
    store {  } %var_10, ptr %var_9
    %var_19 = alloca { void (i1*, {  }, i1)*, {  } }
    %var_20 = load { void (i1*, {  }, i1)*, {  } }, ptr %var_19
    %var_21 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_20, void (i1*, {  }, i1)* @"generated_print_i1", 0
    %var_22 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_21, {  } %var_10, 1
    store { void (i1*, {  }, i1)*, {  } } %var_22, ptr %var_19
    %var_24 = load i1, ptr @const_23
    %var_25 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_22, 0
    %var_26 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_22, 1
    %var_27 = alloca i1
    call void %var_25(i1* %var_27, {  } %var_26, i1 %var_24)
    %var_28 = load i1, ptr %var_27
    ret i32 0
}
define void @"generated_print_i1"(ptr sret(i1) %var_11, {  } %var_12, i1 %var_13) {
  entry14: 
    %var_17 = select i1 %var_13, [5 x i8]* @const_15, [5 x i8]* @const_16
    call void @printf(i8* @const_18, [5 x i8]* %var_17)
    store i1 %var_13, ptr %var_11
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`data structures compilation > boolean true > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_15 = constant [5 x i8] c"true\\00"
@const_16 = constant [6 x i8] c"false\\00"
@const_18 = constant [3 x i8] c"%s\\00"
@const_23 = local_unnamed_addr constant i1 true
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_18, ptr nonnull @const_15)
  ret i32 0
}

define void @generated_print_i1(ptr nocapture writeonly sret(i1) %var_11, {} %var_12, i1 %var_13) local_unnamed_addr {
entry14:
  %var_17 = select i1 %var_13, ptr @const_15, ptr @const_16
  tail call void @printf(ptr nonnull @const_18, ptr nonnull %var_17)
  store i1 %var_13, ptr %var_11, align 1
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`data structures compilation > boolean true > stderr 1`] = `[]`;

exports[`data structures compilation > boolean true > stdout 1`] = `
[
  "true",
]
`;

exports[`data structures compilation > symbol > compiled 1`] = `
"@const_33 = constant i64 0
@const_39 = constant [10 x i8] c"symbol_ab\\00"
@symbols_metadata_array = constant [1 x { i8* }] [{ i8* } { i8* @const_39 }]
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_9 = alloca {  }
    %var_10 = load {  }, ptr %var_9
    store {  } %var_10, ptr %var_9
    %var_29 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_30 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_29
    %var_31 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_30, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_32 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_31, {  } %var_10, 1
    store { void (i64*, {  }, i64)*, {  } } %var_32, ptr %var_29
    %var_34 = load i64, ptr @const_33
    %var_35 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_32, 0
    %var_36 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_32, 1
    %var_37 = alloca i64
    call void %var_35(i64* %var_37, {  } %var_36, i64 %var_34)
    %var_38 = load i64, ptr %var_37
    ret i32 0
}
define void @"generated_print_symbol"(ptr sret(i64) %var_11, {  } %var_12, i64 %var_13) {
  entry14: 
    %var_15 = alloca {  }
    %var_16 = load {  }, ptr %var_15
    store {  } %var_16, ptr %var_15
    %var_21 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_22 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_21
    %var_23 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_22, void (i64*, {  }, i64)* @print_symbol_wrap, 0
    %var_24 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_23, {  } %var_16, 1
    store { void (i64*, {  }, i64)*, {  } } %var_24, ptr %var_21
    %var_25 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_24, 0
    %var_26 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_24, 1
    %var_27 = alloca i64
    call void %var_25(i64* %var_27, {  } %var_26, i64 %var_13)
    %var_28 = load i64, ptr %var_27
    store i64 %var_13, ptr %var_11
    ret void
}
declare void @print_symbol(i64)
define void @print_symbol_wrap(ptr sret(i64) %var_17, {  } %var_18, i64 %var_19) {
  entry20: 
    call void @print_symbol(i64 %var_19)
    store i64 %var_19, ptr %var_17
    ret void
}
"
`;

exports[`data structures compilation > symbol > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_33 = local_unnamed_addr constant i64 0
@const_39 = constant [10 x i8] c"symbol_ab\\00"
@symbols_metadata_array = constant [1 x { ptr }] [{ ptr } { ptr @const_39 }]
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @print_symbol(i64 0)
  ret i32 0
}

define void @generated_print_symbol(ptr nocapture writeonly sret(i64) %var_11, {} %var_12, i64 %var_13) local_unnamed_addr {
entry14:
  tail call void @print_symbol(i64 %var_13)
  store i64 %var_13, ptr %var_11, align 8
  ret void
}

declare void @print_symbol(i64) local_unnamed_addr

define void @print_symbol_wrap(ptr nocapture writeonly sret(i64) %var_17, {} %var_18, i64 %var_19) local_unnamed_addr {
entry20:
  tail call void @print_symbol(i64 %var_19)
  store i64 %var_19, ptr %var_17, align 8
  ret void
}
"
`;

exports[`data structures compilation > symbol > stderr 1`] = `[]`;

exports[`data structures compilation > symbol > stdout 1`] = `
[
  "symbol(symbol_ab)",
]
`;

exports[`data structures compilation > tuple > compiled 1`] = `
"@const_18 = constant [7 x i8] c"tuple(\\00"
@const_19 = constant [3 x i8] c"%s\\00"
@const_27 = constant [3 x i8] c"%i\\00"
@const_36 = constant [3 x i8] c", \\00"
@const_52 = constant [2 x i8] c")\\00"
@const_57 = constant i32 1
@const_62 = constant [3 x i8] c"ab\\00"
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_12 = alloca {  }
    %var_13 = load {  }, ptr %var_12
    store {  } %var_13, ptr %var_12
    %var_53 = alloca { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } }
    %var_54 = load { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } }, ptr %var_53
    %var_55 = insertvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_54, void ({ i32, i8* }*, {  }, { i32, i8* })* @"generated_print_(i32, i8*)", 0
    %var_56 = insertvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_55, {  } %var_13, 1
    store { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_56, ptr %var_53
    %var_58 = load i32, ptr @const_57
    %var_59 = alloca { i32 }
    %var_60 = load { i32 }, ptr %var_59
    %var_61 = insertvalue { i32 } %var_60, i32 %var_58, 0
    store { i32 } %var_61, ptr %var_59
    %var_63 = extractvalue { i32 } %var_61, 0
    %var_64 = alloca { i32, [3 x i8]* }
    %var_65 = load { i32, [3 x i8]* }, ptr %var_64
    %var_66 = insertvalue { i32, [3 x i8]* } %var_65, i32 %var_63, 0
    %var_67 = insertvalue { i32, [3 x i8]* } %var_66, [3 x i8]* @const_62, 1
    store { i32, [3 x i8]* } %var_67, ptr %var_64
    %var_68 = extractvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_56, 0
    %var_69 = extractvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_56, 1
    %var_70 = alloca { i32, i8* }
    call void %var_68({ i32, i8* }* %var_70, {  } %var_69, { i32, i8* } %var_67)
    %var_71 = load { i32, i8* }, ptr %var_70
    ret i32 0
}
define void @"generated_print_(i32, i8*)"(ptr sret({ i32, i8* }) %var_14, {  } %var_15, { i32, i8* } %var_16) {
  entry17: 
    call void @printf(i8* @const_19, [7 x i8]* @const_18)
    %var_20 = extractvalue { i32, i8* } %var_16, 0
    %var_21 = alloca {  }
    %var_22 = load {  }, ptr %var_21
    store {  } %var_22, ptr %var_21
    %var_28 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_29 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_28
    %var_30 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_29, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_31 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_30, {  } %var_22, 1
    store { void (i32*, {  }, i32)*, {  } } %var_31, ptr %var_28
    %var_32 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_31, 0
    %var_33 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_31, 1
    %var_34 = alloca i32
    call void %var_32(i32* %var_34, {  } %var_33, i32 %var_20)
    %var_35 = load i32, ptr %var_34
    call void @printf(i8* @const_19, [3 x i8]* @const_36)
    %var_37 = extractvalue { i32, i8* } %var_16, 1
    %var_38 = alloca {  }
    %var_39 = load {  }, ptr %var_38
    store {  } %var_39, ptr %var_38
    %var_44 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_45 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_44
    %var_46 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_45, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_47 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_46, {  } %var_39, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_47, ptr %var_44
    %var_48 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_47, 0
    %var_49 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_47, 1
    %var_50 = alloca i8*
    call void %var_48(i8** %var_50, {  } %var_49, i8* %var_37)
    %var_51 = load i8*, ptr %var_50
    call void @printf(i8* @const_19, [2 x i8]* @const_52)
    store { i32, i8* } %var_16, ptr %var_14
    ret void
}
declare i32 @printf(i8*, ...)
define void @"generated_print_i32"(ptr sret(i32) %var_23, {  } %var_24, i32 %var_25) {
  entry26: 
    call void @printf(i8* @const_27, i32 %var_25)
    store i32 %var_25, ptr %var_23
    ret void
}
define void @"generated_print_i8*"(ptr sret(i8*) %var_40, {  } %var_41, i8* %var_42) {
  entry43: 
    call void @printf(i8* @const_19, i8* %var_42)
    store i8* %var_42, ptr %var_40
    ret void
}
"
`;

exports[`data structures compilation > tuple > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_18 = constant [7 x i8] c"tuple(\\00"
@const_19 = constant [3 x i8] c"%s\\00"
@const_27 = constant [3 x i8] c"%i\\00"
@const_36 = constant [3 x i8] c", \\00"
@const_52 = constant [2 x i8] c")\\00"
@const_57 = local_unnamed_addr constant i32 1
@const_62 = constant [3 x i8] c"ab\\00"
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_19, ptr nonnull @const_18)
  tail call void @printf(ptr nonnull @const_27, i32 1)
  tail call void @printf(ptr nonnull @const_19, ptr nonnull @const_36)
  tail call void @printf(ptr nonnull @const_19, ptr nonnull @const_62)
  tail call void @printf(ptr nonnull @const_19, ptr nonnull @const_52)
  ret i32 0
}

define void @"generated_print_(i32, i8*)"(ptr nocapture writeonly sret({ i32, ptr }) %var_14, {} %var_15, { i32, ptr } %var_16) local_unnamed_addr {
entry17:
  tail call void @printf(ptr nonnull @const_19, ptr nonnull @const_18)
  %var_20 = extractvalue { i32, ptr } %var_16, 0
  tail call void @printf(ptr nonnull @const_27, i32 %var_20)
  tail call void @printf(ptr nonnull @const_19, ptr nonnull @const_36)
  %var_37 = extractvalue { i32, ptr } %var_16, 1
  tail call void @printf(ptr nonnull @const_19, ptr %var_37)
  tail call void @printf(ptr nonnull @const_19, ptr nonnull @const_52)
  store { i32, ptr } %var_16, ptr %var_14, align 8
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_23, {} %var_24, i32 %var_25) local_unnamed_addr {
entry26:
  tail call void @printf(ptr nonnull @const_27, i32 %var_25)
  store i32 %var_25, ptr %var_23, align 4
  ret void
}

define void @"generated_print_i8*"(ptr nocapture writeonly sret(ptr) %var_40, {} %var_41, ptr %var_42) local_unnamed_addr {
entry43:
  tail call void @printf(ptr nonnull @const_19, ptr %var_42)
  store ptr %var_42, ptr %var_40, align 8
  ret void
}

attributes #0 = { nofree nounwind }
"
`;

exports[`data structures compilation > tuple > stderr 1`] = `[]`;

exports[`data structures compilation > tuple > stdout 1`] = `
[
  "tuple(1, ab)",
]
`;

exports[`data structures compilation > unit > compiled 1`] = `
"@const_33 = constant i64 0
@const_39 = constant [5 x i8] c"unit\\00"
@symbols_metadata_array = constant [1 x { i8* }] [{ i8* } { i8* @const_39 }]
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_9 = alloca {  }
    %var_10 = load {  }, ptr %var_9
    store {  } %var_10, ptr %var_9
    %var_29 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_30 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_29
    %var_31 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_30, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_32 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_31, {  } %var_10, 1
    store { void (i64*, {  }, i64)*, {  } } %var_32, ptr %var_29
    %var_34 = load i64, ptr @const_33
    %var_35 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_32, 0
    %var_36 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_32, 1
    %var_37 = alloca i64
    call void %var_35(i64* %var_37, {  } %var_36, i64 %var_34)
    %var_38 = load i64, ptr %var_37
    ret i32 0
}
define void @"generated_print_symbol"(ptr sret(i64) %var_11, {  } %var_12, i64 %var_13) {
  entry14: 
    %var_15 = alloca {  }
    %var_16 = load {  }, ptr %var_15
    store {  } %var_16, ptr %var_15
    %var_21 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_22 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_21
    %var_23 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_22, void (i64*, {  }, i64)* @print_symbol_wrap, 0
    %var_24 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_23, {  } %var_16, 1
    store { void (i64*, {  }, i64)*, {  } } %var_24, ptr %var_21
    %var_25 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_24, 0
    %var_26 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_24, 1
    %var_27 = alloca i64
    call void %var_25(i64* %var_27, {  } %var_26, i64 %var_13)
    %var_28 = load i64, ptr %var_27
    store i64 %var_13, ptr %var_11
    ret void
}
declare void @print_symbol(i64)
define void @print_symbol_wrap(ptr sret(i64) %var_17, {  } %var_18, i64 %var_19) {
  entry20: 
    call void @print_symbol(i64 %var_19)
    store i64 %var_19, ptr %var_17
    ret void
}
"
`;

exports[`data structures compilation > unit > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_33 = local_unnamed_addr constant i64 0
@const_39 = constant [5 x i8] c"unit\\00"
@symbols_metadata_array = constant [1 x { ptr }] [{ ptr } { ptr @const_39 }]
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @print_symbol(i64 0)
  ret i32 0
}

define void @generated_print_symbol(ptr nocapture writeonly sret(i64) %var_11, {} %var_12, i64 %var_13) local_unnamed_addr {
entry14:
  tail call void @print_symbol(i64 %var_13)
  store i64 %var_13, ptr %var_11, align 8
  ret void
}

declare void @print_symbol(i64) local_unnamed_addr

define void @print_symbol_wrap(ptr nocapture writeonly sret(i64) %var_17, {} %var_18, i64 %var_19) local_unnamed_addr {
entry20:
  tail call void @print_symbol(i64 %var_19)
  store i64 %var_19, ptr %var_17, align 8
  ret void
}
"
`;

exports[`data structures compilation > unit > stderr 1`] = `[]`;

exports[`data structures compilation > unit > stdout 1`] = `
[
  "symbol(unit)",
]
`;

exports[`generic print > compiled 1`] = `
"@const_96 = constant [4 x i8] c"fn[\\00"
@const_97 = constant [3 x i8] c"%s\\00"
@const_98 = constant [2 x i8] c"]\\00"
@const_128 = constant [2 x i8] c"
\\00"
@const_147 = constant [3 x i8] c"%i\\00"
@const_184 = constant i32 1
@const_247 = constant [7 x i8] c"tuple(\\00"
@const_259 = constant [3 x i8] c", \\00"
@const_271 = constant [2 x i8] c")\\00"
@const_280 = constant [3 x i8] c"ab\\00"
@const_327 = constant [3 x i8] c"%f\\00"
@const_332 = constant float 1.25
@const_374 = constant [5 x i8] c"true\\00"
@const_375 = constant [6 x i8] c"false\\00"
@const_381 = constant i1 1
@const_403 = constant i1 0
@const_443 = constant i64 0
@const_465 = constant i64 1
@const_487 = constant i64 2
@const_493 = constant [5 x i8] c"unit\\00"
@const_494 = constant [12 x i8] c"atom_atom_a\\00"
@const_495 = constant [16 x i8] c"symbol_symbol_a\\00"
@symbols_metadata_array = constant [3 x { i8* }] [{ i8* } { i8* @const_493 }, { i8* } { i8* @const_494 }, { i8* } { i8* @const_495 }]
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_89 = alloca {  }
    %var_90 = load {  }, ptr %var_89
    store {  } %var_90, ptr %var_89
    %var_99 = alloca { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } }
    %var_100 = load { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } }, ptr %var_99
    %var_101 = insertvalue { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_100, void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })* @"generated_print_i32[](i32)", 0
    %var_102 = insertvalue { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_101, {  } %var_90, 1
    store { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_102, ptr %var_99
    %var_104 = alloca {  }
    %var_105 = load {  }, ptr %var_104
    store {  } %var_105, ptr %var_104
    %var_110 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_111 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_110
    %var_112 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_111, void (i32*, {  }, i32)* @fn_103, 0
    %var_113 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_112, {  } %var_105, 1
    store { void (i32*, {  }, i32)*, {  } } %var_113, ptr %var_110
    %var_114 = extractvalue { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_102, 0
    %var_115 = extractvalue { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_102, 1
    %var_116 = alloca { void (i32*, {  }, i32)*, {  } }
    call void %var_114({ void (i32*, {  }, i32)*, {  } }* %var_116, {  } %var_115, { void (i32*, {  }, i32)*, {  } } %var_113)
    %var_117 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_116
    %var_118 = alloca {  }
    %var_119 = load {  }, ptr %var_118
    store {  } %var_119, ptr %var_118
    %var_124 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_125 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_124
    %var_126 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_125, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_127 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_126, {  } %var_119, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_127, ptr %var_124
    %var_129 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_127, 0
    %var_130 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_127, 1
    %var_131 = alloca i8*
    call void %var_129(i8** %var_131, {  } %var_130, i8* @const_128)
    %var_132 = load i8*, ptr %var_131
    %var_133 = alloca {  }
    %var_134 = load {  }, ptr %var_133
    store {  } %var_134, ptr %var_133
    %var_156 = alloca { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } }
    %var_157 = load { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } }, ptr %var_156
    %var_158 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } } %var_157, void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })* @"generated_print_i32[i32](i32)", 0
    %var_159 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } } %var_158, {  } %var_134, 1
    store { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } } %var_159, ptr %var_156
    %var_161 = alloca {  }
    %var_162 = load {  }, ptr %var_161
    store {  } %var_162, ptr %var_161
    %var_180 = alloca { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }
    %var_181 = load { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_180
    %var_182 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_181, void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)* @fn_160, 0
    %var_183 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_182, {  } %var_162, 1
    store { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_183, ptr %var_180
    %var_185 = load i32, ptr @const_184
    %var_186 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_183, 0
    %var_187 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_183, 1
    %var_188 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    call void %var_186({ void (i32*, { i32 }, i32)*, { i32 } }* %var_188, {  } %var_187, i32 %var_185)
    %var_189 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_188
    %var_190 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } } %var_159, 0
    %var_191 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } } %var_159, 1
    %var_192 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    call void %var_190({ void (i32*, { i32 }, i32)*, { i32 } }* %var_192, {  } %var_191, { void (i32*, { i32 }, i32)*, { i32 } } %var_189)
    %var_193 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_192
    %var_194 = alloca {  }
    %var_195 = load {  }, ptr %var_194
    store {  } %var_195, ptr %var_194
    %var_196 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_197 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_196
    %var_198 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_197, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_199 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_198, {  } %var_195, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_199, ptr %var_196
    %var_200 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_199, 0
    %var_201 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_199, 1
    %var_202 = alloca i8*
    call void %var_200(i8** %var_202, {  } %var_201, i8* @const_128)
    %var_203 = load i8*, ptr %var_202
    %var_204 = alloca {  }
    %var_205 = load {  }, ptr %var_204
    store {  } %var_205, ptr %var_204
    %var_211 = alloca { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } }
    %var_212 = load { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } }, ptr %var_211
    %var_213 = insertvalue { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_212, void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })* @"generated_print_i32[](i32, i32)", 0
    %var_214 = insertvalue { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_213, {  } %var_205, 1
    store { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_214, ptr %var_211
    %var_216 = alloca {  }
    %var_217 = load {  }, ptr %var_216
    store {  } %var_217, ptr %var_216
    %var_223 = alloca { void (i32*, {  }, i32, i32)*, {  } }
    %var_224 = load { void (i32*, {  }, i32, i32)*, {  } }, ptr %var_223
    %var_225 = insertvalue { void (i32*, {  }, i32, i32)*, {  } } %var_224, void (i32*, {  }, i32, i32)* @fn_215, 0
    %var_226 = insertvalue { void (i32*, {  }, i32, i32)*, {  } } %var_225, {  } %var_217, 1
    store { void (i32*, {  }, i32, i32)*, {  } } %var_226, ptr %var_223
    %var_227 = extractvalue { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_214, 0
    %var_228 = extractvalue { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_214, 1
    %var_229 = alloca { void (i32*, {  }, i32, i32)*, {  } }
    call void %var_227({ void (i32*, {  }, i32, i32)*, {  } }* %var_229, {  } %var_228, { void (i32*, {  }, i32, i32)*, {  } } %var_226)
    %var_230 = load { void (i32*, {  }, i32, i32)*, {  } }, ptr %var_229
    %var_231 = alloca {  }
    %var_232 = load {  }, ptr %var_231
    store {  } %var_232, ptr %var_231
    %var_233 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_234 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_233
    %var_235 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_234, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_236 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_235, {  } %var_232, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_236, ptr %var_233
    %var_237 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_236, 0
    %var_238 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_236, 1
    %var_239 = alloca i8*
    call void %var_237(i8** %var_239, {  } %var_238, i8* @const_128)
    %var_240 = load i8*, ptr %var_239
    %var_241 = alloca {  }
    %var_242 = load {  }, ptr %var_241
    store {  } %var_242, ptr %var_241
    %var_272 = alloca { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } }
    %var_273 = load { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } }, ptr %var_272
    %var_274 = insertvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_273, void ({ i32, i8* }*, {  }, { i32, i8* })* @"generated_print_(i32, i8*)", 0
    %var_275 = insertvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_274, {  } %var_242, 1
    store { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_275, ptr %var_272
    %var_276 = load i32, ptr @const_184
    %var_277 = alloca { i32 }
    %var_278 = load { i32 }, ptr %var_277
    %var_279 = insertvalue { i32 } %var_278, i32 %var_276, 0
    store { i32 } %var_279, ptr %var_277
    %var_281 = extractvalue { i32 } %var_279, 0
    %var_282 = alloca { i32, [3 x i8]* }
    %var_283 = load { i32, [3 x i8]* }, ptr %var_282
    %var_284 = insertvalue { i32, [3 x i8]* } %var_283, i32 %var_281, 0
    %var_285 = insertvalue { i32, [3 x i8]* } %var_284, [3 x i8]* @const_280, 1
    store { i32, [3 x i8]* } %var_285, ptr %var_282
    %var_286 = extractvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_275, 0
    %var_287 = extractvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_275, 1
    %var_288 = alloca { i32, i8* }
    call void %var_286({ i32, i8* }* %var_288, {  } %var_287, { i32, i8* } %var_285)
    %var_289 = load { i32, i8* }, ptr %var_288
    %var_290 = alloca {  }
    %var_291 = load {  }, ptr %var_290
    store {  } %var_291, ptr %var_290
    %var_292 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_293 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_292
    %var_294 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_293, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_295 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_294, {  } %var_291, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_295, ptr %var_292
    %var_296 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_295, 0
    %var_297 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_295, 1
    %var_298 = alloca i8*
    call void %var_296(i8** %var_298, {  } %var_297, i8* @const_128)
    %var_299 = load i8*, ptr %var_298
    %var_300 = alloca {  }
    %var_301 = load {  }, ptr %var_300
    store {  } %var_301, ptr %var_300
    %var_302 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_303 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_302
    %var_304 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_303, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_305 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_304, {  } %var_301, 1
    store { void (i32*, {  }, i32)*, {  } } %var_305, ptr %var_302
    %var_306 = load i32, ptr @const_184
    %var_307 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_305, 0
    %var_308 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_305, 1
    %var_309 = alloca i32
    call void %var_307(i32* %var_309, {  } %var_308, i32 %var_306)
    %var_310 = load i32, ptr %var_309
    %var_311 = alloca {  }
    %var_312 = load {  }, ptr %var_311
    store {  } %var_312, ptr %var_311
    %var_313 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_314 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_313
    %var_315 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_314, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_316 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_315, {  } %var_312, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_316, ptr %var_313
    %var_317 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_316, 0
    %var_318 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_316, 1
    %var_319 = alloca i8*
    call void %var_317(i8** %var_319, {  } %var_318, i8* @const_128)
    %var_320 = load i8*, ptr %var_319
    %var_321 = alloca {  }
    %var_322 = load {  }, ptr %var_321
    store {  } %var_322, ptr %var_321
    %var_328 = alloca { void (float*, {  }, float)*, {  } }
    %var_329 = load { void (float*, {  }, float)*, {  } }, ptr %var_328
    %var_330 = insertvalue { void (float*, {  }, float)*, {  } } %var_329, void (float*, {  }, float)* @"generated_print_f32", 0
    %var_331 = insertvalue { void (float*, {  }, float)*, {  } } %var_330, {  } %var_322, 1
    store { void (float*, {  }, float)*, {  } } %var_331, ptr %var_328
    %var_333 = load float, ptr @const_332
    %var_334 = extractvalue { void (float*, {  }, float)*, {  } } %var_331, 0
    %var_335 = extractvalue { void (float*, {  }, float)*, {  } } %var_331, 1
    %var_336 = alloca float
    call void %var_334(float* %var_336, {  } %var_335, float %var_333)
    %var_337 = load float, ptr %var_336
    %var_338 = alloca {  }
    %var_339 = load {  }, ptr %var_338
    store {  } %var_339, ptr %var_338
    %var_340 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_341 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_340
    %var_342 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_341, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_343 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_342, {  } %var_339, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_343, ptr %var_340
    %var_344 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_343, 0
    %var_345 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_343, 1
    %var_346 = alloca i8*
    call void %var_344(i8** %var_346, {  } %var_345, i8* @const_128)
    %var_347 = load i8*, ptr %var_346
    %var_348 = alloca {  }
    %var_349 = load {  }, ptr %var_348
    store {  } %var_349, ptr %var_348
    %var_350 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_351 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_350
    %var_352 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_351, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_353 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_352, {  } %var_349, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_353, ptr %var_350
    %var_354 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_353, 0
    %var_355 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_353, 1
    %var_356 = alloca i8*
    call void %var_354(i8** %var_356, {  } %var_355, i8* @const_280)
    %var_357 = load i8*, ptr %var_356
    %var_358 = alloca {  }
    %var_359 = load {  }, ptr %var_358
    store {  } %var_359, ptr %var_358
    %var_360 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_361 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_360
    %var_362 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_361, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_363 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_362, {  } %var_359, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_363, ptr %var_360
    %var_364 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_363, 0
    %var_365 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_363, 1
    %var_366 = alloca i8*
    call void %var_364(i8** %var_366, {  } %var_365, i8* @const_128)
    %var_367 = load i8*, ptr %var_366
    %var_368 = alloca {  }
    %var_369 = load {  }, ptr %var_368
    store {  } %var_369, ptr %var_368
    %var_377 = alloca { void (i1*, {  }, i1)*, {  } }
    %var_378 = load { void (i1*, {  }, i1)*, {  } }, ptr %var_377
    %var_379 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_378, void (i1*, {  }, i1)* @"generated_print_i1", 0
    %var_380 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_379, {  } %var_369, 1
    store { void (i1*, {  }, i1)*, {  } } %var_380, ptr %var_377
    %var_382 = load i1, ptr @const_381
    %var_383 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_380, 0
    %var_384 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_380, 1
    %var_385 = alloca i1
    call void %var_383(i1* %var_385, {  } %var_384, i1 %var_382)
    %var_386 = load i1, ptr %var_385
    %var_387 = alloca {  }
    %var_388 = load {  }, ptr %var_387
    store {  } %var_388, ptr %var_387
    %var_389 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_390 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_389
    %var_391 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_390, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_392 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_391, {  } %var_388, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_392, ptr %var_389
    %var_393 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_392, 0
    %var_394 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_392, 1
    %var_395 = alloca i8*
    call void %var_393(i8** %var_395, {  } %var_394, i8* @const_128)
    %var_396 = load i8*, ptr %var_395
    %var_397 = alloca {  }
    %var_398 = load {  }, ptr %var_397
    store {  } %var_398, ptr %var_397
    %var_399 = alloca { void (i1*, {  }, i1)*, {  } }
    %var_400 = load { void (i1*, {  }, i1)*, {  } }, ptr %var_399
    %var_401 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_400, void (i1*, {  }, i1)* @"generated_print_i1", 0
    %var_402 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_401, {  } %var_398, 1
    store { void (i1*, {  }, i1)*, {  } } %var_402, ptr %var_399
    %var_404 = load i1, ptr @const_403
    %var_405 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_402, 0
    %var_406 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_402, 1
    %var_407 = alloca i1
    call void %var_405(i1* %var_407, {  } %var_406, i1 %var_404)
    %var_408 = load i1, ptr %var_407
    %var_409 = alloca {  }
    %var_410 = load {  }, ptr %var_409
    store {  } %var_410, ptr %var_409
    %var_411 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_412 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_411
    %var_413 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_412, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_414 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_413, {  } %var_410, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_414, ptr %var_411
    %var_415 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_414, 0
    %var_416 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_414, 1
    %var_417 = alloca i8*
    call void %var_415(i8** %var_417, {  } %var_416, i8* @const_128)
    %var_418 = load i8*, ptr %var_417
    %var_419 = alloca {  }
    %var_420 = load {  }, ptr %var_419
    store {  } %var_420, ptr %var_419
    %var_439 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_440 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_439
    %var_441 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_440, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_442 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_441, {  } %var_420, 1
    store { void (i64*, {  }, i64)*, {  } } %var_442, ptr %var_439
    %var_444 = load i64, ptr @const_443
    %var_445 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_442, 0
    %var_446 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_442, 1
    %var_447 = alloca i64
    call void %var_445(i64* %var_447, {  } %var_446, i64 %var_444)
    %var_448 = load i64, ptr %var_447
    %var_449 = alloca {  }
    %var_450 = load {  }, ptr %var_449
    store {  } %var_450, ptr %var_449
    %var_451 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_452 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_451
    %var_453 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_452, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_454 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_453, {  } %var_450, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_454, ptr %var_451
    %var_455 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_454, 0
    %var_456 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_454, 1
    %var_457 = alloca i8*
    call void %var_455(i8** %var_457, {  } %var_456, i8* @const_128)
    %var_458 = load i8*, ptr %var_457
    %var_459 = alloca {  }
    %var_460 = load {  }, ptr %var_459
    store {  } %var_460, ptr %var_459
    %var_461 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_462 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_461
    %var_463 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_462, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_464 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_463, {  } %var_460, 1
    store { void (i64*, {  }, i64)*, {  } } %var_464, ptr %var_461
    %var_466 = load i64, ptr @const_465
    %var_467 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_464, 0
    %var_468 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_464, 1
    %var_469 = alloca i64
    call void %var_467(i64* %var_469, {  } %var_468, i64 %var_466)
    %var_470 = load i64, ptr %var_469
    %var_471 = alloca {  }
    %var_472 = load {  }, ptr %var_471
    store {  } %var_472, ptr %var_471
    %var_473 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_474 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_473
    %var_475 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_474, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_476 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_475, {  } %var_472, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_476, ptr %var_473
    %var_477 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_476, 0
    %var_478 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_476, 1
    %var_479 = alloca i8*
    call void %var_477(i8** %var_479, {  } %var_478, i8* @const_128)
    %var_480 = load i8*, ptr %var_479
    %var_481 = alloca {  }
    %var_482 = load {  }, ptr %var_481
    store {  } %var_482, ptr %var_481
    %var_483 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_484 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_483
    %var_485 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_484, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_486 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_485, {  } %var_482, 1
    store { void (i64*, {  }, i64)*, {  } } %var_486, ptr %var_483
    %var_488 = load i64, ptr @const_487
    %var_489 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_486, 0
    %var_490 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_486, 1
    %var_491 = alloca i64
    call void %var_489(i64* %var_491, {  } %var_490, i64 %var_488)
    %var_492 = load i64, ptr %var_491
    ret i32 0
}
define void @"generated_print_i32[](i32)"(ptr sret({ void (i32*, {  }, i32)*, {  } }) %var_91, {  } %var_92, { void (i32*, {  }, i32)*, {  } } %var_93) {
  entry94: 
    %var_95 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_93, 1
    call void @printf(i8* @const_97, [4 x i8]* @const_96)
    call void @printf(i8* @const_97, [2 x i8]* @const_98)
    store { void (i32*, {  }, i32)*, {  } } %var_93, ptr %var_91
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_103(ptr sret(i32) %var_106, {  } %var_107, i32 %var_108) {
  entry109: 
    store i32 %var_108, ptr %var_106
    ret void
}
define void @"generated_print_i8*"(ptr sret(i8*) %var_120, {  } %var_121, i8* %var_122) {
  entry123: 
    call void @printf(i8* @const_97, i8* %var_122)
    store i8* %var_122, ptr %var_120
    ret void
}
define void @"generated_print_i32[i32](i32)"(ptr sret({ void (i32*, { i32 }, i32)*, { i32 } }) %var_135, {  } %var_136, { void (i32*, { i32 }, i32)*, { i32 } } %var_137) {
  entry138: 
    %var_139 = extractvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_137, 1
    call void @printf(i8* @const_97, [4 x i8]* @const_96)
    %var_140 = extractvalue { i32 } %var_139, 0
    %var_141 = alloca {  }
    %var_142 = load {  }, ptr %var_141
    store {  } %var_142, ptr %var_141
    %var_148 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_149 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_148
    %var_150 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_149, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_151 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_150, {  } %var_142, 1
    store { void (i32*, {  }, i32)*, {  } } %var_151, ptr %var_148
    %var_152 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_151, 0
    %var_153 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_151, 1
    %var_154 = alloca i32
    call void %var_152(i32* %var_154, {  } %var_153, i32 %var_140)
    %var_155 = load i32, ptr %var_154
    call void @printf(i8* @const_97, [2 x i8]* @const_98)
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_137, ptr %var_135
    ret void
}
define void @"generated_print_i32"(ptr sret(i32) %var_143, {  } %var_144, i32 %var_145) {
  entry146: 
    call void @printf(i8* @const_147, i32 %var_145)
    store i32 %var_145, ptr %var_143
    ret void
}
define void @fn_160(ptr sret({ void (i32*, { i32 }, i32)*, { i32 } }) %var_163, {  } %var_164, i32 %var_165) {
  entry166: 
    %var_168 = alloca { i32 }
    %var_169 = load { i32 }, ptr %var_168
    %var_170 = insertvalue { i32 } %var_169, i32 %var_165, 0
    store { i32 } %var_170, ptr %var_168
    %var_176 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    %var_177 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_176
    %var_178 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_177, void (i32*, { i32 }, i32)* @fn_167, 0
    %var_179 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_178, { i32 } %var_170, 1
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_179, ptr %var_176
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_179, ptr %var_163
    ret void
}
define void @fn_167(ptr sret(i32) %var_171, { i32 } %var_172, i32 %var_173) {
  entry174: 
    %var_175 = extractvalue { i32 } %var_172, 0
    store i32 %var_175, ptr %var_171
    ret void
}
define void @"generated_print_i32[](i32, i32)"(ptr sret({ void (i32*, {  }, i32, i32)*, {  } }) %var_206, {  } %var_207, { void (i32*, {  }, i32, i32)*, {  } } %var_208) {
  entry209: 
    %var_210 = extractvalue { void (i32*, {  }, i32, i32)*, {  } } %var_208, 1
    call void @printf(i8* @const_97, [4 x i8]* @const_96)
    call void @printf(i8* @const_97, [2 x i8]* @const_98)
    store { void (i32*, {  }, i32, i32)*, {  } } %var_208, ptr %var_206
    ret void
}
define void @fn_215(ptr sret(i32) %var_218, {  } %var_219, i32 %var_220, i32 %var_221) {
  entry222: 
    store i32 %var_220, ptr %var_218
    ret void
}
define void @"generated_print_(i32, i8*)"(ptr sret({ i32, i8* }) %var_243, {  } %var_244, { i32, i8* } %var_245) {
  entry246: 
    call void @printf(i8* @const_97, [7 x i8]* @const_247)
    %var_248 = extractvalue { i32, i8* } %var_245, 0
    %var_249 = alloca {  }
    %var_250 = load {  }, ptr %var_249
    store {  } %var_250, ptr %var_249
    %var_251 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_252 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_251
    %var_253 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_252, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_254 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_253, {  } %var_250, 1
    store { void (i32*, {  }, i32)*, {  } } %var_254, ptr %var_251
    %var_255 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_254, 0
    %var_256 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_254, 1
    %var_257 = alloca i32
    call void %var_255(i32* %var_257, {  } %var_256, i32 %var_248)
    %var_258 = load i32, ptr %var_257
    call void @printf(i8* @const_97, [3 x i8]* @const_259)
    %var_260 = extractvalue { i32, i8* } %var_245, 1
    %var_261 = alloca {  }
    %var_262 = load {  }, ptr %var_261
    store {  } %var_262, ptr %var_261
    %var_263 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_264 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_263
    %var_265 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_264, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_266 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_265, {  } %var_262, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_266, ptr %var_263
    %var_267 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_266, 0
    %var_268 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_266, 1
    %var_269 = alloca i8*
    call void %var_267(i8** %var_269, {  } %var_268, i8* %var_260)
    %var_270 = load i8*, ptr %var_269
    call void @printf(i8* @const_97, [2 x i8]* @const_271)
    store { i32, i8* } %var_245, ptr %var_243
    ret void
}
define void @"generated_print_f32"(ptr sret(float) %var_323, {  } %var_324, float %var_325) {
  entry326: 
    call void @printf(i8* @const_327, float %var_325)
    store float %var_325, ptr %var_323
    ret void
}
define void @"generated_print_i1"(ptr sret(i1) %var_370, {  } %var_371, i1 %var_372) {
  entry373: 
    %var_376 = select i1 %var_372, [5 x i8]* @const_374, [5 x i8]* @const_375
    call void @printf(i8* @const_97, [5 x i8]* %var_376)
    store i1 %var_372, ptr %var_370
    ret void
}
define void @"generated_print_symbol"(ptr sret(i64) %var_421, {  } %var_422, i64 %var_423) {
  entry424: 
    %var_425 = alloca {  }
    %var_426 = load {  }, ptr %var_425
    store {  } %var_426, ptr %var_425
    %var_431 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_432 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_431
    %var_433 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_432, void (i64*, {  }, i64)* @print_symbol_wrap, 0
    %var_434 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_433, {  } %var_426, 1
    store { void (i64*, {  }, i64)*, {  } } %var_434, ptr %var_431
    %var_435 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_434, 0
    %var_436 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_434, 1
    %var_437 = alloca i64
    call void %var_435(i64* %var_437, {  } %var_436, i64 %var_423)
    %var_438 = load i64, ptr %var_437
    store i64 %var_423, ptr %var_421
    ret void
}
declare void @print_symbol(i64)
define void @print_symbol_wrap(ptr sret(i64) %var_427, {  } %var_428, i64 %var_429) {
  entry430: 
    call void @print_symbol(i64 %var_429)
    store i64 %var_429, ptr %var_427
    ret void
}
"
`;

exports[`generic print > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_96 = constant [4 x i8] c"fn[\\00"
@const_97 = constant [3 x i8] c"%s\\00"
@const_98 = constant [2 x i8] c"]\\00"
@const_128 = constant [2 x i8] c"\\0A\\00"
@const_147 = constant [3 x i8] c"%i\\00"
@const_184 = local_unnamed_addr constant i32 1
@const_247 = constant [7 x i8] c"tuple(\\00"
@const_259 = constant [3 x i8] c", \\00"
@const_271 = constant [2 x i8] c")\\00"
@const_280 = constant [3 x i8] c"ab\\00"
@const_327 = constant [3 x i8] c"%f\\00"
@const_332 = local_unnamed_addr constant float 1.250000e+00
@const_374 = constant [5 x i8] c"true\\00"
@const_375 = constant [6 x i8] c"false\\00"
@const_381 = local_unnamed_addr constant i1 true
@const_403 = local_unnamed_addr constant i1 false
@const_443 = local_unnamed_addr constant i64 0
@const_465 = local_unnamed_addr constant i64 1
@const_487 = local_unnamed_addr constant i64 2
@const_493 = constant [5 x i8] c"unit\\00"
@const_494 = constant [12 x i8] c"atom_atom_a\\00"
@const_495 = constant [16 x i8] c"symbol_symbol_a\\00"
@symbols_metadata_array = constant [3 x { ptr }] [{ ptr } { ptr @const_493 }, { ptr } { ptr @const_494 }, { ptr } { ptr @const_495 }]
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_97, ptr nonnull @const_96)
  tail call void @printf(ptr nonnull @const_97, ptr nonnull @const_98)
  tail call void @printf(ptr nonnull @const_97, ptr nonnull @const_128)
  tail call void @printf(ptr nonnull @const_97, ptr nonnull @const_96)
  tail call void @printf(ptr nonnull @const_147, i32 1)
  tail call void @printf(ptr nonnull @const_97, ptr nonnull @const_98)
  tail call void @printf(ptr nonnull @const_97, ptr nonnull @const_128)
  tail call void @printf(ptr nonnull @const_97, ptr nonnull @const_96)
  tail call void @printf(ptr nonnull @const_97, ptr nonnull @const_98)
  tail call void @printf(ptr nonnull @const_97, ptr nonnull @const_128)
  tail call void @printf(ptr nonnull @const_97, ptr nonnull @const_247)
  tail call void @printf(ptr nonnull @const_147, i32 1)
  tail call void @printf(ptr nonnull @const_97, ptr nonnull @const_259)
  tail call void @printf(ptr nonnull @const_97, ptr nonnull @const_280)
  tail call void @printf(ptr nonnull @const_97, ptr nonnull @const_271)
  tail call void @printf(ptr nonnull @const_97, ptr nonnull @const_128)
  tail call void @printf(ptr nonnull @const_147, i32 1)
  tail call void @printf(ptr nonnull @const_97, ptr nonnull @const_128)
  tail call void @printf(ptr nonnull @const_327, float 1.250000e+00)
  tail call void @printf(ptr nonnull @const_97, ptr nonnull @const_128)
  tail call void @printf(ptr nonnull @const_97, ptr nonnull @const_280)
  tail call void @printf(ptr nonnull @const_97, ptr nonnull @const_128)
  tail call void @printf(ptr nonnull @const_97, ptr nonnull @const_374)
  tail call void @printf(ptr nonnull @const_97, ptr nonnull @const_128)
  tail call void @printf(ptr nonnull @const_97, ptr nonnull @const_375)
  tail call void @printf(ptr nonnull @const_97, ptr nonnull @const_128)
  tail call void @print_symbol(i64 0)
  tail call void @printf(ptr nonnull @const_97, ptr nonnull @const_128)
  tail call void @print_symbol(i64 1)
  tail call void @printf(ptr nonnull @const_97, ptr nonnull @const_128)
  tail call void @print_symbol(i64 2)
  ret i32 0
}

define void @"generated_print_i32[](i32)"(ptr nocapture writeonly sret({ ptr, {} }) %var_91, {} %var_92, { ptr, {} } %var_93) local_unnamed_addr {
entry94:
  tail call void @printf(ptr nonnull @const_97, ptr nonnull @const_96)
  tail call void @printf(ptr nonnull @const_97, ptr nonnull @const_98)
  %var_93.elt = extractvalue { ptr, {} } %var_93, 0
  store ptr %var_93.elt, ptr %var_91, align 8
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_103(ptr nocapture writeonly sret(i32) %var_106, {} %var_107, i32 %var_108) local_unnamed_addr #1 {
entry109:
  store i32 %var_108, ptr %var_106, align 4
  ret void
}

define void @"generated_print_i8*"(ptr nocapture writeonly sret(ptr) %var_120, {} %var_121, ptr %var_122) local_unnamed_addr {
entry123:
  tail call void @printf(ptr nonnull @const_97, ptr %var_122)
  store ptr %var_122, ptr %var_120, align 8
  ret void
}

define void @"generated_print_i32[i32](i32)"(ptr nocapture writeonly sret({ ptr, { i32 } }) %var_135, {} %var_136, { ptr, { i32 } } %var_137) local_unnamed_addr {
entry138:
  %var_139 = extractvalue { ptr, { i32 } } %var_137, 1
  tail call void @printf(ptr nonnull @const_97, ptr nonnull @const_96)
  %var_140 = extractvalue { i32 } %var_139, 0
  tail call void @printf(ptr nonnull @const_147, i32 %var_140)
  tail call void @printf(ptr nonnull @const_97, ptr nonnull @const_98)
  store { ptr, { i32 } } %var_137, ptr %var_135, align 8
  ret void
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_143, {} %var_144, i32 %var_145) local_unnamed_addr {
entry146:
  tail call void @printf(ptr nonnull @const_147, i32 %var_145)
  store i32 %var_145, ptr %var_143, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_160(ptr nocapture writeonly sret({ ptr, { i32 } }) %var_163, {} %var_164, i32 %var_165) local_unnamed_addr #1 {
entry166:
  %var_170 = insertvalue { i32 } undef, i32 %var_165, 0
  %var_179 = insertvalue { ptr, { i32 } } { ptr @fn_167, { i32 } undef }, { i32 } %var_170, 1
  store { ptr, { i32 } } %var_179, ptr %var_163, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_167(ptr nocapture writeonly sret(i32) %var_171, { i32 } %var_172, i32 %var_173) #1 {
entry174:
  %var_175 = extractvalue { i32 } %var_172, 0
  store i32 %var_175, ptr %var_171, align 4
  ret void
}

define void @"generated_print_i32[](i32, i32)"(ptr nocapture writeonly sret({ ptr, {} }) %var_206, {} %var_207, { ptr, {} } %var_208) local_unnamed_addr {
entry209:
  tail call void @printf(ptr nonnull @const_97, ptr nonnull @const_96)
  tail call void @printf(ptr nonnull @const_97, ptr nonnull @const_98)
  %var_208.elt = extractvalue { ptr, {} } %var_208, 0
  store ptr %var_208.elt, ptr %var_206, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_215(ptr nocapture writeonly sret(i32) %var_218, {} %var_219, i32 %var_220, i32 %var_221) local_unnamed_addr #1 {
entry222:
  store i32 %var_220, ptr %var_218, align 4
  ret void
}

define void @"generated_print_(i32, i8*)"(ptr nocapture writeonly sret({ i32, ptr }) %var_243, {} %var_244, { i32, ptr } %var_245) local_unnamed_addr {
entry246:
  tail call void @printf(ptr nonnull @const_97, ptr nonnull @const_247)
  %var_248 = extractvalue { i32, ptr } %var_245, 0
  tail call void @printf(ptr nonnull @const_147, i32 %var_248)
  tail call void @printf(ptr nonnull @const_97, ptr nonnull @const_259)
  %var_260 = extractvalue { i32, ptr } %var_245, 1
  tail call void @printf(ptr nonnull @const_97, ptr %var_260)
  tail call void @printf(ptr nonnull @const_97, ptr nonnull @const_271)
  store { i32, ptr } %var_245, ptr %var_243, align 8
  ret void
}

define void @generated_print_f32(ptr nocapture writeonly sret(float) %var_323, {} %var_324, float %var_325) local_unnamed_addr {
entry326:
  tail call void @printf(ptr nonnull @const_327, float %var_325)
  store float %var_325, ptr %var_323, align 4
  ret void
}

define void @generated_print_i1(ptr nocapture writeonly sret(i1) %var_370, {} %var_371, i1 %var_372) local_unnamed_addr {
entry373:
  %var_376 = select i1 %var_372, ptr @const_374, ptr @const_375
  tail call void @printf(ptr nonnull @const_97, ptr nonnull %var_376)
  store i1 %var_372, ptr %var_370, align 1
  ret void
}

define void @generated_print_symbol(ptr nocapture writeonly sret(i64) %var_421, {} %var_422, i64 %var_423) local_unnamed_addr {
entry424:
  tail call void @print_symbol(i64 %var_423)
  store i64 %var_423, ptr %var_421, align 8
  ret void
}

declare void @print_symbol(i64) local_unnamed_addr

define void @print_symbol_wrap(ptr nocapture writeonly sret(i64) %var_427, {} %var_428, i64 %var_429) local_unnamed_addr {
entry430:
  tail call void @print_symbol(i64 %var_429)
  store i64 %var_429, ptr %var_427, align 8
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`generic print > stderr 1`] = `[]`;

exports[`generic print > stdout 1`] = `
[
  "fn[]
fn[1]
fn[]
tuple(1, ab)
1
0.000000
ab
true
false
symbol(unit)
symbol(atom_atom_a)
symbol(symbol_symbol_a)",
]
`;

exports[`simply typed lambda calc compilation > apply > compiled 1`] = `
"@const_27 = constant [3 x i8] c"%i\\00"
@const_75 = constant i32 2
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_21 = alloca {  }
    %var_22 = load {  }, ptr %var_21
    store {  } %var_22, ptr %var_21
    %var_28 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_29 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_28
    %var_30 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_29, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_31 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_30, {  } %var_22, 1
    store { void (i32*, {  }, i32)*, {  } } %var_31, ptr %var_28
    %var_33 = alloca {  }
    %var_34 = load {  }, ptr %var_33
    store {  } %var_34, ptr %var_33
    %var_56 = alloca { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } }
    %var_57 = load { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } }, ptr %var_56
    %var_58 = insertvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_57, void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })* @fn_32, 0
    %var_59 = insertvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_58, {  } %var_34, 1
    store { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_59, ptr %var_56
    %var_61 = alloca {  }
    %var_62 = load {  }, ptr %var_61
    store {  } %var_62, ptr %var_61
    %var_67 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_68 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_67
    %var_69 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_68, void (i32*, {  }, i32)* @fn_60, 0
    %var_70 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_69, {  } %var_62, 1
    store { void (i32*, {  }, i32)*, {  } } %var_70, ptr %var_67
    %var_71 = extractvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_59, 0
    %var_72 = extractvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_59, 1
    %var_73 = alloca { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }
    call void %var_71({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }* %var_73, {  } %var_72, { void (i32*, {  }, i32)*, {  } } %var_70)
    %var_74 = load { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }, ptr %var_73
    %var_76 = load i32, ptr @const_75
    %var_77 = extractvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_74, 0
    %var_78 = extractvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_74, 1
    %var_79 = alloca i32
    call void %var_77(i32* %var_79, { { void (i32*, {  }, i32)*, {  } } } %var_78, i32 %var_76)
    %var_80 = load i32, ptr %var_79
    %var_81 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_31, 0
    %var_82 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_31, 1
    %var_83 = alloca i32
    call void %var_81(i32* %var_83, {  } %var_82, i32 %var_80)
    %var_84 = load i32, ptr %var_83
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %var_23, {  } %var_24, i32 %var_25) {
  entry26: 
    call void @printf(i8* @const_27, i32 %var_25)
    store i32 %var_25, ptr %var_23
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_32(ptr sret({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }) %var_35, {  } %var_36, { void (i32*, {  }, i32)*, {  } } %var_37) {
  entry38: 
    %var_40 = alloca { { void (i32*, {  }, i32)*, {  } } }
    %var_41 = load { { void (i32*, {  }, i32)*, {  } } }, ptr %var_40
    %var_42 = insertvalue { { void (i32*, {  }, i32)*, {  } } } %var_41, { void (i32*, {  }, i32)*, {  } } %var_37, 0
    store { { void (i32*, {  }, i32)*, {  } } } %var_42, ptr %var_40
    %var_52 = alloca { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }
    %var_53 = load { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }, ptr %var_52
    %var_54 = insertvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_53, void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)* @fn_39, 0
    %var_55 = insertvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_54, { { void (i32*, {  }, i32)*, {  } } } %var_42, 1
    store { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_55, ptr %var_52
    store { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_55, ptr %var_35
    ret void
}
define void @fn_39(ptr sret(i32) %var_43, { { void (i32*, {  }, i32)*, {  } } } %var_44, i32 %var_45) {
  entry46: 
    %var_47 = extractvalue { { void (i32*, {  }, i32)*, {  } } } %var_44, 0
    %var_48 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_47, 0
    %var_49 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_47, 1
    %var_50 = alloca i32
    call void %var_48(i32* %var_50, {  } %var_49, i32 %var_45)
    %var_51 = load i32, ptr %var_50
    store i32 %var_51, ptr %var_43
    ret void
}
define void @fn_60(ptr sret(i32) %var_63, {  } %var_64, i32 %var_65) {
  entry66: 
    store i32 %var_65, ptr %var_63
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > apply > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_27 = constant [3 x i8] c"%i\\00"
@const_75 = local_unnamed_addr constant i32 2
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_27, i32 2)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_23, {} %var_24, i32 %var_25) local_unnamed_addr {
entry26:
  tail call void @printf(ptr nonnull @const_27, i32 %var_25)
  store i32 %var_25, ptr %var_23, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_32(ptr nocapture writeonly sret({ ptr, { { ptr, {} } } }) %var_35, {} %var_36, { ptr, {} } %var_37) local_unnamed_addr #1 {
entry38:
  store ptr @fn_39, ptr %var_35, align 8
  %var_35.repack1 = getelementptr inbounds { ptr, { { ptr, {} } } }, ptr %var_35, i64 0, i32 1
  %var_37.elt = extractvalue { ptr, {} } %var_37, 0
  store ptr %var_37.elt, ptr %var_35.repack1, align 8
  ret void
}

define void @fn_39(ptr nocapture writeonly sret(i32) %var_43, { { ptr, {} } } %var_44, i32 %var_45) {
entry46:
  %var_47 = extractvalue { { ptr, {} } } %var_44, 0
  %var_48 = extractvalue { ptr, {} } %var_47, 0
  %var_50 = alloca i32, align 4
  call void %var_48(ptr nonnull %var_50, {} zeroinitializer, i32 %var_45)
  %var_51 = load i32, ptr %var_50, align 4
  store i32 %var_51, ptr %var_43, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_60(ptr nocapture writeonly sret(i32) %var_63, {} %var_64, i32 %var_65) local_unnamed_addr #1 {
entry66:
  store i32 %var_65, ptr %var_63, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > apply > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > apply > stdout 1`] = `
[
  "2",
]
`;

exports[`simply typed lambda calc compilation > church tuple > compiled 1`] = `
"@const_35 = constant [3 x i8] c"%i\\00"
@const_87 = constant i32 1
@const_93 = constant i32 2
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_29 = alloca {  }
    %var_30 = load {  }, ptr %var_29
    store {  } %var_30, ptr %var_29
    %var_36 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_37 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_36
    %var_38 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_37, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_39 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_38, {  } %var_30, 1
    store { void (i32*, {  }, i32)*, {  } } %var_39, ptr %var_36
    %var_41 = alloca {  }
    %var_42 = load {  }, ptr %var_41
    store {  } %var_42, ptr %var_41
    %var_83 = alloca { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }
    %var_84 = load { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_83
    %var_85 = insertvalue { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_84, void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)* @fn_40, 0
    %var_86 = insertvalue { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_85, {  } %var_42, 1
    store { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_86, ptr %var_83
    %var_88 = load i32, ptr @const_87
    %var_89 = extractvalue { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_86, 0
    %var_90 = extractvalue { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_86, 1
    %var_91 = alloca { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }
    call void %var_89({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }* %var_91, {  } %var_90, i32 %var_88)
    %var_92 = load { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }, ptr %var_91
    %var_94 = load i32, ptr @const_93
    %var_95 = extractvalue { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_92, 0
    %var_96 = extractvalue { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_92, 1
    %var_97 = alloca { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }
    call void %var_95({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }* %var_97, { i32 } %var_96, i32 %var_94)
    %var_98 = load { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }, ptr %var_97
    %var_100 = alloca {  }
    %var_101 = load {  }, ptr %var_100
    store {  } %var_101, ptr %var_100
    %var_119 = alloca { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }
    %var_120 = load { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_119
    %var_121 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_120, void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)* @fn_99, 0
    %var_122 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_121, {  } %var_101, 1
    store { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_122, ptr %var_119
    %var_123 = extractvalue { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_98, 0
    %var_124 = extractvalue { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_98, 1
    %var_125 = alloca i32
    call void %var_123(i32* %var_125, { i32, i32 } %var_124, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_122)
    %var_126 = load i32, ptr %var_125
    %var_127 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_39, 0
    %var_128 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_39, 1
    %var_129 = alloca i32
    call void %var_127(i32* %var_129, {  } %var_128, i32 %var_126)
    %var_130 = load i32, ptr %var_129
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %var_31, {  } %var_32, i32 %var_33) {
  entry34: 
    call void @printf(i8* @const_35, i32 %var_33)
    store i32 %var_33, ptr %var_31
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_40(ptr sret({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }) %var_43, {  } %var_44, i32 %var_45) {
  entry46: 
    %var_48 = alloca { i32 }
    %var_49 = load { i32 }, ptr %var_48
    %var_50 = insertvalue { i32 } %var_49, i32 %var_45, 0
    store { i32 } %var_50, ptr %var_48
    %var_79 = alloca { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }
    %var_80 = load { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }, ptr %var_79
    %var_81 = insertvalue { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_80, void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)* @fn_47, 0
    %var_82 = insertvalue { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_81, { i32 } %var_50, 1
    store { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_82, ptr %var_79
    store { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_82, ptr %var_43
    ret void
}
define void @fn_47(ptr sret({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }) %var_51, { i32 } %var_52, i32 %var_53) {
  entry54: 
    %var_55 = extractvalue { i32 } %var_52, 0
    %var_57 = alloca { i32, i32 }
    %var_58 = load { i32, i32 }, ptr %var_57
    %var_59 = insertvalue { i32, i32 } %var_58, i32 %var_55, 0
    %var_60 = insertvalue { i32, i32 } %var_59, i32 %var_53, 1
    store { i32, i32 } %var_60, ptr %var_57
    %var_75 = alloca { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }
    %var_76 = load { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }, ptr %var_75
    %var_77 = insertvalue { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_76, void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })* @fn_56, 0
    %var_78 = insertvalue { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_77, { i32, i32 } %var_60, 1
    store { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_78, ptr %var_75
    store { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_78, ptr %var_51
    ret void
}
define void @fn_56(ptr sret(i32) %var_61, { i32, i32 } %var_62, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_63) {
  entry64: 
    %var_65 = extractvalue { i32, i32 } %var_62, 0
    %var_66 = extractvalue { i32, i32 } %var_62, 1
    %var_67 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_63, 0
    %var_68 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_63, 1
    %var_69 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    call void %var_67({ void (i32*, { i32 }, i32)*, { i32 } }* %var_69, {  } %var_68, i32 %var_65)
    %var_70 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_69
    %var_71 = extractvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_70, 0
    %var_72 = extractvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_70, 1
    %var_73 = alloca i32
    call void %var_71(i32* %var_73, { i32 } %var_72, i32 %var_66)
    %var_74 = load i32, ptr %var_73
    store i32 %var_74, ptr %var_61
    ret void
}
define void @fn_99(ptr sret({ void (i32*, { i32 }, i32)*, { i32 } }) %var_102, {  } %var_103, i32 %var_104) {
  entry105: 
    %var_107 = alloca { i32 }
    %var_108 = load { i32 }, ptr %var_107
    %var_109 = insertvalue { i32 } %var_108, i32 %var_104, 0
    store { i32 } %var_109, ptr %var_107
    %var_115 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    %var_116 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_115
    %var_117 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_116, void (i32*, { i32 }, i32)* @fn_106, 0
    %var_118 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_117, { i32 } %var_109, 1
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_118, ptr %var_115
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_118, ptr %var_102
    ret void
}
define void @fn_106(ptr sret(i32) %var_110, { i32 } %var_111, i32 %var_112) {
  entry113: 
    %var_114 = extractvalue { i32 } %var_111, 0
    store i32 %var_114, ptr %var_110
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > church tuple > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_35 = constant [3 x i8] c"%i\\00"
@const_87 = local_unnamed_addr constant i32 1
@const_93 = local_unnamed_addr constant i32 2
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_35, i32 1)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_31, {} %var_32, i32 %var_33) local_unnamed_addr {
entry34:
  tail call void @printf(ptr nonnull @const_35, i32 %var_33)
  store i32 %var_33, ptr %var_31, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_40(ptr nocapture writeonly sret({ ptr, { i32 } }) %var_43, {} %var_44, i32 %var_45) local_unnamed_addr #1 {
entry46:
  %var_50 = insertvalue { i32 } undef, i32 %var_45, 0
  %var_82 = insertvalue { ptr, { i32 } } { ptr @fn_47, { i32 } undef }, { i32 } %var_50, 1
  store { ptr, { i32 } } %var_82, ptr %var_43, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_47(ptr nocapture writeonly sret({ ptr, { i32, i32 } }) %var_51, { i32 } %var_52, i32 %var_53) #1 {
entry54:
  %var_55 = extractvalue { i32 } %var_52, 0
  store ptr @fn_56, ptr %var_51, align 8
  %var_51.repack1 = getelementptr inbounds { ptr, { i32, i32 } }, ptr %var_51, i64 0, i32 1
  store i32 %var_55, ptr %var_51.repack1, align 8
  %var_51.repack1.repack3 = getelementptr inbounds { ptr, { i32, i32 } }, ptr %var_51, i64 0, i32 1, i32 1
  store i32 %var_53, ptr %var_51.repack1.repack3, align 4
  ret void
}

define void @fn_56(ptr nocapture writeonly sret(i32) %var_61, { i32, i32 } %var_62, { ptr, {} } %var_63) {
entry64:
  %var_65 = extractvalue { i32, i32 } %var_62, 0
  %var_66 = extractvalue { i32, i32 } %var_62, 1
  %var_67 = extractvalue { ptr, {} } %var_63, 0
  %var_69 = alloca { ptr, { i32 } }, align 8
  call void %var_67(ptr nonnull %var_69, {} zeroinitializer, i32 %var_65)
  %var_70.fca.0.load = load ptr, ptr %var_69, align 8
  %var_70.fca.1.0.gep = getelementptr inbounds { ptr, { i32 } }, ptr %var_69, i64 0, i32 1, i32 0
  %var_70.fca.1.0.load = load i32, ptr %var_70.fca.1.0.gep, align 8
  %var_72 = insertvalue { i32 } poison, i32 %var_70.fca.1.0.load, 0
  %var_73 = alloca i32, align 4
  call void %var_70.fca.0.load(ptr nonnull %var_73, { i32 } %var_72, i32 %var_66)
  %var_74 = load i32, ptr %var_73, align 4
  store i32 %var_74, ptr %var_61, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_99(ptr nocapture writeonly sret({ ptr, { i32 } }) %var_102, {} %var_103, i32 %var_104) local_unnamed_addr #1 {
entry105:
  %var_109 = insertvalue { i32 } undef, i32 %var_104, 0
  %var_118 = insertvalue { ptr, { i32 } } { ptr @fn_106, { i32 } undef }, { i32 } %var_109, 1
  store { ptr, { i32 } } %var_118, ptr %var_102, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_106(ptr nocapture writeonly sret(i32) %var_110, { i32 } %var_111, i32 %var_112) #1 {
entry113:
  %var_114 = extractvalue { i32 } %var_111, 0
  store i32 %var_114, ptr %var_110, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > church tuple > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > church tuple > stdout 1`] = `
[
  "1",
]
`;

exports[`simply typed lambda calc compilation > church tuple 2 > compiled 1`] = `
"@const_28 = constant [3 x i8] c"%i\\00"
@const_50 = constant i32 1
@const_52 = constant i32 2
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_22 = alloca {  }
    %var_23 = load {  }, ptr %var_22
    store {  } %var_23, ptr %var_22
    %var_29 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_30 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_29
    %var_31 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_30, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_32 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_31, {  } %var_23, 1
    store { void (i32*, {  }, i32)*, {  } } %var_32, ptr %var_29
    %var_34 = alloca {  }
    %var_35 = load {  }, ptr %var_34
    store {  } %var_35, ptr %var_34
    %var_46 = alloca { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } }
    %var_47 = load { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } }, ptr %var_46
    %var_48 = insertvalue { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_47, void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })* @fn_33, 0
    %var_49 = insertvalue { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_48, {  } %var_35, 1
    store { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_49, ptr %var_46
    %var_51 = load i32, ptr @const_50
    %var_53 = load i32, ptr @const_52
    %var_55 = alloca {  }
    %var_56 = load {  }, ptr %var_55
    store {  } %var_56, ptr %var_55
    %var_61 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_62 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_61
    %var_63 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_62, void (i32*, {  }, i32)* @fn_54, 0
    %var_64 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_63, {  } %var_56, 1
    store { void (i32*, {  }, i32)*, {  } } %var_64, ptr %var_61
    %var_65 = extractvalue { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_49, 0
    %var_66 = extractvalue { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_49, 1
    %var_67 = alloca i32
    call void %var_65(i32* %var_67, {  } %var_66, i32 %var_51, i32 %var_53, { void (i32*, {  }, i32, i32)*, {  } } %var_64)
    %var_68 = load i32, ptr %var_67
    %var_69 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_32, 0
    %var_70 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_32, 1
    %var_71 = alloca i32
    call void %var_69(i32* %var_71, {  } %var_70, i32 %var_68)
    %var_72 = load i32, ptr %var_71
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %var_24, {  } %var_25, i32 %var_26) {
  entry27: 
    call void @printf(i8* @const_28, i32 %var_26)
    store i32 %var_26, ptr %var_24
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_33(ptr sret(i32) %var_36, {  } %var_37, i32 %var_38, i32 %var_39, { void (i32*, {  }, i32, i32)*, {  } } %var_40) {
  entry41: 
    %var_42 = extractvalue { void (i32*, {  }, i32, i32)*, {  } } %var_40, 0
    %var_43 = extractvalue { void (i32*, {  }, i32, i32)*, {  } } %var_40, 1
    %var_44 = alloca i32
    call void %var_42(i32* %var_44, {  } %var_43, i32 %var_38, i32 %var_39)
    %var_45 = load i32, ptr %var_44
    store i32 %var_45, ptr %var_36
    ret void
}
define void @fn_54(ptr sret(i32) %var_57, {  } %var_58, i32 %var_59) {
  entry60: 
    store i32 %var_59, ptr %var_57
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > church tuple 2 > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_28 = constant [3 x i8] c"%i\\00"
@const_50 = local_unnamed_addr constant i32 1
@const_52 = local_unnamed_addr constant i32 2
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_28, i32 1)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_24, {} %var_25, i32 %var_26) local_unnamed_addr {
entry27:
  tail call void @printf(ptr nonnull @const_28, i32 %var_26)
  store i32 %var_26, ptr %var_24, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

define void @fn_33(ptr nocapture writeonly sret(i32) %var_36, {} %var_37, i32 %var_38, i32 %var_39, { ptr, {} } %var_40) local_unnamed_addr {
entry41:
  %var_42 = extractvalue { ptr, {} } %var_40, 0
  %var_44 = alloca i32, align 4
  call void %var_42(ptr nonnull %var_44, {} zeroinitializer, i32 %var_38, i32 %var_39)
  %var_45 = load i32, ptr %var_44, align 4
  store i32 %var_45, ptr %var_36, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_54(ptr nocapture writeonly sret(i32) %var_57, {} %var_58, i32 %var_59) local_unnamed_addr #1 {
entry60:
  store i32 %var_59, ptr %var_57, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > church tuple 2 > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > church tuple 2 > stdout 1`] = `
[
  "1",
]
`;

exports[`simply typed lambda calc compilation > either > compiled 1`] = `
"@const_33 = constant [3 x i8] c"%i\\00"
@const_81 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_27 = alloca {  }
    %var_28 = load {  }, ptr %var_27
    store {  } %var_28, ptr %var_27
    %var_34 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_35 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_34
    %var_36 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_35, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_37 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_36, {  } %var_28, 1
    store { void (i32*, {  }, i32)*, {  } } %var_37, ptr %var_34
    %var_39 = alloca {  }
    %var_40 = load {  }, ptr %var_39
    store {  } %var_40, ptr %var_39
    %var_77 = alloca { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } }
    %var_78 = load { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_77
    %var_79 = insertvalue { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } } %var_78, void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)* @fn_38, 0
    %var_80 = insertvalue { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } } %var_79, {  } %var_40, 1
    store { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } } %var_80, ptr %var_77
    %var_82 = load i32, ptr @const_81
    %var_83 = extractvalue { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } } %var_80, 0
    %var_84 = extractvalue { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } } %var_80, 1
    %var_85 = alloca { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }
    call void %var_83({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }* %var_85, {  } %var_84, i32 %var_82)
    %var_86 = load { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }, ptr %var_85
    %var_88 = alloca {  }
    %var_89 = load {  }, ptr %var_88
    store {  } %var_89, ptr %var_88
    %var_94 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_95 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_94
    %var_96 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_95, void (i32*, {  }, i32)* @fn_87, 0
    %var_97 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_96, {  } %var_89, 1
    store { void (i32*, {  }, i32)*, {  } } %var_97, ptr %var_94
    %var_98 = extractvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_86, 0
    %var_99 = extractvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_86, 1
    %var_100 = alloca { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }
    call void %var_98({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }* %var_100, { i32 } %var_99, { void (i32*, {  }, i32)*, {  } } %var_97)
    %var_101 = load { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }, ptr %var_100
    %var_103 = alloca {  }
    %var_104 = load {  }, ptr %var_103
    store {  } %var_104, ptr %var_103
    %var_109 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_110 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_109
    %var_111 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_110, void (i32*, {  }, i32)* @fn_102, 0
    %var_112 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_111, {  } %var_104, 1
    store { void (i32*, {  }, i32)*, {  } } %var_112, ptr %var_109
    %var_113 = extractvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_101, 0
    %var_114 = extractvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_101, 1
    %var_115 = alloca i32
    call void %var_113(i32* %var_115, { { void (i32*, {  }, i32)*, {  } }, i32 } %var_114, { void (i32*, {  }, i32)*, {  } } %var_112)
    %var_116 = load i32, ptr %var_115
    %var_117 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_37, 0
    %var_118 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_37, 1
    %var_119 = alloca i32
    call void %var_117(i32* %var_119, {  } %var_118, i32 %var_116)
    %var_120 = load i32, ptr %var_119
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %var_29, {  } %var_30, i32 %var_31) {
  entry32: 
    call void @printf(i8* @const_33, i32 %var_31)
    store i32 %var_31, ptr %var_29
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_38(ptr sret({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }) %var_41, {  } %var_42, i32 %var_43) {
  entry44: 
    %var_46 = alloca { i32 }
    %var_47 = load { i32 }, ptr %var_46
    %var_48 = insertvalue { i32 } %var_47, i32 %var_43, 0
    store { i32 } %var_48, ptr %var_46
    %var_73 = alloca { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }
    %var_74 = load { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }, ptr %var_73
    %var_75 = insertvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_74, void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })* @fn_45, 0
    %var_76 = insertvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_75, { i32 } %var_48, 1
    store { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_76, ptr %var_73
    store { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_76, ptr %var_41
    ret void
}
define void @fn_45(ptr sret({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }) %var_49, { i32 } %var_50, { void (i32*, {  }, i32)*, {  } } %var_51) {
  entry52: 
    %var_53 = extractvalue { i32 } %var_50, 0
    %var_55 = alloca { { void (i32*, {  }, i32)*, {  } }, i32 }
    %var_56 = load { { void (i32*, {  }, i32)*, {  } }, i32 }, ptr %var_55
    %var_57 = insertvalue { { void (i32*, {  }, i32)*, {  } }, i32 } %var_56, { void (i32*, {  }, i32)*, {  } } %var_51, 0
    %var_58 = insertvalue { { void (i32*, {  }, i32)*, {  } }, i32 } %var_57, i32 %var_53, 1
    store { { void (i32*, {  }, i32)*, {  } }, i32 } %var_58, ptr %var_55
    %var_69 = alloca { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }
    %var_70 = load { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }, ptr %var_69
    %var_71 = insertvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_70, void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })* @fn_54, 0
    %var_72 = insertvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_71, { { void (i32*, {  }, i32)*, {  } }, i32 } %var_58, 1
    store { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_72, ptr %var_69
    store { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_72, ptr %var_49
    ret void
}
define void @fn_54(ptr sret(i32) %var_59, { { void (i32*, {  }, i32)*, {  } }, i32 } %var_60, { void (i32*, {  }, i32)*, {  } } %var_61) {
  entry62: 
    %var_63 = extractvalue { { void (i32*, {  }, i32)*, {  } }, i32 } %var_60, 0
    %var_64 = extractvalue { { void (i32*, {  }, i32)*, {  } }, i32 } %var_60, 1
    %var_65 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_63, 0
    %var_66 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_63, 1
    %var_67 = alloca i32
    call void %var_65(i32* %var_67, {  } %var_66, i32 %var_64)
    %var_68 = load i32, ptr %var_67
    store i32 %var_68, ptr %var_59
    ret void
}
define void @fn_87(ptr sret(i32) %var_90, {  } %var_91, i32 %var_92) {
  entry93: 
    store i32 %var_92, ptr %var_90
    ret void
}
define void @fn_102(ptr sret(i32) %var_105, {  } %var_106, i32 %var_107) {
  entry108: 
    store i32 %var_107, ptr %var_105
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > either > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_33 = constant [3 x i8] c"%i\\00"
@const_81 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_33, i32 1)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_29, {} %var_30, i32 %var_31) local_unnamed_addr {
entry32:
  tail call void @printf(ptr nonnull @const_33, i32 %var_31)
  store i32 %var_31, ptr %var_29, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_38(ptr nocapture writeonly sret({ ptr, { i32 } }) %var_41, {} %var_42, i32 %var_43) local_unnamed_addr #1 {
entry44:
  %var_48 = insertvalue { i32 } undef, i32 %var_43, 0
  %var_76 = insertvalue { ptr, { i32 } } { ptr @fn_45, { i32 } undef }, { i32 } %var_48, 1
  store { ptr, { i32 } } %var_76, ptr %var_41, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_45(ptr nocapture writeonly sret({ ptr, { { ptr, {} }, i32 } }) %var_49, { i32 } %var_50, { ptr, {} } %var_51) #1 {
entry52:
  %var_53 = extractvalue { i32 } %var_50, 0
  %var_57 = insertvalue { { ptr, {} }, i32 } { { ptr, {} } { ptr undef, {} poison }, i32 undef }, { ptr, {} } %var_51, 0
  %var_58 = insertvalue { { ptr, {} }, i32 } %var_57, i32 %var_53, 1
  store ptr @fn_54, ptr %var_49, align 8
  %var_49.repack1 = getelementptr inbounds { ptr, { { ptr, {} }, i32 } }, ptr %var_49, i64 0, i32 1
  store { { ptr, {} }, i32 } %var_58, ptr %var_49.repack1, align 8
  ret void
}

define void @fn_54(ptr nocapture writeonly sret(i32) %var_59, { { ptr, {} }, i32 } %var_60, { ptr, {} } %var_61) {
entry62:
  %var_63 = extractvalue { { ptr, {} }, i32 } %var_60, 0
  %var_64 = extractvalue { { ptr, {} }, i32 } %var_60, 1
  %var_65 = extractvalue { ptr, {} } %var_63, 0
  %var_67 = alloca i32, align 4
  call void %var_65(ptr nonnull %var_67, {} zeroinitializer, i32 %var_64)
  %var_68 = load i32, ptr %var_67, align 4
  store i32 %var_68, ptr %var_59, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_87(ptr nocapture writeonly sret(i32) %var_90, {} %var_91, i32 %var_92) local_unnamed_addr #1 {
entry93:
  store i32 %var_92, ptr %var_90, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_102(ptr nocapture writeonly sret(i32) %var_105, {} %var_106, i32 %var_107) local_unnamed_addr #1 {
entry108:
  store i32 %var_107, ptr %var_105, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > either > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > either > stdout 1`] = `
[
  "1",
]
`;

exports[`simply typed lambda calc compilation > either 2 > compiled 1`] = `
"@const_29 = constant [3 x i8] c"%i\\00"
@const_51 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_23 = alloca {  }
    %var_24 = load {  }, ptr %var_23
    store {  } %var_24, ptr %var_23
    %var_30 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_31 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_30
    %var_32 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_31, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_33 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_32, {  } %var_24, 1
    store { void (i32*, {  }, i32)*, {  } } %var_33, ptr %var_30
    %var_35 = alloca {  }
    %var_36 = load {  }, ptr %var_35
    store {  } %var_36, ptr %var_35
    %var_47 = alloca { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } }
    %var_48 = load { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } }, ptr %var_47
    %var_49 = insertvalue { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_48, void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })* @fn_34, 0
    %var_50 = insertvalue { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_49, {  } %var_36, 1
    store { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_50, ptr %var_47
    %var_52 = load i32, ptr @const_51
    %var_54 = alloca {  }
    %var_55 = load {  }, ptr %var_54
    store {  } %var_55, ptr %var_54
    %var_60 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_61 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_60
    %var_62 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_61, void (i32*, {  }, i32)* @fn_53, 0
    %var_63 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_62, {  } %var_55, 1
    store { void (i32*, {  }, i32)*, {  } } %var_63, ptr %var_60
    %var_65 = alloca {  }
    %var_66 = load {  }, ptr %var_65
    store {  } %var_66, ptr %var_65
    %var_71 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_72 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_71
    %var_73 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_72, void (i32*, {  }, i32)* @fn_64, 0
    %var_74 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_73, {  } %var_66, 1
    store { void (i32*, {  }, i32)*, {  } } %var_74, ptr %var_71
    %var_75 = extractvalue { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_50, 0
    %var_76 = extractvalue { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_50, 1
    %var_77 = alloca i32
    call void %var_75(i32* %var_77, {  } %var_76, i32 %var_52, { void (i32*, {  }, i32)*, {  } } %var_63, { void (i32*, {  }, i32)*, {  } } %var_74)
    %var_78 = load i32, ptr %var_77
    %var_79 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_33, 0
    %var_80 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_33, 1
    %var_81 = alloca i32
    call void %var_79(i32* %var_81, {  } %var_80, i32 %var_78)
    %var_82 = load i32, ptr %var_81
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %var_25, {  } %var_26, i32 %var_27) {
  entry28: 
    call void @printf(i8* @const_29, i32 %var_27)
    store i32 %var_27, ptr %var_25
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_34(ptr sret(i32) %var_37, {  } %var_38, i32 %var_39, { void (i32*, {  }, i32)*, {  } } %var_40, { void (i32*, {  }, i32)*, {  } } %var_41) {
  entry42: 
    %var_43 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_40, 0
    %var_44 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_40, 1
    %var_45 = alloca i32
    call void %var_43(i32* %var_45, {  } %var_44, i32 %var_39)
    %var_46 = load i32, ptr %var_45
    store i32 %var_46, ptr %var_37
    ret void
}
define void @fn_53(ptr sret(i32) %var_56, {  } %var_57, i32 %var_58) {
  entry59: 
    store i32 %var_58, ptr %var_56
    ret void
}
define void @fn_64(ptr sret(i32) %var_67, {  } %var_68, i32 %var_69) {
  entry70: 
    store i32 %var_69, ptr %var_67
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > either 2 > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_29 = constant [3 x i8] c"%i\\00"
@const_51 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_29, i32 1)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_25, {} %var_26, i32 %var_27) local_unnamed_addr {
entry28:
  tail call void @printf(ptr nonnull @const_29, i32 %var_27)
  store i32 %var_27, ptr %var_25, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

define void @fn_34(ptr nocapture writeonly sret(i32) %var_37, {} %var_38, i32 %var_39, { ptr, {} } %var_40, { ptr, {} } %var_41) local_unnamed_addr {
entry42:
  %var_43 = extractvalue { ptr, {} } %var_40, 0
  %var_45 = alloca i32, align 4
  call void %var_43(ptr nonnull %var_45, {} zeroinitializer, i32 %var_39)
  %var_46 = load i32, ptr %var_45, align 4
  store i32 %var_46, ptr %var_37, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_53(ptr nocapture writeonly sret(i32) %var_56, {} %var_57, i32 %var_58) local_unnamed_addr #1 {
entry59:
  store i32 %var_58, ptr %var_56, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_64(ptr nocapture writeonly sret(i32) %var_67, {} %var_68, i32 %var_69) local_unnamed_addr #1 {
entry70:
  store i32 %var_69, ptr %var_67, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > either 2 > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > either 2 > stdout 1`] = `
[
  "1",
]
`;

exports[`simply typed lambda calc compilation > function application and literal print > compiled 1`] = `
"@const_21 = constant [3 x i8] c"%i\\00"
@const_38 = constant i32 2
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_15 = alloca {  }
    %var_16 = load {  }, ptr %var_15
    store {  } %var_16, ptr %var_15
    %var_22 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_23 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_22
    %var_24 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_23, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_25 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_24, {  } %var_16, 1
    store { void (i32*, {  }, i32)*, {  } } %var_25, ptr %var_22
    %var_27 = alloca {  }
    %var_28 = load {  }, ptr %var_27
    store {  } %var_28, ptr %var_27
    %var_34 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_35 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_34
    %var_36 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_35, void (i32*, {  }, i32)* @fn_26, 0
    %var_37 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_36, {  } %var_28, 1
    store { void (i32*, {  }, i32)*, {  } } %var_37, ptr %var_34
    %var_39 = load i32, ptr @const_38
    %var_40 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_37, 0
    %var_41 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_37, 1
    %var_42 = alloca i32
    call void %var_40(i32* %var_42, {  } %var_41, i32 %var_39)
    %var_43 = load i32, ptr %var_42
    %var_44 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_25, 0
    %var_45 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_25, 1
    %var_46 = alloca i32
    call void %var_44(i32* %var_46, {  } %var_45, i32 %var_43)
    %var_47 = load i32, ptr %var_46
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %var_17, {  } %var_18, i32 %var_19) {
  entry20: 
    call void @printf(i8* @const_21, i32 %var_19)
    store i32 %var_19, ptr %var_17
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_26(ptr sret(i32) %var_29, {  } %var_30, i32 %var_31) {
  entry32: 
    %var_33 = add i32 %var_31, %var_31
    store i32 %var_33, ptr %var_29
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > function application and literal print > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_21 = constant [3 x i8] c"%i\\00"
@const_38 = local_unnamed_addr constant i32 2
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_21, i32 4)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_17, {} %var_18, i32 %var_19) local_unnamed_addr {
entry20:
  tail call void @printf(ptr nonnull @const_21, i32 %var_19)
  store i32 %var_19, ptr %var_17, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_26(ptr nocapture writeonly sret(i32) %var_29, {} %var_30, i32 %var_31) local_unnamed_addr #1 {
entry32:
  %var_33 = shl i32 %var_31, 1
  store i32 %var_33, ptr %var_29, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > function application and literal print > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > function application and literal print > stdout 1`] = `
[
  "4",
]
`;

exports[`simply typed lambda calc compilation > function closure > compiled 1`] = `
"@const_27 = constant [3 x i8] c"%i\\00"
@const_48 = constant i32 2
@const_60 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_21 = alloca {  }
    %var_22 = load {  }, ptr %var_21
    store {  } %var_22, ptr %var_21
    %var_28 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_29 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_28
    %var_30 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_29, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_31 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_30, {  } %var_22, 1
    store { void (i32*, {  }, i32)*, {  } } %var_31, ptr %var_28
    %var_33 = alloca {  }
    %var_34 = load {  }, ptr %var_33
    store {  } %var_34, ptr %var_33
    %var_56 = alloca { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }
    %var_57 = load { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_56
    %var_58 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_57, void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)* @fn_32, 0
    %var_59 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_58, {  } %var_34, 1
    store { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_59, ptr %var_56
    %var_61 = load i32, ptr @const_60
    %var_62 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_59, 0
    %var_63 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_59, 1
    %var_64 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    call void %var_62({ void (i32*, { i32 }, i32)*, { i32 } }* %var_64, {  } %var_63, i32 %var_61)
    %var_65 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_64
    %var_66 = load i32, ptr @const_48
    %var_67 = extractvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_65, 0
    %var_68 = extractvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_65, 1
    %var_69 = alloca i32
    call void %var_67(i32* %var_69, { i32 } %var_68, i32 %var_66)
    %var_70 = load i32, ptr %var_69
    %var_71 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_31, 0
    %var_72 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_31, 1
    %var_73 = alloca i32
    call void %var_71(i32* %var_73, {  } %var_72, i32 %var_70)
    %var_74 = load i32, ptr %var_73
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %var_23, {  } %var_24, i32 %var_25) {
  entry26: 
    call void @printf(i8* @const_27, i32 %var_25)
    store i32 %var_25, ptr %var_23
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_32(ptr sret({ void (i32*, { i32 }, i32)*, { i32 } }) %var_35, {  } %var_36, i32 %var_37) {
  entry38: 
    %var_40 = alloca { i32 }
    %var_41 = load { i32 }, ptr %var_40
    %var_42 = insertvalue { i32 } %var_41, i32 %var_37, 0
    store { i32 } %var_42, ptr %var_40
    %var_52 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    %var_53 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_52
    %var_54 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_53, void (i32*, { i32 }, i32)* @fn_39, 0
    %var_55 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_54, { i32 } %var_42, 1
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_55, ptr %var_52
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_55, ptr %var_35
    ret void
}
define void @fn_39(ptr sret(i32) %var_43, { i32 } %var_44, i32 %var_45) {
  entry46: 
    %var_47 = extractvalue { i32 } %var_44, 0
    %var_49 = load i32, ptr @const_48
    %var_50 = mul i32 %var_49, %var_47
    %var_51 = add i32 %var_45, %var_50
    store i32 %var_51, ptr %var_43
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > function closure > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_27 = constant [3 x i8] c"%i\\00"
@const_48 = local_unnamed_addr constant i32 2
@const_60 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_27, i32 4)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_23, {} %var_24, i32 %var_25) local_unnamed_addr {
entry26:
  tail call void @printf(ptr nonnull @const_27, i32 %var_25)
  store i32 %var_25, ptr %var_23, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_32(ptr nocapture writeonly sret({ ptr, { i32 } }) %var_35, {} %var_36, i32 %var_37) local_unnamed_addr #1 {
entry38:
  %var_42 = insertvalue { i32 } undef, i32 %var_37, 0
  %var_55 = insertvalue { ptr, { i32 } } { ptr @fn_39, { i32 } undef }, { i32 } %var_42, 1
  store { ptr, { i32 } } %var_55, ptr %var_35, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_39(ptr nocapture writeonly sret(i32) %var_43, { i32 } %var_44, i32 %var_45) #1 {
entry46:
  %var_47 = extractvalue { i32 } %var_44, 0
  %var_50 = shl i32 %var_47, 1
  %var_51 = add i32 %var_50, %var_45
  store i32 %var_51, ptr %var_43, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > function closure > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > function closure > stdout 1`] = `
[
  "4",
]
`;

exports[`simply typed lambda calc compilation > function deep closure > compiled 1`] = `
"@const_31 = constant [3 x i8] c"%i\\00"
@const_77 = constant i32 1
@const_83 = constant i32 3
@const_89 = constant i32 5
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_25 = alloca {  }
    %var_26 = load {  }, ptr %var_25
    store {  } %var_26, ptr %var_25
    %var_32 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_33 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_32
    %var_34 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_33, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_35 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_34, {  } %var_26, 1
    store { void (i32*, {  }, i32)*, {  } } %var_35, ptr %var_32
    %var_37 = alloca {  }
    %var_38 = load {  }, ptr %var_37
    store {  } %var_38, ptr %var_37
    %var_73 = alloca { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }
    %var_74 = load { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_73
    %var_75 = insertvalue { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_74, void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)* @fn_36, 0
    %var_76 = insertvalue { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_75, {  } %var_38, 1
    store { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_76, ptr %var_73
    %var_78 = load i32, ptr @const_77
    %var_79 = extractvalue { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_76, 0
    %var_80 = extractvalue { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_76, 1
    %var_81 = alloca { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }
    call void %var_79({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }* %var_81, {  } %var_80, i32 %var_78)
    %var_82 = load { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }, ptr %var_81
    %var_84 = load i32, ptr @const_83
    %var_85 = extractvalue { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_82, 0
    %var_86 = extractvalue { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_82, 1
    %var_87 = alloca { void (i32*, { i32, i32 }, i32)*, { i32, i32 } }
    call void %var_85({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }* %var_87, { i32 } %var_86, i32 %var_84)
    %var_88 = load { void (i32*, { i32, i32 }, i32)*, { i32, i32 } }, ptr %var_87
    %var_90 = load i32, ptr @const_89
    %var_91 = extractvalue { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_88, 0
    %var_92 = extractvalue { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_88, 1
    %var_93 = alloca i32
    call void %var_91(i32* %var_93, { i32, i32 } %var_92, i32 %var_90)
    %var_94 = load i32, ptr %var_93
    %var_95 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_35, 0
    %var_96 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_35, 1
    %var_97 = alloca i32
    call void %var_95(i32* %var_97, {  } %var_96, i32 %var_94)
    %var_98 = load i32, ptr %var_97
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %var_27, {  } %var_28, i32 %var_29) {
  entry30: 
    call void @printf(i8* @const_31, i32 %var_29)
    store i32 %var_29, ptr %var_27
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_36(ptr sret({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }) %var_39, {  } %var_40, i32 %var_41) {
  entry42: 
    %var_44 = alloca { i32 }
    %var_45 = load { i32 }, ptr %var_44
    %var_46 = insertvalue { i32 } %var_45, i32 %var_41, 0
    store { i32 } %var_46, ptr %var_44
    %var_69 = alloca { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }
    %var_70 = load { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }, ptr %var_69
    %var_71 = insertvalue { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_70, void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)* @fn_43, 0
    %var_72 = insertvalue { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_71, { i32 } %var_46, 1
    store { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_72, ptr %var_69
    store { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_72, ptr %var_39
    ret void
}
define void @fn_43(ptr sret({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }) %var_47, { i32 } %var_48, i32 %var_49) {
  entry50: 
    %var_51 = extractvalue { i32 } %var_48, 0
    %var_53 = alloca { i32, i32 }
    %var_54 = load { i32, i32 }, ptr %var_53
    %var_55 = insertvalue { i32, i32 } %var_54, i32 %var_51, 0
    %var_56 = insertvalue { i32, i32 } %var_55, i32 %var_49, 1
    store { i32, i32 } %var_56, ptr %var_53
    %var_65 = alloca { void (i32*, { i32, i32 }, i32)*, { i32, i32 } }
    %var_66 = load { void (i32*, { i32, i32 }, i32)*, { i32, i32 } }, ptr %var_65
    %var_67 = insertvalue { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_66, void (i32*, { i32, i32 }, i32)* @fn_52, 0
    %var_68 = insertvalue { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_67, { i32, i32 } %var_56, 1
    store { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_68, ptr %var_65
    store { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_68, ptr %var_47
    ret void
}
define void @fn_52(ptr sret(i32) %var_57, { i32, i32 } %var_58, i32 %var_59) {
  entry60: 
    %var_61 = extractvalue { i32, i32 } %var_58, 0
    %var_62 = extractvalue { i32, i32 } %var_58, 1
    %var_63 = add i32 %var_62, %var_59
    %var_64 = add i32 %var_61, %var_63
    store i32 %var_64, ptr %var_57
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > function deep closure > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_31 = constant [3 x i8] c"%i\\00"
@const_77 = local_unnamed_addr constant i32 1
@const_83 = local_unnamed_addr constant i32 3
@const_89 = local_unnamed_addr constant i32 5
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_31, i32 9)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_27, {} %var_28, i32 %var_29) local_unnamed_addr {
entry30:
  tail call void @printf(ptr nonnull @const_31, i32 %var_29)
  store i32 %var_29, ptr %var_27, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_36(ptr nocapture writeonly sret({ ptr, { i32 } }) %var_39, {} %var_40, i32 %var_41) local_unnamed_addr #1 {
entry42:
  %var_46 = insertvalue { i32 } undef, i32 %var_41, 0
  %var_72 = insertvalue { ptr, { i32 } } { ptr @fn_43, { i32 } undef }, { i32 } %var_46, 1
  store { ptr, { i32 } } %var_72, ptr %var_39, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_43(ptr nocapture writeonly sret({ ptr, { i32, i32 } }) %var_47, { i32 } %var_48, i32 %var_49) #1 {
entry50:
  %var_51 = extractvalue { i32 } %var_48, 0
  store ptr @fn_52, ptr %var_47, align 8
  %var_47.repack1 = getelementptr inbounds { ptr, { i32, i32 } }, ptr %var_47, i64 0, i32 1
  store i32 %var_51, ptr %var_47.repack1, align 8
  %var_47.repack1.repack3 = getelementptr inbounds { ptr, { i32, i32 } }, ptr %var_47, i64 0, i32 1, i32 1
  store i32 %var_49, ptr %var_47.repack1.repack3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_52(ptr nocapture writeonly sret(i32) %var_57, { i32, i32 } %var_58, i32 %var_59) #1 {
entry60:
  %var_61 = extractvalue { i32, i32 } %var_58, 0
  %var_62 = extractvalue { i32, i32 } %var_58, 1
  %var_63 = add i32 %var_62, %var_59
  %var_64 = add i32 %var_63, %var_61
  store i32 %var_64, ptr %var_57, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > function deep closure > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > function deep closure > stdout 1`] = `
[
  "9",
]
`;

exports[`simply typed lambda calc compilation > function multiple args > compiled 1`] = `
"@const_25 = constant [3 x i8] c"%i\\00"
@const_38 = constant i32 2
@const_46 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_19 = alloca {  }
    %var_20 = load {  }, ptr %var_19
    store {  } %var_20, ptr %var_19
    %var_26 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_27 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_26
    %var_28 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_27, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_29 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_28, {  } %var_20, 1
    store { void (i32*, {  }, i32)*, {  } } %var_29, ptr %var_26
    %var_31 = alloca {  }
    %var_32 = load {  }, ptr %var_31
    store {  } %var_32, ptr %var_31
    %var_42 = alloca { void (i32*, {  }, i32, i32)*, {  } }
    %var_43 = load { void (i32*, {  }, i32, i32)*, {  } }, ptr %var_42
    %var_44 = insertvalue { void (i32*, {  }, i32, i32)*, {  } } %var_43, void (i32*, {  }, i32, i32)* @fn_30, 0
    %var_45 = insertvalue { void (i32*, {  }, i32, i32)*, {  } } %var_44, {  } %var_32, 1
    store { void (i32*, {  }, i32, i32)*, {  } } %var_45, ptr %var_42
    %var_47 = load i32, ptr @const_46
    %var_48 = load i32, ptr @const_38
    %var_49 = extractvalue { void (i32*, {  }, i32, i32)*, {  } } %var_45, 0
    %var_50 = extractvalue { void (i32*, {  }, i32, i32)*, {  } } %var_45, 1
    %var_51 = alloca i32
    call void %var_49(i32* %var_51, {  } %var_50, i32 %var_47, i32 %var_48)
    %var_52 = load i32, ptr %var_51
    %var_53 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_29, 0
    %var_54 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_29, 1
    %var_55 = alloca i32
    call void %var_53(i32* %var_55, {  } %var_54, i32 %var_52)
    %var_56 = load i32, ptr %var_55
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %var_21, {  } %var_22, i32 %var_23) {
  entry24: 
    call void @printf(i8* @const_25, i32 %var_23)
    store i32 %var_23, ptr %var_21
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_30(ptr sret(i32) %var_33, {  } %var_34, i32 %var_35, i32 %var_36) {
  entry37: 
    %var_39 = load i32, ptr @const_38
    %var_40 = mul i32 %var_39, %var_35
    %var_41 = add i32 %var_36, %var_40
    store i32 %var_41, ptr %var_33
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > function multiple args > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_25 = constant [3 x i8] c"%i\\00"
@const_38 = local_unnamed_addr constant i32 2
@const_46 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_25, i32 4)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_21, {} %var_22, i32 %var_23) local_unnamed_addr {
entry24:
  tail call void @printf(ptr nonnull @const_25, i32 %var_23)
  store i32 %var_23, ptr %var_21, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_30(ptr nocapture writeonly sret(i32) %var_33, {} %var_34, i32 %var_35, i32 %var_36) local_unnamed_addr #1 {
entry37:
  %var_40 = shl i32 %var_35, 1
  %var_41 = add i32 %var_40, %var_36
  store i32 %var_41, ptr %var_33, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > function multiple args > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > function multiple args > stdout 1`] = `
[
  "4",
]
`;

exports[`simply typed lambda calc compilation > hello world > compiled 1`] = `
"@const_15 = constant [3 x i8] c"%s\\00"
@const_20 = constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_9 = alloca {  }
    %var_10 = load {  }, ptr %var_9
    store {  } %var_10, ptr %var_9
    %var_16 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_17 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_16
    %var_18 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_17, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_19 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_18, {  } %var_10, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_19, ptr %var_16
    %var_21 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_19, 0
    %var_22 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_19, 1
    %var_23 = alloca i8*
    call void %var_21(i8** %var_23, {  } %var_22, i8* @const_20)
    %var_24 = load i8*, ptr %var_23
    ret i32 0
}
define void @"generated_print_i8*"(ptr sret(i8*) %var_11, {  } %var_12, i8* %var_13) {
  entry14: 
    call void @printf(i8* @const_15, i8* %var_13)
    store i8* %var_13, ptr %var_11
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`simply typed lambda calc compilation > hello world > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_15 = constant [3 x i8] c"%s\\00"
@const_20 = constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_15, ptr nonnull @const_20)
  ret i32 0
}

define void @"generated_print_i8*"(ptr nocapture writeonly sret(ptr) %var_11, {} %var_12, ptr %var_13) local_unnamed_addr {
entry14:
  tail call void @printf(ptr nonnull @const_15, ptr %var_13)
  store ptr %var_13, ptr %var_11, align 8
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`simply typed lambda calc compilation > hello world > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > hello world > stdout 1`] = `
[
  "hello world!",
]
`;

exports[`simply typed lambda calc compilation > hello world string > compiled 1`] = `
"@const_7 = constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    ret i32 0
}
"
`;

exports[`simply typed lambda calc compilation > hello world string > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_7 = local_unnamed_addr constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef i32 @main() local_unnamed_addr #0 {
main:
  ret i32 0
}

attributes #0 = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) }
"
`;

exports[`simply typed lambda calc compilation > hello world string > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > hello world string > stdout 1`] = `[]`;

exports[`simply typed lambda calc compilation > print number > compiled 1`] = `
"@const_15 = constant [3 x i8] c"%i\\00"
@const_20 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_9 = alloca {  }
    %var_10 = load {  }, ptr %var_9
    store {  } %var_10, ptr %var_9
    %var_16 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_17 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_16
    %var_18 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_17, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_19 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_18, {  } %var_10, 1
    store { void (i32*, {  }, i32)*, {  } } %var_19, ptr %var_16
    %var_21 = load i32, ptr @const_20
    %var_22 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_19, 0
    %var_23 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_19, 1
    %var_24 = alloca i32
    call void %var_22(i32* %var_24, {  } %var_23, i32 %var_21)
    %var_25 = load i32, ptr %var_24
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %var_11, {  } %var_12, i32 %var_13) {
  entry14: 
    call void @printf(i8* @const_15, i32 %var_13)
    store i32 %var_13, ptr %var_11
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`simply typed lambda calc compilation > print number > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_15 = constant [3 x i8] c"%i\\00"
@const_20 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_15, i32 1)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_11, {} %var_12, i32 %var_13) local_unnamed_addr {
entry14:
  tail call void @printf(ptr nonnull @const_15, i32 %var_13)
  store i32 %var_13, ptr %var_11, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`simply typed lambda calc compilation > print number > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > print number > stdout 1`] = `
[
  "1",
]
`;

exports[`structured programming compilation > block > compiled 1`] = `
"@const_20 = constant [3 x i8] c"%i\\00"
@const_25 = constant i32 123
@const_27 = constant i32 234
@const_29 = constant i32 345
@const_31 = constant i32 456
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_14 = alloca {  }
    %var_15 = load {  }, ptr %var_14
    store {  } %var_15, ptr %var_14
    %var_21 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_22 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_21
    %var_23 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_22, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_24 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_23, {  } %var_15, 1
    store { void (i32*, {  }, i32)*, {  } } %var_24, ptr %var_21
    %var_26 = load i32, ptr @const_25
    %var_28 = load i32, ptr @const_27
    %var_30 = load i32, ptr @const_29
    %var_32 = load i32, ptr @const_31
    %var_33 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_24, 0
    %var_34 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_24, 1
    %var_35 = alloca i32
    call void %var_33(i32* %var_35, {  } %var_34, i32 %var_32)
    %var_36 = load i32, ptr %var_35
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %var_16, {  } %var_17, i32 %var_18) {
  entry19: 
    call void @printf(i8* @const_20, i32 %var_18)
    store i32 %var_18, ptr %var_16
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > block > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_20 = constant [3 x i8] c"%i\\00"
@const_25 = local_unnamed_addr constant i32 123
@const_27 = local_unnamed_addr constant i32 234
@const_29 = local_unnamed_addr constant i32 345
@const_31 = local_unnamed_addr constant i32 456
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_20, i32 456)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_16, {} %var_17, i32 %var_18) local_unnamed_addr {
entry19:
  tail call void @printf(ptr nonnull @const_20, i32 %var_18)
  store i32 %var_18, ptr %var_16, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > block > stderr 1`] = `[]`;

exports[`structured programming compilation > block > stdout 1`] = `
[
  "456",
]
`;

exports[`structured programming compilation > block variable assingment > compiled 1`] = `
"@const_25 = constant [3 x i8] c"%i\\00"
@const_30 = constant i32 123
@const_32 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_19 = alloca {  }
    %var_20 = load {  }, ptr %var_19
    store {  } %var_20, ptr %var_19
    %var_26 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_27 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_26
    %var_28 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_27, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_29 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_28, {  } %var_20, 1
    store { void (i32*, {  }, i32)*, {  } } %var_29, ptr %var_26
    %var_31 = load i32, ptr @const_30
    %var_33 = load i32, ptr @const_32
    %var_34 = add i32 %var_31, %var_33
    %var_35 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_29, 0
    %var_36 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_29, 1
    %var_37 = alloca i32
    call void %var_35(i32* %var_37, {  } %var_36, i32 %var_34)
    %var_38 = load i32, ptr %var_37
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %var_21, {  } %var_22, i32 %var_23) {
  entry24: 
    call void @printf(i8* @const_25, i32 %var_23)
    store i32 %var_23, ptr %var_21
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > block variable assingment > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_25 = constant [3 x i8] c"%i\\00"
@const_30 = local_unnamed_addr constant i32 123
@const_32 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_25, i32 124)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_21, {} %var_22, i32 %var_23) local_unnamed_addr {
entry24:
  tail call void @printf(ptr nonnull @const_25, i32 %var_23)
  store i32 %var_23, ptr %var_21, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > block variable assingment > stderr 1`] = `[]`;

exports[`structured programming compilation > block variable assingment > stdout 1`] = `
[
  "124",
]
`;

exports[`structured programming compilation > block variable declaration > compiled 1`] = `
"@const_20 = constant [3 x i8] c"%i\\00"
@const_25 = constant i32 123
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_14 = alloca {  }
    %var_15 = load {  }, ptr %var_14
    store {  } %var_15, ptr %var_14
    %var_21 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_22 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_21
    %var_23 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_22, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_24 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_23, {  } %var_15, 1
    store { void (i32*, {  }, i32)*, {  } } %var_24, ptr %var_21
    %var_26 = load i32, ptr @const_25
    %var_27 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_24, 0
    %var_28 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_24, 1
    %var_29 = alloca i32
    call void %var_27(i32* %var_29, {  } %var_28, i32 %var_26)
    %var_30 = load i32, ptr %var_29
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %var_16, {  } %var_17, i32 %var_18) {
  entry19: 
    call void @printf(i8* @const_20, i32 %var_18)
    store i32 %var_18, ptr %var_16
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > block variable declaration > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_20 = constant [3 x i8] c"%i\\00"
@const_25 = local_unnamed_addr constant i32 123
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_20, i32 123)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_16, {} %var_17, i32 %var_18) local_unnamed_addr {
entry19:
  tail call void @printf(ptr nonnull @const_20, i32 %var_18)
  store i32 %var_18, ptr %var_16, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > block variable declaration > stderr 1`] = `[]`;

exports[`structured programming compilation > block variable declaration > stdout 1`] = `
[
  "123",
]
`;

exports[`structured programming compilation > block variable shadowing > compiled 1`] = `
"@const_23 = constant [3 x i8] c"%i\\00"
@const_28 = constant i32 123
@const_30 = constant i32 234
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_17 = alloca {  }
    %var_18 = load {  }, ptr %var_17
    store {  } %var_18, ptr %var_17
    %var_24 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_25 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_24
    %var_26 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_25, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_27 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_26, {  } %var_18, 1
    store { void (i32*, {  }, i32)*, {  } } %var_27, ptr %var_24
    %var_29 = load i32, ptr @const_28
    %var_31 = load i32, ptr @const_30
    %var_32 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_27, 0
    %var_33 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_27, 1
    %var_34 = alloca i32
    call void %var_32(i32* %var_34, {  } %var_33, i32 %var_31)
    %var_35 = load i32, ptr %var_34
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %var_19, {  } %var_20, i32 %var_21) {
  entry22: 
    call void @printf(i8* @const_23, i32 %var_21)
    store i32 %var_21, ptr %var_19
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > block variable shadowing > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_23 = constant [3 x i8] c"%i\\00"
@const_28 = local_unnamed_addr constant i32 123
@const_30 = local_unnamed_addr constant i32 234
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_23, i32 234)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_19, {} %var_20, i32 %var_21) local_unnamed_addr {
entry22:
  tail call void @printf(ptr nonnull @const_23, i32 %var_21)
  store i32 %var_21, ptr %var_19, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > block variable shadowing > stderr 1`] = `[]`;

exports[`structured programming compilation > block variable shadowing > stdout 1`] = `
[
  "234",
]
`;

exports[`structured programming compilation > hello world twice > compiled 1`] = `
"@const_18 = constant [3 x i8] c"%s\\00"
@const_23 = constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_12 = alloca {  }
    %var_13 = load {  }, ptr %var_12
    store {  } %var_13, ptr %var_12
    %var_19 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_20 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_19
    %var_21 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_20, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_22 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_21, {  } %var_13, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_22, ptr %var_19
    %var_24 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_22, 0
    %var_25 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_22, 1
    %var_26 = alloca i8*
    call void %var_24(i8** %var_26, {  } %var_25, i8* @const_23)
    %var_27 = load i8*, ptr %var_26
    %var_28 = alloca {  }
    %var_29 = load {  }, ptr %var_28
    store {  } %var_29, ptr %var_28
    %var_30 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_31 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_30
    %var_32 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_31, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_33 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_32, {  } %var_29, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_33, ptr %var_30
    %var_34 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_33, 0
    %var_35 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_33, 1
    %var_36 = alloca i8*
    call void %var_34(i8** %var_36, {  } %var_35, i8* @const_23)
    %var_37 = load i8*, ptr %var_36
    ret i32 0
}
define void @"generated_print_i8*"(ptr sret(i8*) %var_14, {  } %var_15, i8* %var_16) {
  entry17: 
    call void @printf(i8* @const_18, i8* %var_16)
    store i8* %var_16, ptr %var_14
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > hello world twice > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_18 = constant [3 x i8] c"%s\\00"
@const_23 = constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_18, ptr nonnull @const_23)
  tail call void @printf(ptr nonnull @const_18, ptr nonnull @const_23)
  ret i32 0
}

define void @"generated_print_i8*"(ptr nocapture writeonly sret(ptr) %var_14, {} %var_15, ptr %var_16) local_unnamed_addr {
entry17:
  tail call void @printf(ptr nonnull @const_18, ptr %var_16)
  store ptr %var_16, ptr %var_14, align 8
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > hello world twice > stderr 1`] = `[]`;

exports[`structured programming compilation > hello world twice > stdout 1`] = `
[
  "hello world!hello world!",
]
`;

exports[`structured programming compilation > if-then > compiled 1`] = `
"@const_19 = constant [3 x i8] c"%i\\00"
@const_24 = constant i1 1
@const_28 = constant i32 123
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_13 = alloca {  }
    %var_14 = load {  }, ptr %var_13
    store {  } %var_14, ptr %var_13
    %var_20 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_21 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_20
    %var_22 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_21, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_23 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_22, {  } %var_14, 1
    store { void (i32*, {  }, i32)*, {  } } %var_23, ptr %var_20
    %var_25 = load i1, ptr @const_24
    br i1 %var_25, label %then27, label %if_rest26
  then27: 
    %var_29 = load i32, ptr @const_28
    br label %if_rest26
  if_rest26: 
    %var_30 = phi i32 [%var_29, %then27], [undef, %main]
    %var_31 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_23, 0
    %var_32 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_23, 1
    %var_33 = alloca i32
    call void %var_31(i32* %var_33, {  } %var_32, i32 %var_30)
    %var_34 = load i32, ptr %var_33
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %var_15, {  } %var_16, i32 %var_17) {
  entry18: 
    call void @printf(i8* @const_19, i32 %var_17)
    store i32 %var_17, ptr %var_15
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > if-then > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_19 = constant [3 x i8] c"%i\\00"
@const_24 = local_unnamed_addr constant i1 true
@const_28 = local_unnamed_addr constant i32 123
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_19, i32 123)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_15, {} %var_16, i32 %var_17) local_unnamed_addr {
entry18:
  tail call void @printf(ptr nonnull @const_19, i32 %var_17)
  store i32 %var_17, ptr %var_15, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > if-then > stderr 1`] = `[]`;

exports[`structured programming compilation > if-then > stdout 1`] = `
[
  "123",
]
`;

exports[`structured programming compilation > if-then-else > compiled 1`] = `
"@const_22 = constant [3 x i8] c"%i\\00"
@const_27 = constant i1 0
@const_31 = constant i32 123
@const_34 = constant i32 456
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_16 = alloca {  }
    %var_17 = load {  }, ptr %var_16
    store {  } %var_17, ptr %var_16
    %var_23 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_24 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_23
    %var_25 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_24, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_26 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_25, {  } %var_17, 1
    store { void (i32*, {  }, i32)*, {  } } %var_26, ptr %var_23
    %var_28 = load i1, ptr @const_27
    br i1 %var_28, label %then30, label %else33
  then30: 
    %var_32 = load i32, ptr @const_31
    br label %if_rest29
  else33: 
    %var_35 = load i32, ptr @const_34
    br label %if_rest29
  if_rest29: 
    %var_36 = phi i32 [%var_32, %then30], [%var_35, %else33]
    %var_37 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_26, 0
    %var_38 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_26, 1
    %var_39 = alloca i32
    call void %var_37(i32* %var_39, {  } %var_38, i32 %var_36)
    %var_40 = load i32, ptr %var_39
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %var_18, {  } %var_19, i32 %var_20) {
  entry21: 
    call void @printf(i8* @const_22, i32 %var_20)
    store i32 %var_20, ptr %var_18
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > if-then-else > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_22 = constant [3 x i8] c"%i\\00"
@const_27 = local_unnamed_addr constant i1 false
@const_31 = local_unnamed_addr constant i32 123
@const_34 = local_unnamed_addr constant i32 456
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_22, i32 456)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_18, {} %var_19, i32 %var_20) local_unnamed_addr {
entry21:
  tail call void @printf(ptr nonnull @const_22, i32 %var_20)
  store i32 %var_20, ptr %var_18, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > if-then-else > stderr 1`] = `[]`;

exports[`structured programming compilation > if-then-else > stdout 1`] = `
[
  "456",
]
`;

exports[`structured programming compilation > sequence > compiled 1`] = `
"@const_19 = constant [3 x i8] c"%i\\00"
@const_24 = constant i32 123
@const_26 = constant i32 234
@const_28 = constant i32 345
@const_30 = constant i32 456
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_13 = alloca {  }
    %var_14 = load {  }, ptr %var_13
    store {  } %var_14, ptr %var_13
    %var_20 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_21 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_20
    %var_22 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_21, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_23 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_22, {  } %var_14, 1
    store { void (i32*, {  }, i32)*, {  } } %var_23, ptr %var_20
    %var_25 = load i32, ptr @const_24
    %var_27 = load i32, ptr @const_26
    %var_29 = load i32, ptr @const_28
    %var_31 = load i32, ptr @const_30
    %var_32 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_23, 0
    %var_33 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_23, 1
    %var_34 = alloca i32
    call void %var_32(i32* %var_34, {  } %var_33, i32 %var_31)
    %var_35 = load i32, ptr %var_34
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %var_15, {  } %var_16, i32 %var_17) {
  entry18: 
    call void @printf(i8* @const_19, i32 %var_17)
    store i32 %var_17, ptr %var_15
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > sequence > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_19 = constant [3 x i8] c"%i\\00"
@const_24 = local_unnamed_addr constant i32 123
@const_26 = local_unnamed_addr constant i32 234
@const_28 = local_unnamed_addr constant i32 345
@const_30 = local_unnamed_addr constant i32 456
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_19, i32 456)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_15, {} %var_16, i32 %var_17) local_unnamed_addr {
entry18:
  tail call void @printf(ptr nonnull @const_19, i32 %var_17)
  store i32 %var_17, ptr %var_15, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > sequence > stderr 1`] = `[]`;

exports[`structured programming compilation > sequence > stdout 1`] = `
[
  "456",
]
`;

exports[`structured programming compilation > two prints > compiled 1`] = `
"@const_18 = constant [3 x i8] c"%s\\00"
@const_23 = constant [13 x i8] c"hello world!\\00"
@const_34 = constant [15 x i8] c"hello world 2!\\00"
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_12 = alloca {  }
    %var_13 = load {  }, ptr %var_12
    store {  } %var_13, ptr %var_12
    %var_19 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_20 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_19
    %var_21 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_20, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_22 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_21, {  } %var_13, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_22, ptr %var_19
    %var_24 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_22, 0
    %var_25 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_22, 1
    %var_26 = alloca i8*
    call void %var_24(i8** %var_26, {  } %var_25, i8* @const_23)
    %var_27 = load i8*, ptr %var_26
    %var_28 = alloca {  }
    %var_29 = load {  }, ptr %var_28
    store {  } %var_29, ptr %var_28
    %var_30 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_31 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_30
    %var_32 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_31, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_33 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_32, {  } %var_29, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_33, ptr %var_30
    %var_35 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_33, 0
    %var_36 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_33, 1
    %var_37 = alloca i8*
    call void %var_35(i8** %var_37, {  } %var_36, i8* @const_34)
    %var_38 = load i8*, ptr %var_37
    ret i32 0
}
define void @"generated_print_i8*"(ptr sret(i8*) %var_14, {  } %var_15, i8* %var_16) {
  entry17: 
    call void @printf(i8* @const_18, i8* %var_16)
    store i8* %var_16, ptr %var_14
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > two prints > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_18 = constant [3 x i8] c"%s\\00"
@const_23 = constant [13 x i8] c"hello world!\\00"
@const_34 = constant [15 x i8] c"hello world 2!\\00"
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_18, ptr nonnull @const_23)
  tail call void @printf(ptr nonnull @const_18, ptr nonnull @const_34)
  ret i32 0
}

define void @"generated_print_i8*"(ptr nocapture writeonly sret(ptr) %var_14, {} %var_15, ptr %var_16) local_unnamed_addr {
entry17:
  tail call void @printf(ptr nonnull @const_18, ptr %var_16)
  store ptr %var_16, ptr %var_14, align 8
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > two prints > stderr 1`] = `[]`;

exports[`structured programming compilation > two prints > stdout 1`] = `
[
  "hello world!hello world 2!",
]
`;
