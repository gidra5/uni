// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`data structures compilation > atom (global symbol) > compiled 1`] = `
"@const_0 = constant i64 0
@const_1 = constant [7 x i8] c"atom_a\\00"
@symbols_metadata_array = constant [1 x { i8* }] [{ i8* } { i8* @const_1 }]
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_11 = alloca {  }
    %var_12 = load {  }, ptr %var_11
    store {  } %var_12, ptr %var_11
    %var_23 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_24 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_23
    %var_25 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_24, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_26 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_25, {  } %var_12, 1
    store { void (i64*, {  }, i64)*, {  } } %var_26, ptr %var_23
    %var_27 = load i64, ptr @const_0
    %var_28 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_26, 0
    %var_29 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_26, 1
    %var_30 = alloca i64
    call void %var_28(i64* %var_30, {  } %var_29, i64 %var_27)
    %var_31 = load i64, ptr %var_30
    ret i32 0
}
define void @"generated_print_symbol"(ptr sret(i64) %arg_0, {  } %arg_1, i64 %arg_2) {
  entry_0: 
    %var_13 = alloca {  }
    %var_14 = load {  }, ptr %var_13
    store {  } %var_14, ptr %var_13
    %var_15 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_16 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_15
    %var_17 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_16, void (i64*, {  }, i64)* @print_symbol_wrap, 0
    %var_18 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_17, {  } %var_14, 1
    store { void (i64*, {  }, i64)*, {  } } %var_18, ptr %var_15
    %var_19 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_18, 0
    %var_20 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_18, 1
    %var_21 = alloca i64
    call void %var_19(i64* %var_21, {  } %var_20, i64 %arg_2)
    %var_22 = load i64, ptr %var_21
    store i64 %arg_2, ptr %arg_0
    ret void
}
declare void @print_symbol(i64)
define void @print_symbol_wrap(ptr sret(i64) %arg_0, {  } %arg_1, i64 %arg_2) {
  entry_0: 
    call void @print_symbol(i64 %arg_2)
    store i64 %arg_2, ptr %arg_0
    ret void
}
"
`;

exports[`data structures compilation > atom (global symbol) > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = local_unnamed_addr constant i64 0
@const_1 = constant [7 x i8] c"atom_a\\00"
@symbols_metadata_array = constant [1 x { ptr }] [{ ptr } { ptr @const_1 }]
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @print_symbol(i64 0)
  ret i32 0
}

define void @generated_print_symbol(ptr nocapture writeonly sret(i64) %arg_0, {} %arg_1, i64 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @print_symbol(i64 %arg_2)
  store i64 %arg_2, ptr %arg_0, align 8
  ret void
}

declare void @print_symbol(i64) local_unnamed_addr

define void @print_symbol_wrap(ptr nocapture writeonly sret(i64) %arg_0, {} %arg_1, i64 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @print_symbol(i64 %arg_2)
  store i64 %arg_2, ptr %arg_0, align 8
  ret void
}
"
`;

exports[`data structures compilation > atom (global symbol) > stderr 1`] = `[]`;

exports[`data structures compilation > atom (global symbol) > stdout 1`] = `
[
  "symbol(atom_a)",
]
`;

exports[`data structures compilation > boolean false > compiled 1`] = `
"@const_0 = constant [5 x i8] c"true\\00"
@const_1 = constant [6 x i8] c"false\\00"
@const_2 = constant [3 x i8] c"%s\\00"
@const_3 = constant i1 0
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_11 = alloca {  }
    %var_12 = load {  }, ptr %var_11
    store {  } %var_12, ptr %var_11
    %var_14 = alloca { void (i1*, {  }, i1)*, {  } }
    %var_15 = load { void (i1*, {  }, i1)*, {  } }, ptr %var_14
    %var_16 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_15, void (i1*, {  }, i1)* @"generated_print_i1", 0
    %var_17 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_16, {  } %var_12, 1
    store { void (i1*, {  }, i1)*, {  } } %var_17, ptr %var_14
    %var_18 = load i1, ptr @const_3
    %var_19 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_17, 0
    %var_20 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_17, 1
    %var_21 = alloca i1
    call void %var_19(i1* %var_21, {  } %var_20, i1 %var_18)
    %var_22 = load i1, ptr %var_21
    ret i32 0
}
define void @"generated_print_i1"(ptr sret(i1) %arg_0, {  } %arg_1, i1 %arg_2) {
  entry_0: 
    %var_13 = select i1 %arg_2, [5 x i8]* @const_0, [5 x i8]* @const_1
    call void @printf(i8* @const_2, [5 x i8]* %var_13)
    store i1 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`data structures compilation > boolean false > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [5 x i8] c"true\\00"
@const_1 = constant [6 x i8] c"false\\00"
@const_2 = constant [3 x i8] c"%s\\00"
@const_3 = local_unnamed_addr constant i1 false
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_2, ptr nonnull @const_1)
  ret i32 0
}

define void @generated_print_i1(ptr nocapture writeonly sret(i1) %arg_0, {} %arg_1, i1 %arg_2) local_unnamed_addr {
entry_0:
  %var_13 = select i1 %arg_2, ptr @const_0, ptr @const_1
  tail call void @printf(ptr nonnull @const_2, ptr nonnull %var_13)
  store i1 %arg_2, ptr %arg_0, align 1
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`data structures compilation > boolean false > stderr 1`] = `[]`;

exports[`data structures compilation > boolean false > stdout 1`] = `
[
  "false",
]
`;

exports[`data structures compilation > boolean true > compiled 1`] = `
"@const_0 = constant [5 x i8] c"true\\00"
@const_1 = constant [6 x i8] c"false\\00"
@const_2 = constant [3 x i8] c"%s\\00"
@const_3 = constant i1 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_11 = alloca {  }
    %var_12 = load {  }, ptr %var_11
    store {  } %var_12, ptr %var_11
    %var_14 = alloca { void (i1*, {  }, i1)*, {  } }
    %var_15 = load { void (i1*, {  }, i1)*, {  } }, ptr %var_14
    %var_16 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_15, void (i1*, {  }, i1)* @"generated_print_i1", 0
    %var_17 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_16, {  } %var_12, 1
    store { void (i1*, {  }, i1)*, {  } } %var_17, ptr %var_14
    %var_18 = load i1, ptr @const_3
    %var_19 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_17, 0
    %var_20 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_17, 1
    %var_21 = alloca i1
    call void %var_19(i1* %var_21, {  } %var_20, i1 %var_18)
    %var_22 = load i1, ptr %var_21
    ret i32 0
}
define void @"generated_print_i1"(ptr sret(i1) %arg_0, {  } %arg_1, i1 %arg_2) {
  entry_0: 
    %var_13 = select i1 %arg_2, [5 x i8]* @const_0, [5 x i8]* @const_1
    call void @printf(i8* @const_2, [5 x i8]* %var_13)
    store i1 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`data structures compilation > boolean true > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [5 x i8] c"true\\00"
@const_1 = constant [6 x i8] c"false\\00"
@const_2 = constant [3 x i8] c"%s\\00"
@const_3 = local_unnamed_addr constant i1 true
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_2, ptr nonnull @const_0)
  ret i32 0
}

define void @generated_print_i1(ptr nocapture writeonly sret(i1) %arg_0, {} %arg_1, i1 %arg_2) local_unnamed_addr {
entry_0:
  %var_13 = select i1 %arg_2, ptr @const_0, ptr @const_1
  tail call void @printf(ptr nonnull @const_2, ptr nonnull %var_13)
  store i1 %arg_2, ptr %arg_0, align 1
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`data structures compilation > boolean true > stderr 1`] = `[]`;

exports[`data structures compilation > boolean true > stdout 1`] = `
[
  "true",
]
`;

exports[`data structures compilation > symbol > compiled 1`] = `
"@const_0 = constant i64 0
@const_1 = constant [10 x i8] c"symbol_ab\\00"
@symbols_metadata_array = constant [1 x { i8* }] [{ i8* } { i8* @const_1 }]
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_11 = alloca {  }
    %var_12 = load {  }, ptr %var_11
    store {  } %var_12, ptr %var_11
    %var_23 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_24 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_23
    %var_25 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_24, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_26 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_25, {  } %var_12, 1
    store { void (i64*, {  }, i64)*, {  } } %var_26, ptr %var_23
    %var_27 = load i64, ptr @const_0
    %var_28 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_26, 0
    %var_29 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_26, 1
    %var_30 = alloca i64
    call void %var_28(i64* %var_30, {  } %var_29, i64 %var_27)
    %var_31 = load i64, ptr %var_30
    ret i32 0
}
define void @"generated_print_symbol"(ptr sret(i64) %arg_0, {  } %arg_1, i64 %arg_2) {
  entry_0: 
    %var_13 = alloca {  }
    %var_14 = load {  }, ptr %var_13
    store {  } %var_14, ptr %var_13
    %var_15 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_16 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_15
    %var_17 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_16, void (i64*, {  }, i64)* @print_symbol_wrap, 0
    %var_18 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_17, {  } %var_14, 1
    store { void (i64*, {  }, i64)*, {  } } %var_18, ptr %var_15
    %var_19 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_18, 0
    %var_20 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_18, 1
    %var_21 = alloca i64
    call void %var_19(i64* %var_21, {  } %var_20, i64 %arg_2)
    %var_22 = load i64, ptr %var_21
    store i64 %arg_2, ptr %arg_0
    ret void
}
declare void @print_symbol(i64)
define void @print_symbol_wrap(ptr sret(i64) %arg_0, {  } %arg_1, i64 %arg_2) {
  entry_0: 
    call void @print_symbol(i64 %arg_2)
    store i64 %arg_2, ptr %arg_0
    ret void
}
"
`;

exports[`data structures compilation > symbol > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = local_unnamed_addr constant i64 0
@const_1 = constant [10 x i8] c"symbol_ab\\00"
@symbols_metadata_array = constant [1 x { ptr }] [{ ptr } { ptr @const_1 }]
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @print_symbol(i64 0)
  ret i32 0
}

define void @generated_print_symbol(ptr nocapture writeonly sret(i64) %arg_0, {} %arg_1, i64 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @print_symbol(i64 %arg_2)
  store i64 %arg_2, ptr %arg_0, align 8
  ret void
}

declare void @print_symbol(i64) local_unnamed_addr

define void @print_symbol_wrap(ptr nocapture writeonly sret(i64) %arg_0, {} %arg_1, i64 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @print_symbol(i64 %arg_2)
  store i64 %arg_2, ptr %arg_0, align 8
  ret void
}
"
`;

exports[`data structures compilation > symbol > stderr 1`] = `[]`;

exports[`data structures compilation > symbol > stdout 1`] = `
[
  "symbol(symbol_ab)",
]
`;

exports[`data structures compilation > tuple > compiled 1`] = `
"@const_0 = constant [7 x i8] c"tuple(\\00"
@const_1 = constant [3 x i8] c"%s\\00"
@const_2 = constant [3 x i8] c"%i\\00"
@const_3 = constant [3 x i8] c", \\00"
@const_4 = constant [2 x i8] c")\\00"
@const_5 = constant i32 1
@const_6 = constant [3 x i8] c"ab\\00"
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_14 = alloca {  }
    %var_15 = load {  }, ptr %var_14
    store {  } %var_15, ptr %var_14
    %var_38 = alloca { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } }
    %var_39 = load { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } }, ptr %var_38
    %var_40 = insertvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_39, void ({ i32, i8* }*, {  }, { i32, i8* })* @"generated_print_(i32, i8*)", 0
    %var_41 = insertvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_40, {  } %var_15, 1
    store { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_41, ptr %var_38
    %var_42 = load i32, ptr @const_5
    %var_43 = alloca { i32 }
    %var_44 = load { i32 }, ptr %var_43
    %var_45 = insertvalue { i32 } %var_44, i32 %var_42, 0
    store { i32 } %var_45, ptr %var_43
    %var_46 = extractvalue { i32 } %var_45, 0
    %var_47 = alloca { i32, [3 x i8]* }
    %var_48 = load { i32, [3 x i8]* }, ptr %var_47
    %var_49 = insertvalue { i32, [3 x i8]* } %var_48, i32 %var_46, 0
    %var_50 = insertvalue { i32, [3 x i8]* } %var_49, [3 x i8]* @const_6, 1
    store { i32, [3 x i8]* } %var_50, ptr %var_47
    %var_51 = extractvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_41, 0
    %var_52 = extractvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_41, 1
    %var_53 = alloca { i32, i8* }
    call void %var_51({ i32, i8* }* %var_53, {  } %var_52, { i32, i8* } %var_50)
    %var_54 = load { i32, i8* }, ptr %var_53
    ret i32 0
}
define void @"generated_print_(i32, i8*)"(ptr sret({ i32, i8* }) %arg_0, {  } %arg_1, { i32, i8* } %arg_2) {
  entry_0: 
    call void @printf(i8* @const_1, [7 x i8]* @const_0)
    %var_16 = extractvalue { i32, i8* } %arg_2, 0
    %var_17 = alloca {  }
    %var_18 = load {  }, ptr %var_17
    store {  } %var_18, ptr %var_17
    %var_19 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_20 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_19
    %var_21 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_20, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_22 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_21, {  } %var_18, 1
    store { void (i32*, {  }, i32)*, {  } } %var_22, ptr %var_19
    %var_23 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_22, 0
    %var_24 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_22, 1
    %var_25 = alloca i32
    call void %var_23(i32* %var_25, {  } %var_24, i32 %var_16)
    %var_26 = load i32, ptr %var_25
    call void @printf(i8* @const_1, [3 x i8]* @const_3)
    %var_27 = extractvalue { i32, i8* } %arg_2, 1
    %var_28 = alloca {  }
    %var_29 = load {  }, ptr %var_28
    store {  } %var_29, ptr %var_28
    %var_30 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_31 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_30
    %var_32 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_31, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_33 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_32, {  } %var_29, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_33, ptr %var_30
    %var_34 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_33, 0
    %var_35 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_33, 1
    %var_36 = alloca i8*
    call void %var_34(i8** %var_36, {  } %var_35, i8* %var_27)
    %var_37 = load i8*, ptr %var_36
    call void @printf(i8* @const_1, [2 x i8]* @const_4)
    store { i32, i8* } %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_2, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
define void @"generated_print_i8*"(ptr sret(i8*) %arg_0, {  } %arg_1, i8* %arg_2) {
  entry_0: 
    call void @printf(i8* @const_1, i8* %arg_2)
    store i8* %arg_2, ptr %arg_0
    ret void
}
"
`;

exports[`data structures compilation > tuple > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [7 x i8] c"tuple(\\00"
@const_1 = constant [3 x i8] c"%s\\00"
@const_2 = constant [3 x i8] c"%i\\00"
@const_3 = constant [3 x i8] c", \\00"
@const_4 = constant [2 x i8] c")\\00"
@const_5 = local_unnamed_addr constant i32 1
@const_6 = constant [3 x i8] c"ab\\00"
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_0)
  tail call void @printf(ptr nonnull @const_2, i32 1)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_3)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_6)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_4)
  ret i32 0
}

define void @"generated_print_(i32, i8*)"(ptr nocapture writeonly sret({ i32, ptr }) %arg_0, {} %arg_1, { i32, ptr } %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_0)
  %var_16 = extractvalue { i32, ptr } %arg_2, 0
  tail call void @printf(ptr nonnull @const_2, i32 %var_16)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_3)
  %var_27 = extractvalue { i32, ptr } %arg_2, 1
  tail call void @printf(ptr nonnull @const_1, ptr %var_27)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_4)
  store { i32, ptr } %arg_2, ptr %arg_0, align 8
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_2, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

define void @"generated_print_i8*"(ptr nocapture writeonly sret(ptr) %arg_0, {} %arg_1, ptr %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_1, ptr %arg_2)
  store ptr %arg_2, ptr %arg_0, align 8
  ret void
}

attributes #0 = { nofree nounwind }
"
`;

exports[`data structures compilation > tuple > stderr 1`] = `[]`;

exports[`data structures compilation > tuple > stdout 1`] = `
[
  "tuple(1, ab)",
]
`;

exports[`data structures compilation > unit > compiled 1`] = `
"@const_0 = constant i64 0
@const_1 = constant [5 x i8] c"unit\\00"
@symbols_metadata_array = constant [1 x { i8* }] [{ i8* } { i8* @const_1 }]
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_11 = alloca {  }
    %var_12 = load {  }, ptr %var_11
    store {  } %var_12, ptr %var_11
    %var_23 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_24 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_23
    %var_25 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_24, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_26 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_25, {  } %var_12, 1
    store { void (i64*, {  }, i64)*, {  } } %var_26, ptr %var_23
    %var_27 = load i64, ptr @const_0
    %var_28 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_26, 0
    %var_29 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_26, 1
    %var_30 = alloca i64
    call void %var_28(i64* %var_30, {  } %var_29, i64 %var_27)
    %var_31 = load i64, ptr %var_30
    ret i32 0
}
define void @"generated_print_symbol"(ptr sret(i64) %arg_0, {  } %arg_1, i64 %arg_2) {
  entry_0: 
    %var_13 = alloca {  }
    %var_14 = load {  }, ptr %var_13
    store {  } %var_14, ptr %var_13
    %var_15 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_16 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_15
    %var_17 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_16, void (i64*, {  }, i64)* @print_symbol_wrap, 0
    %var_18 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_17, {  } %var_14, 1
    store { void (i64*, {  }, i64)*, {  } } %var_18, ptr %var_15
    %var_19 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_18, 0
    %var_20 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_18, 1
    %var_21 = alloca i64
    call void %var_19(i64* %var_21, {  } %var_20, i64 %arg_2)
    %var_22 = load i64, ptr %var_21
    store i64 %arg_2, ptr %arg_0
    ret void
}
declare void @print_symbol(i64)
define void @print_symbol_wrap(ptr sret(i64) %arg_0, {  } %arg_1, i64 %arg_2) {
  entry_0: 
    call void @print_symbol(i64 %arg_2)
    store i64 %arg_2, ptr %arg_0
    ret void
}
"
`;

exports[`data structures compilation > unit > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = local_unnamed_addr constant i64 0
@const_1 = constant [5 x i8] c"unit\\00"
@symbols_metadata_array = constant [1 x { ptr }] [{ ptr } { ptr @const_1 }]
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @print_symbol(i64 0)
  ret i32 0
}

define void @generated_print_symbol(ptr nocapture writeonly sret(i64) %arg_0, {} %arg_1, i64 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @print_symbol(i64 %arg_2)
  store i64 %arg_2, ptr %arg_0, align 8
  ret void
}

declare void @print_symbol(i64) local_unnamed_addr

define void @print_symbol_wrap(ptr nocapture writeonly sret(i64) %arg_0, {} %arg_1, i64 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @print_symbol(i64 %arg_2)
  store i64 %arg_2, ptr %arg_0, align 8
  ret void
}
"
`;

exports[`data structures compilation > unit > stderr 1`] = `[]`;

exports[`data structures compilation > unit > stdout 1`] = `
[
  "symbol(unit)",
]
`;

exports[`generic print > compiled 1`] = `
"@const_0 = constant [4 x i8] c"fn[\\00"
@const_1 = constant [3 x i8] c"%s\\00"
@const_2 = constant [2 x i8] c"]\\00"
@const_3 = constant [2 x i8] c"
\\00"
@const_4 = constant [3 x i8] c"%i\\00"
@const_5 = constant i32 1
@const_6 = constant [7 x i8] c"tuple(\\00"
@const_7 = constant [3 x i8] c", \\00"
@const_8 = constant [2 x i8] c")\\00"
@const_9 = constant [3 x i8] c"ab\\00"
@const_10 = constant [3 x i8] c"%f\\00"
@const_11 = constant float 1.25
@const_12 = constant [5 x i8] c"true\\00"
@const_13 = constant [6 x i8] c"false\\00"
@const_14 = constant i1 1
@const_15 = constant i1 0
@const_16 = constant i64 0
@const_17 = constant i64 1
@const_18 = constant i64 2
@const_19 = constant [5 x i8] c"unit\\00"
@const_20 = constant [12 x i8] c"atom_atom_a\\00"
@const_21 = constant [16 x i8] c"symbol_symbol_a\\00"
@symbols_metadata_array = constant [3 x { i8* }] [{ i8* } { i8* @const_19 }, { i8* } { i8* @const_20 }, { i8* } { i8* @const_21 }]
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_91 = alloca {  }
    %var_92 = load {  }, ptr %var_91
    store {  } %var_92, ptr %var_91
    %var_94 = alloca { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } }
    %var_95 = load { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } }, ptr %var_94
    %var_96 = insertvalue { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_95, void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })* @"generated_print_i32[](i32)", 0
    %var_97 = insertvalue { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_96, {  } %var_92, 1
    store { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_97, ptr %var_94
    %var_99 = alloca {  }
    %var_100 = load {  }, ptr %var_99
    store {  } %var_100, ptr %var_99
    %var_101 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_102 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_101
    %var_103 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_102, void (i32*, {  }, i32)* @fn_98, 0
    %var_104 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_103, {  } %var_100, 1
    store { void (i32*, {  }, i32)*, {  } } %var_104, ptr %var_101
    %var_105 = extractvalue { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_97, 0
    %var_106 = extractvalue { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_97, 1
    %var_107 = alloca { void (i32*, {  }, i32)*, {  } }
    call void %var_105({ void (i32*, {  }, i32)*, {  } }* %var_107, {  } %var_106, { void (i32*, {  }, i32)*, {  } } %var_104)
    %var_108 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_107
    %var_109 = alloca {  }
    %var_110 = load {  }, ptr %var_109
    store {  } %var_110, ptr %var_109
    %var_111 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_112 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_111
    %var_113 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_112, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_114 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_113, {  } %var_110, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_114, ptr %var_111
    %var_115 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_114, 0
    %var_116 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_114, 1
    %var_117 = alloca i8*
    call void %var_115(i8** %var_117, {  } %var_116, i8* @const_3)
    %var_118 = load i8*, ptr %var_117
    %var_119 = alloca {  }
    %var_120 = load {  }, ptr %var_119
    store {  } %var_120, ptr %var_119
    %var_133 = alloca { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } }
    %var_134 = load { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } }, ptr %var_133
    %var_135 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } } %var_134, void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })* @"generated_print_i32[i32](i32)", 0
    %var_136 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } } %var_135, {  } %var_120, 1
    store { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } } %var_136, ptr %var_133
    %var_138 = alloca {  }
    %var_139 = load {  }, ptr %var_138
    store {  } %var_139, ptr %var_138
    %var_149 = alloca { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }
    %var_150 = load { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_149
    %var_151 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_150, void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)* @fn_137, 0
    %var_152 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_151, {  } %var_139, 1
    store { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_152, ptr %var_149
    %var_153 = load i32, ptr @const_5
    %var_154 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_152, 0
    %var_155 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_152, 1
    %var_156 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    call void %var_154({ void (i32*, { i32 }, i32)*, { i32 } }* %var_156, {  } %var_155, i32 %var_153)
    %var_157 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_156
    %var_158 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } } %var_136, 0
    %var_159 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } } %var_136, 1
    %var_160 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    call void %var_158({ void (i32*, { i32 }, i32)*, { i32 } }* %var_160, {  } %var_159, { void (i32*, { i32 }, i32)*, { i32 } } %var_157)
    %var_161 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_160
    %var_162 = alloca {  }
    %var_163 = load {  }, ptr %var_162
    store {  } %var_163, ptr %var_162
    %var_164 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_165 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_164
    %var_166 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_165, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_167 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_166, {  } %var_163, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_167, ptr %var_164
    %var_168 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_167, 0
    %var_169 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_167, 1
    %var_170 = alloca i8*
    call void %var_168(i8** %var_170, {  } %var_169, i8* @const_3)
    %var_171 = load i8*, ptr %var_170
    %var_172 = alloca {  }
    %var_173 = load {  }, ptr %var_172
    store {  } %var_173, ptr %var_172
    %var_175 = alloca { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } }
    %var_176 = load { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } }, ptr %var_175
    %var_177 = insertvalue { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_176, void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })* @"generated_print_i32[](i32, i32)", 0
    %var_178 = insertvalue { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_177, {  } %var_173, 1
    store { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_178, ptr %var_175
    %var_180 = alloca {  }
    %var_181 = load {  }, ptr %var_180
    store {  } %var_181, ptr %var_180
    %var_182 = alloca { void (i32*, {  }, i32, i32)*, {  } }
    %var_183 = load { void (i32*, {  }, i32, i32)*, {  } }, ptr %var_182
    %var_184 = insertvalue { void (i32*, {  }, i32, i32)*, {  } } %var_183, void (i32*, {  }, i32, i32)* @fn_179, 0
    %var_185 = insertvalue { void (i32*, {  }, i32, i32)*, {  } } %var_184, {  } %var_181, 1
    store { void (i32*, {  }, i32, i32)*, {  } } %var_185, ptr %var_182
    %var_186 = extractvalue { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_178, 0
    %var_187 = extractvalue { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_178, 1
    %var_188 = alloca { void (i32*, {  }, i32, i32)*, {  } }
    call void %var_186({ void (i32*, {  }, i32, i32)*, {  } }* %var_188, {  } %var_187, { void (i32*, {  }, i32, i32)*, {  } } %var_185)
    %var_189 = load { void (i32*, {  }, i32, i32)*, {  } }, ptr %var_188
    %var_190 = alloca {  }
    %var_191 = load {  }, ptr %var_190
    store {  } %var_191, ptr %var_190
    %var_192 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_193 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_192
    %var_194 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_193, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_195 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_194, {  } %var_191, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_195, ptr %var_192
    %var_196 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_195, 0
    %var_197 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_195, 1
    %var_198 = alloca i8*
    call void %var_196(i8** %var_198, {  } %var_197, i8* @const_3)
    %var_199 = load i8*, ptr %var_198
    %var_200 = alloca {  }
    %var_201 = load {  }, ptr %var_200
    store {  } %var_201, ptr %var_200
    %var_224 = alloca { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } }
    %var_225 = load { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } }, ptr %var_224
    %var_226 = insertvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_225, void ({ i32, i8* }*, {  }, { i32, i8* })* @"generated_print_(i32, i8*)", 0
    %var_227 = insertvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_226, {  } %var_201, 1
    store { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_227, ptr %var_224
    %var_228 = load i32, ptr @const_5
    %var_229 = alloca { i32 }
    %var_230 = load { i32 }, ptr %var_229
    %var_231 = insertvalue { i32 } %var_230, i32 %var_228, 0
    store { i32 } %var_231, ptr %var_229
    %var_232 = extractvalue { i32 } %var_231, 0
    %var_233 = alloca { i32, [3 x i8]* }
    %var_234 = load { i32, [3 x i8]* }, ptr %var_233
    %var_235 = insertvalue { i32, [3 x i8]* } %var_234, i32 %var_232, 0
    %var_236 = insertvalue { i32, [3 x i8]* } %var_235, [3 x i8]* @const_9, 1
    store { i32, [3 x i8]* } %var_236, ptr %var_233
    %var_237 = extractvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_227, 0
    %var_238 = extractvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_227, 1
    %var_239 = alloca { i32, i8* }
    call void %var_237({ i32, i8* }* %var_239, {  } %var_238, { i32, i8* } %var_236)
    %var_240 = load { i32, i8* }, ptr %var_239
    %var_241 = alloca {  }
    %var_242 = load {  }, ptr %var_241
    store {  } %var_242, ptr %var_241
    %var_243 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_244 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_243
    %var_245 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_244, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_246 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_245, {  } %var_242, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_246, ptr %var_243
    %var_247 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_246, 0
    %var_248 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_246, 1
    %var_249 = alloca i8*
    call void %var_247(i8** %var_249, {  } %var_248, i8* @const_3)
    %var_250 = load i8*, ptr %var_249
    %var_251 = alloca {  }
    %var_252 = load {  }, ptr %var_251
    store {  } %var_252, ptr %var_251
    %var_253 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_254 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_253
    %var_255 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_254, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_256 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_255, {  } %var_252, 1
    store { void (i32*, {  }, i32)*, {  } } %var_256, ptr %var_253
    %var_257 = load i32, ptr @const_5
    %var_258 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_256, 0
    %var_259 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_256, 1
    %var_260 = alloca i32
    call void %var_258(i32* %var_260, {  } %var_259, i32 %var_257)
    %var_261 = load i32, ptr %var_260
    %var_262 = alloca {  }
    %var_263 = load {  }, ptr %var_262
    store {  } %var_263, ptr %var_262
    %var_264 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_265 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_264
    %var_266 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_265, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_267 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_266, {  } %var_263, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_267, ptr %var_264
    %var_268 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_267, 0
    %var_269 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_267, 1
    %var_270 = alloca i8*
    call void %var_268(i8** %var_270, {  } %var_269, i8* @const_3)
    %var_271 = load i8*, ptr %var_270
    %var_272 = alloca {  }
    %var_273 = load {  }, ptr %var_272
    store {  } %var_273, ptr %var_272
    %var_274 = alloca { void (float*, {  }, float)*, {  } }
    %var_275 = load { void (float*, {  }, float)*, {  } }, ptr %var_274
    %var_276 = insertvalue { void (float*, {  }, float)*, {  } } %var_275, void (float*, {  }, float)* @"generated_print_f32", 0
    %var_277 = insertvalue { void (float*, {  }, float)*, {  } } %var_276, {  } %var_273, 1
    store { void (float*, {  }, float)*, {  } } %var_277, ptr %var_274
    %var_278 = load float, ptr @const_11
    %var_279 = extractvalue { void (float*, {  }, float)*, {  } } %var_277, 0
    %var_280 = extractvalue { void (float*, {  }, float)*, {  } } %var_277, 1
    %var_281 = alloca float
    call void %var_279(float* %var_281, {  } %var_280, float %var_278)
    %var_282 = load float, ptr %var_281
    %var_283 = alloca {  }
    %var_284 = load {  }, ptr %var_283
    store {  } %var_284, ptr %var_283
    %var_285 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_286 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_285
    %var_287 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_286, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_288 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_287, {  } %var_284, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_288, ptr %var_285
    %var_289 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_288, 0
    %var_290 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_288, 1
    %var_291 = alloca i8*
    call void %var_289(i8** %var_291, {  } %var_290, i8* @const_3)
    %var_292 = load i8*, ptr %var_291
    %var_293 = alloca {  }
    %var_294 = load {  }, ptr %var_293
    store {  } %var_294, ptr %var_293
    %var_295 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_296 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_295
    %var_297 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_296, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_298 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_297, {  } %var_294, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_298, ptr %var_295
    %var_299 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_298, 0
    %var_300 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_298, 1
    %var_301 = alloca i8*
    call void %var_299(i8** %var_301, {  } %var_300, i8* @const_9)
    %var_302 = load i8*, ptr %var_301
    %var_303 = alloca {  }
    %var_304 = load {  }, ptr %var_303
    store {  } %var_304, ptr %var_303
    %var_305 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_306 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_305
    %var_307 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_306, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_308 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_307, {  } %var_304, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_308, ptr %var_305
    %var_309 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_308, 0
    %var_310 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_308, 1
    %var_311 = alloca i8*
    call void %var_309(i8** %var_311, {  } %var_310, i8* @const_3)
    %var_312 = load i8*, ptr %var_311
    %var_313 = alloca {  }
    %var_314 = load {  }, ptr %var_313
    store {  } %var_314, ptr %var_313
    %var_316 = alloca { void (i1*, {  }, i1)*, {  } }
    %var_317 = load { void (i1*, {  }, i1)*, {  } }, ptr %var_316
    %var_318 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_317, void (i1*, {  }, i1)* @"generated_print_i1", 0
    %var_319 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_318, {  } %var_314, 1
    store { void (i1*, {  }, i1)*, {  } } %var_319, ptr %var_316
    %var_320 = load i1, ptr @const_14
    %var_321 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_319, 0
    %var_322 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_319, 1
    %var_323 = alloca i1
    call void %var_321(i1* %var_323, {  } %var_322, i1 %var_320)
    %var_324 = load i1, ptr %var_323
    %var_325 = alloca {  }
    %var_326 = load {  }, ptr %var_325
    store {  } %var_326, ptr %var_325
    %var_327 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_328 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_327
    %var_329 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_328, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_330 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_329, {  } %var_326, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_330, ptr %var_327
    %var_331 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_330, 0
    %var_332 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_330, 1
    %var_333 = alloca i8*
    call void %var_331(i8** %var_333, {  } %var_332, i8* @const_3)
    %var_334 = load i8*, ptr %var_333
    %var_335 = alloca {  }
    %var_336 = load {  }, ptr %var_335
    store {  } %var_336, ptr %var_335
    %var_337 = alloca { void (i1*, {  }, i1)*, {  } }
    %var_338 = load { void (i1*, {  }, i1)*, {  } }, ptr %var_337
    %var_339 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_338, void (i1*, {  }, i1)* @"generated_print_i1", 0
    %var_340 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_339, {  } %var_336, 1
    store { void (i1*, {  }, i1)*, {  } } %var_340, ptr %var_337
    %var_341 = load i1, ptr @const_15
    %var_342 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_340, 0
    %var_343 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_340, 1
    %var_344 = alloca i1
    call void %var_342(i1* %var_344, {  } %var_343, i1 %var_341)
    %var_345 = load i1, ptr %var_344
    %var_346 = alloca {  }
    %var_347 = load {  }, ptr %var_346
    store {  } %var_347, ptr %var_346
    %var_348 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_349 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_348
    %var_350 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_349, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_351 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_350, {  } %var_347, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_351, ptr %var_348
    %var_352 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_351, 0
    %var_353 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_351, 1
    %var_354 = alloca i8*
    call void %var_352(i8** %var_354, {  } %var_353, i8* @const_3)
    %var_355 = load i8*, ptr %var_354
    %var_356 = alloca {  }
    %var_357 = load {  }, ptr %var_356
    store {  } %var_357, ptr %var_356
    %var_368 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_369 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_368
    %var_370 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_369, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_371 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_370, {  } %var_357, 1
    store { void (i64*, {  }, i64)*, {  } } %var_371, ptr %var_368
    %var_372 = load i64, ptr @const_16
    %var_373 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_371, 0
    %var_374 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_371, 1
    %var_375 = alloca i64
    call void %var_373(i64* %var_375, {  } %var_374, i64 %var_372)
    %var_376 = load i64, ptr %var_375
    %var_377 = alloca {  }
    %var_378 = load {  }, ptr %var_377
    store {  } %var_378, ptr %var_377
    %var_379 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_380 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_379
    %var_381 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_380, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_382 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_381, {  } %var_378, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_382, ptr %var_379
    %var_383 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_382, 0
    %var_384 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_382, 1
    %var_385 = alloca i8*
    call void %var_383(i8** %var_385, {  } %var_384, i8* @const_3)
    %var_386 = load i8*, ptr %var_385
    %var_387 = alloca {  }
    %var_388 = load {  }, ptr %var_387
    store {  } %var_388, ptr %var_387
    %var_389 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_390 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_389
    %var_391 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_390, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_392 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_391, {  } %var_388, 1
    store { void (i64*, {  }, i64)*, {  } } %var_392, ptr %var_389
    %var_393 = load i64, ptr @const_17
    %var_394 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_392, 0
    %var_395 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_392, 1
    %var_396 = alloca i64
    call void %var_394(i64* %var_396, {  } %var_395, i64 %var_393)
    %var_397 = load i64, ptr %var_396
    %var_398 = alloca {  }
    %var_399 = load {  }, ptr %var_398
    store {  } %var_399, ptr %var_398
    %var_400 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_401 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_400
    %var_402 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_401, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_403 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_402, {  } %var_399, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_403, ptr %var_400
    %var_404 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_403, 0
    %var_405 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_403, 1
    %var_406 = alloca i8*
    call void %var_404(i8** %var_406, {  } %var_405, i8* @const_3)
    %var_407 = load i8*, ptr %var_406
    %var_408 = alloca {  }
    %var_409 = load {  }, ptr %var_408
    store {  } %var_409, ptr %var_408
    %var_410 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_411 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_410
    %var_412 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_411, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_413 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_412, {  } %var_409, 1
    store { void (i64*, {  }, i64)*, {  } } %var_413, ptr %var_410
    %var_414 = load i64, ptr @const_18
    %var_415 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_413, 0
    %var_416 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_413, 1
    %var_417 = alloca i64
    call void %var_415(i64* %var_417, {  } %var_416, i64 %var_414)
    %var_418 = load i64, ptr %var_417
    ret i32 0
}
define void @"generated_print_i32[](i32)"(ptr sret({ void (i32*, {  }, i32)*, {  } }) %arg_0, {  } %arg_1, { void (i32*, {  }, i32)*, {  } } %arg_2) {
  entry_0: 
    %var_93 = extractvalue { void (i32*, {  }, i32)*, {  } } %arg_2, 1
    call void @printf(i8* @const_1, [4 x i8]* @const_0)
    call void @printf(i8* @const_1, [2 x i8]* @const_2)
    store { void (i32*, {  }, i32)*, {  } } %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_98(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    store i32 %arg_2, ptr %arg_0
    ret void
}
define void @"generated_print_i8*"(ptr sret(i8*) %arg_0, {  } %arg_1, i8* %arg_2) {
  entry_0: 
    call void @printf(i8* @const_1, i8* %arg_2)
    store i8* %arg_2, ptr %arg_0
    ret void
}
define void @"generated_print_i32[i32](i32)"(ptr sret({ void (i32*, { i32 }, i32)*, { i32 } }) %arg_0, {  } %arg_1, { void (i32*, { i32 }, i32)*, { i32 } } %arg_2) {
  entry_0: 
    %var_121 = extractvalue { void (i32*, { i32 }, i32)*, { i32 } } %arg_2, 1
    call void @printf(i8* @const_1, [4 x i8]* @const_0)
    %var_122 = extractvalue { i32 } %var_121, 0
    %var_123 = alloca {  }
    %var_124 = load {  }, ptr %var_123
    store {  } %var_124, ptr %var_123
    %var_125 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_126 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_125
    %var_127 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_126, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_128 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_127, {  } %var_124, 1
    store { void (i32*, {  }, i32)*, {  } } %var_128, ptr %var_125
    %var_129 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_128, 0
    %var_130 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_128, 1
    %var_131 = alloca i32
    call void %var_129(i32* %var_131, {  } %var_130, i32 %var_122)
    %var_132 = load i32, ptr %var_131
    call void @printf(i8* @const_1, [2 x i8]* @const_2)
    store { void (i32*, { i32 }, i32)*, { i32 } } %arg_2, ptr %arg_0
    ret void
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_4, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
define void @fn_137(ptr sret({ void (i32*, { i32 }, i32)*, { i32 } }) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_141 = alloca { i32 }
    %var_142 = load { i32 }, ptr %var_141
    %var_143 = insertvalue { i32 } %var_142, i32 %arg_2, 0
    store { i32 } %var_143, ptr %var_141
    %var_145 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    %var_146 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_145
    %var_147 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_146, void (i32*, { i32 }, i32)* @fn_140, 0
    %var_148 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_147, { i32 } %var_143, 1
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_148, ptr %var_145
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_148, ptr %arg_0
    ret void
}
define void @fn_140(ptr sret(i32) %arg_0, { i32 } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_144 = extractvalue { i32 } %arg_1, 0
    store i32 %var_144, ptr %arg_0
    ret void
}
define void @"generated_print_i32[](i32, i32)"(ptr sret({ void (i32*, {  }, i32, i32)*, {  } }) %arg_0, {  } %arg_1, { void (i32*, {  }, i32, i32)*, {  } } %arg_2) {
  entry_0: 
    %var_174 = extractvalue { void (i32*, {  }, i32, i32)*, {  } } %arg_2, 1
    call void @printf(i8* @const_1, [4 x i8]* @const_0)
    call void @printf(i8* @const_1, [2 x i8]* @const_2)
    store { void (i32*, {  }, i32, i32)*, {  } } %arg_2, ptr %arg_0
    ret void
}
define void @fn_179(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2, i32 %arg_3) {
  entry_0: 
    store i32 %arg_2, ptr %arg_0
    ret void
}
define void @"generated_print_(i32, i8*)"(ptr sret({ i32, i8* }) %arg_0, {  } %arg_1, { i32, i8* } %arg_2) {
  entry_0: 
    call void @printf(i8* @const_1, [7 x i8]* @const_6)
    %var_202 = extractvalue { i32, i8* } %arg_2, 0
    %var_203 = alloca {  }
    %var_204 = load {  }, ptr %var_203
    store {  } %var_204, ptr %var_203
    %var_205 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_206 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_205
    %var_207 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_206, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_208 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_207, {  } %var_204, 1
    store { void (i32*, {  }, i32)*, {  } } %var_208, ptr %var_205
    %var_209 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_208, 0
    %var_210 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_208, 1
    %var_211 = alloca i32
    call void %var_209(i32* %var_211, {  } %var_210, i32 %var_202)
    %var_212 = load i32, ptr %var_211
    call void @printf(i8* @const_1, [3 x i8]* @const_7)
    %var_213 = extractvalue { i32, i8* } %arg_2, 1
    %var_214 = alloca {  }
    %var_215 = load {  }, ptr %var_214
    store {  } %var_215, ptr %var_214
    %var_216 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_217 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_216
    %var_218 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_217, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_219 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_218, {  } %var_215, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_219, ptr %var_216
    %var_220 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_219, 0
    %var_221 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_219, 1
    %var_222 = alloca i8*
    call void %var_220(i8** %var_222, {  } %var_221, i8* %var_213)
    %var_223 = load i8*, ptr %var_222
    call void @printf(i8* @const_1, [2 x i8]* @const_8)
    store { i32, i8* } %arg_2, ptr %arg_0
    ret void
}
define void @"generated_print_f32"(ptr sret(float) %arg_0, {  } %arg_1, float %arg_2) {
  entry_0: 
    call void @printf(i8* @const_10, float %arg_2)
    store float %arg_2, ptr %arg_0
    ret void
}
define void @"generated_print_i1"(ptr sret(i1) %arg_0, {  } %arg_1, i1 %arg_2) {
  entry_0: 
    %var_315 = select i1 %arg_2, [5 x i8]* @const_12, [5 x i8]* @const_13
    call void @printf(i8* @const_1, [5 x i8]* %var_315)
    store i1 %arg_2, ptr %arg_0
    ret void
}
define void @"generated_print_symbol"(ptr sret(i64) %arg_0, {  } %arg_1, i64 %arg_2) {
  entry_0: 
    %var_358 = alloca {  }
    %var_359 = load {  }, ptr %var_358
    store {  } %var_359, ptr %var_358
    %var_360 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_361 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_360
    %var_362 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_361, void (i64*, {  }, i64)* @print_symbol_wrap, 0
    %var_363 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_362, {  } %var_359, 1
    store { void (i64*, {  }, i64)*, {  } } %var_363, ptr %var_360
    %var_364 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_363, 0
    %var_365 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_363, 1
    %var_366 = alloca i64
    call void %var_364(i64* %var_366, {  } %var_365, i64 %arg_2)
    %var_367 = load i64, ptr %var_366
    store i64 %arg_2, ptr %arg_0
    ret void
}
declare void @print_symbol(i64)
define void @print_symbol_wrap(ptr sret(i64) %arg_0, {  } %arg_1, i64 %arg_2) {
  entry_0: 
    call void @print_symbol(i64 %arg_2)
    store i64 %arg_2, ptr %arg_0
    ret void
}
"
`;

exports[`generic print > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [4 x i8] c"fn[\\00"
@const_1 = constant [3 x i8] c"%s\\00"
@const_2 = constant [2 x i8] c"]\\00"
@const_3 = constant [2 x i8] c"\\0A\\00"
@const_4 = constant [3 x i8] c"%i\\00"
@const_5 = local_unnamed_addr constant i32 1
@const_6 = constant [7 x i8] c"tuple(\\00"
@const_7 = constant [3 x i8] c", \\00"
@const_8 = constant [2 x i8] c")\\00"
@const_9 = constant [3 x i8] c"ab\\00"
@const_10 = constant [3 x i8] c"%f\\00"
@const_11 = local_unnamed_addr constant float 1.250000e+00
@const_12 = constant [5 x i8] c"true\\00"
@const_13 = constant [6 x i8] c"false\\00"
@const_14 = local_unnamed_addr constant i1 true
@const_15 = local_unnamed_addr constant i1 false
@const_16 = local_unnamed_addr constant i64 0
@const_17 = local_unnamed_addr constant i64 1
@const_18 = local_unnamed_addr constant i64 2
@const_19 = constant [5 x i8] c"unit\\00"
@const_20 = constant [12 x i8] c"atom_atom_a\\00"
@const_21 = constant [16 x i8] c"symbol_symbol_a\\00"
@symbols_metadata_array = constant [3 x { ptr }] [{ ptr } { ptr @const_19 }, { ptr } { ptr @const_20 }, { ptr } { ptr @const_21 }]
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_0)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_2)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_3)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_0)
  tail call void @printf(ptr nonnull @const_4, i32 1)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_2)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_3)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_0)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_2)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_3)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_6)
  tail call void @printf(ptr nonnull @const_4, i32 1)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_7)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_9)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_8)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_3)
  tail call void @printf(ptr nonnull @const_4, i32 1)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_3)
  tail call void @printf(ptr nonnull @const_10, float 1.250000e+00)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_3)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_9)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_3)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_12)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_3)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_13)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_3)
  tail call void @print_symbol(i64 0)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_3)
  tail call void @print_symbol(i64 1)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_3)
  tail call void @print_symbol(i64 2)
  ret i32 0
}

define void @"generated_print_i32[](i32)"(ptr nocapture writeonly sret({ ptr, {} }) %arg_0, {} %arg_1, { ptr, {} } %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_0)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_2)
  %arg_2.elt = extractvalue { ptr, {} } %arg_2, 0
  store ptr %arg_2.elt, ptr %arg_0, align 8
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_98(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

define void @"generated_print_i8*"(ptr nocapture writeonly sret(ptr) %arg_0, {} %arg_1, ptr %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_1, ptr %arg_2)
  store ptr %arg_2, ptr %arg_0, align 8
  ret void
}

define void @"generated_print_i32[i32](i32)"(ptr nocapture writeonly sret({ ptr, { i32 } }) %arg_0, {} %arg_1, { ptr, { i32 } } %arg_2) local_unnamed_addr {
entry_0:
  %var_121 = extractvalue { ptr, { i32 } } %arg_2, 1
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_0)
  %var_122 = extractvalue { i32 } %var_121, 0
  tail call void @printf(ptr nonnull @const_4, i32 %var_122)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_2)
  store { ptr, { i32 } } %arg_2, ptr %arg_0, align 8
  ret void
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_4, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_137(ptr nocapture writeonly sret({ ptr, { i32 } }) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  %var_143 = insertvalue { i32 } undef, i32 %arg_2, 0
  %var_148 = insertvalue { ptr, { i32 } } { ptr @fn_140, { i32 } undef }, { i32 } %var_143, 1
  store { ptr, { i32 } } %var_148, ptr %arg_0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_140(ptr nocapture writeonly sret(i32) %arg_0, { i32 } %arg_1, i32 %arg_2) #1 {
entry_0:
  %var_144 = extractvalue { i32 } %arg_1, 0
  store i32 %var_144, ptr %arg_0, align 4
  ret void
}

define void @"generated_print_i32[](i32, i32)"(ptr nocapture writeonly sret({ ptr, {} }) %arg_0, {} %arg_1, { ptr, {} } %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_0)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_2)
  %arg_2.elt = extractvalue { ptr, {} } %arg_2, 0
  store ptr %arg_2.elt, ptr %arg_0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_179(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2, i32 %arg_3) local_unnamed_addr #1 {
entry_0:
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

define void @"generated_print_(i32, i8*)"(ptr nocapture writeonly sret({ i32, ptr }) %arg_0, {} %arg_1, { i32, ptr } %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_6)
  %var_202 = extractvalue { i32, ptr } %arg_2, 0
  tail call void @printf(ptr nonnull @const_4, i32 %var_202)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_7)
  %var_213 = extractvalue { i32, ptr } %arg_2, 1
  tail call void @printf(ptr nonnull @const_1, ptr %var_213)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_8)
  store { i32, ptr } %arg_2, ptr %arg_0, align 8
  ret void
}

define void @generated_print_f32(ptr nocapture writeonly sret(float) %arg_0, {} %arg_1, float %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_10, float %arg_2)
  store float %arg_2, ptr %arg_0, align 4
  ret void
}

define void @generated_print_i1(ptr nocapture writeonly sret(i1) %arg_0, {} %arg_1, i1 %arg_2) local_unnamed_addr {
entry_0:
  %var_315 = select i1 %arg_2, ptr @const_12, ptr @const_13
  tail call void @printf(ptr nonnull @const_1, ptr nonnull %var_315)
  store i1 %arg_2, ptr %arg_0, align 1
  ret void
}

define void @generated_print_symbol(ptr nocapture writeonly sret(i64) %arg_0, {} %arg_1, i64 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @print_symbol(i64 %arg_2)
  store i64 %arg_2, ptr %arg_0, align 8
  ret void
}

declare void @print_symbol(i64) local_unnamed_addr

define void @print_symbol_wrap(ptr nocapture writeonly sret(i64) %arg_0, {} %arg_1, i64 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @print_symbol(i64 %arg_2)
  store i64 %arg_2, ptr %arg_0, align 8
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`generic print > stderr 1`] = `[]`;

exports[`generic print > stdout 1`] = `
[
  "fn[]
fn[1]
fn[]
tuple(1, ab)
1
0.000000
ab
true
false
symbol(unit)
symbol(atom_atom_a)
symbol(symbol_symbol_a)",
]
`;

exports[`simply typed lambda calc compilation > apply > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = constant i32 2
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_23 = alloca {  }
    %var_24 = load {  }, ptr %var_23
    store {  } %var_24, ptr %var_23
    %var_25 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_26 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_25
    %var_27 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_26, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_28 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_27, {  } %var_24, 1
    store { void (i32*, {  }, i32)*, {  } } %var_28, ptr %var_25
    %var_30 = alloca {  }
    %var_31 = load {  }, ptr %var_30
    store {  } %var_31, ptr %var_30
    %var_45 = alloca { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } }
    %var_46 = load { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } }, ptr %var_45
    %var_47 = insertvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_46, void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })* @fn_29, 0
    %var_48 = insertvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_47, {  } %var_31, 1
    store { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_48, ptr %var_45
    %var_50 = alloca {  }
    %var_51 = load {  }, ptr %var_50
    store {  } %var_51, ptr %var_50
    %var_52 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_53 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_52
    %var_54 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_53, void (i32*, {  }, i32)* @fn_49, 0
    %var_55 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_54, {  } %var_51, 1
    store { void (i32*, {  }, i32)*, {  } } %var_55, ptr %var_52
    %var_56 = extractvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_48, 0
    %var_57 = extractvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_48, 1
    %var_58 = alloca { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }
    call void %var_56({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }* %var_58, {  } %var_57, { void (i32*, {  }, i32)*, {  } } %var_55)
    %var_59 = load { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }, ptr %var_58
    %var_60 = load i32, ptr @const_1
    %var_61 = extractvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_59, 0
    %var_62 = extractvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_59, 1
    %var_63 = alloca i32
    call void %var_61(i32* %var_63, { { void (i32*, {  }, i32)*, {  } } } %var_62, i32 %var_60)
    %var_64 = load i32, ptr %var_63
    %var_65 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_28, 0
    %var_66 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_28, 1
    %var_67 = alloca i32
    call void %var_65(i32* %var_67, {  } %var_66, i32 %var_64)
    %var_68 = load i32, ptr %var_67
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_29(ptr sret({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }) %arg_0, {  } %arg_1, { void (i32*, {  }, i32)*, {  } } %arg_2) {
  entry_0: 
    %var_33 = alloca { { void (i32*, {  }, i32)*, {  } } }
    %var_34 = load { { void (i32*, {  }, i32)*, {  } } }, ptr %var_33
    %var_35 = insertvalue { { void (i32*, {  }, i32)*, {  } } } %var_34, { void (i32*, {  }, i32)*, {  } } %arg_2, 0
    store { { void (i32*, {  }, i32)*, {  } } } %var_35, ptr %var_33
    %var_41 = alloca { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }
    %var_42 = load { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }, ptr %var_41
    %var_43 = insertvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_42, void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)* @fn_32, 0
    %var_44 = insertvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_43, { { void (i32*, {  }, i32)*, {  } } } %var_35, 1
    store { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_44, ptr %var_41
    store { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_44, ptr %arg_0
    ret void
}
define void @fn_32(ptr sret(i32) %arg_0, { { void (i32*, {  }, i32)*, {  } } } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_36 = extractvalue { { void (i32*, {  }, i32)*, {  } } } %arg_1, 0
    %var_37 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_36, 0
    %var_38 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_36, 1
    %var_39 = alloca i32
    call void %var_37(i32* %var_39, {  } %var_38, i32 %arg_2)
    %var_40 = load i32, ptr %var_39
    store i32 %var_40, ptr %arg_0
    ret void
}
define void @fn_49(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    store i32 %arg_2, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > apply > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = local_unnamed_addr constant i32 2
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, i32 2)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_29(ptr nocapture writeonly sret({ ptr, { { ptr, {} } } }) %arg_0, {} %arg_1, { ptr, {} } %arg_2) local_unnamed_addr #1 {
entry_0:
  store ptr @fn_32, ptr %arg_0, align 8
  %arg_0.repack1 = getelementptr inbounds { ptr, { { ptr, {} } } }, ptr %arg_0, i64 0, i32 1
  %arg_2.elt = extractvalue { ptr, {} } %arg_2, 0
  store ptr %arg_2.elt, ptr %arg_0.repack1, align 8
  ret void
}

define void @fn_32(ptr nocapture writeonly sret(i32) %arg_0, { { ptr, {} } } %arg_1, i32 %arg_2) {
entry_0:
  %var_36 = extractvalue { { ptr, {} } } %arg_1, 0
  %var_37 = extractvalue { ptr, {} } %var_36, 0
  %var_39 = alloca i32, align 4
  call void %var_37(ptr nonnull %var_39, {} zeroinitializer, i32 %arg_2)
  %var_40 = load i32, ptr %var_39, align 4
  store i32 %var_40, ptr %arg_0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_49(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > apply > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > apply > stdout 1`] = `
[
  "2",
]
`;

exports[`simply typed lambda calc compilation > church tuple > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = constant i32 1
@const_2 = constant i32 2
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_31 = alloca {  }
    %var_32 = load {  }, ptr %var_31
    store {  } %var_32, ptr %var_31
    %var_33 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_34 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_33
    %var_35 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_34, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_36 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_35, {  } %var_32, 1
    store { void (i32*, {  }, i32)*, {  } } %var_36, ptr %var_33
    %var_38 = alloca {  }
    %var_39 = load {  }, ptr %var_38
    store {  } %var_39, ptr %var_38
    %var_68 = alloca { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }
    %var_69 = load { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_68
    %var_70 = insertvalue { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_69, void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)* @fn_37, 0
    %var_71 = insertvalue { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_70, {  } %var_39, 1
    store { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_71, ptr %var_68
    %var_72 = load i32, ptr @const_1
    %var_73 = extractvalue { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_71, 0
    %var_74 = extractvalue { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_71, 1
    %var_75 = alloca { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }
    call void %var_73({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }* %var_75, {  } %var_74, i32 %var_72)
    %var_76 = load { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }, ptr %var_75
    %var_77 = load i32, ptr @const_2
    %var_78 = extractvalue { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_76, 0
    %var_79 = extractvalue { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_76, 1
    %var_80 = alloca { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }
    call void %var_78({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }* %var_80, { i32 } %var_79, i32 %var_77)
    %var_81 = load { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }, ptr %var_80
    %var_83 = alloca {  }
    %var_84 = load {  }, ptr %var_83
    store {  } %var_84, ptr %var_83
    %var_94 = alloca { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }
    %var_95 = load { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_94
    %var_96 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_95, void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)* @fn_82, 0
    %var_97 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_96, {  } %var_84, 1
    store { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_97, ptr %var_94
    %var_98 = extractvalue { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_81, 0
    %var_99 = extractvalue { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_81, 1
    %var_100 = alloca i32
    call void %var_98(i32* %var_100, { i32, i32 } %var_99, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_97)
    %var_101 = load i32, ptr %var_100
    %var_102 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_36, 0
    %var_103 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_36, 1
    %var_104 = alloca i32
    call void %var_102(i32* %var_104, {  } %var_103, i32 %var_101)
    %var_105 = load i32, ptr %var_104
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_37(ptr sret({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_41 = alloca { i32 }
    %var_42 = load { i32 }, ptr %var_41
    %var_43 = insertvalue { i32 } %var_42, i32 %arg_2, 0
    store { i32 } %var_43, ptr %var_41
    %var_64 = alloca { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }
    %var_65 = load { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }, ptr %var_64
    %var_66 = insertvalue { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_65, void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)* @fn_40, 0
    %var_67 = insertvalue { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_66, { i32 } %var_43, 1
    store { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_67, ptr %var_64
    store { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_67, ptr %arg_0
    ret void
}
define void @fn_40(ptr sret({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }) %arg_0, { i32 } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_44 = extractvalue { i32 } %arg_1, 0
    %var_46 = alloca { i32, i32 }
    %var_47 = load { i32, i32 }, ptr %var_46
    %var_48 = insertvalue { i32, i32 } %var_47, i32 %var_44, 0
    %var_49 = insertvalue { i32, i32 } %var_48, i32 %arg_2, 1
    store { i32, i32 } %var_49, ptr %var_46
    %var_60 = alloca { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }
    %var_61 = load { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }, ptr %var_60
    %var_62 = insertvalue { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_61, void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })* @fn_45, 0
    %var_63 = insertvalue { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_62, { i32, i32 } %var_49, 1
    store { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_63, ptr %var_60
    store { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_63, ptr %arg_0
    ret void
}
define void @fn_45(ptr sret(i32) %arg_0, { i32, i32 } %arg_1, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %arg_2) {
  entry_0: 
    %var_50 = extractvalue { i32, i32 } %arg_1, 0
    %var_51 = extractvalue { i32, i32 } %arg_1, 1
    %var_52 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %arg_2, 0
    %var_53 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %arg_2, 1
    %var_54 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    call void %var_52({ void (i32*, { i32 }, i32)*, { i32 } }* %var_54, {  } %var_53, i32 %var_50)
    %var_55 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_54
    %var_56 = extractvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_55, 0
    %var_57 = extractvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_55, 1
    %var_58 = alloca i32
    call void %var_56(i32* %var_58, { i32 } %var_57, i32 %var_51)
    %var_59 = load i32, ptr %var_58
    store i32 %var_59, ptr %arg_0
    ret void
}
define void @fn_82(ptr sret({ void (i32*, { i32 }, i32)*, { i32 } }) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_86 = alloca { i32 }
    %var_87 = load { i32 }, ptr %var_86
    %var_88 = insertvalue { i32 } %var_87, i32 %arg_2, 0
    store { i32 } %var_88, ptr %var_86
    %var_90 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    %var_91 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_90
    %var_92 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_91, void (i32*, { i32 }, i32)* @fn_85, 0
    %var_93 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_92, { i32 } %var_88, 1
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_93, ptr %var_90
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_93, ptr %arg_0
    ret void
}
define void @fn_85(ptr sret(i32) %arg_0, { i32 } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_89 = extractvalue { i32 } %arg_1, 0
    store i32 %var_89, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > church tuple > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = local_unnamed_addr constant i32 1
@const_2 = local_unnamed_addr constant i32 2
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, i32 1)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_37(ptr nocapture writeonly sret({ ptr, { i32 } }) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  %var_43 = insertvalue { i32 } undef, i32 %arg_2, 0
  %var_67 = insertvalue { ptr, { i32 } } { ptr @fn_40, { i32 } undef }, { i32 } %var_43, 1
  store { ptr, { i32 } } %var_67, ptr %arg_0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_40(ptr nocapture writeonly sret({ ptr, { i32, i32 } }) %arg_0, { i32 } %arg_1, i32 %arg_2) #1 {
entry_0:
  %var_44 = extractvalue { i32 } %arg_1, 0
  store ptr @fn_45, ptr %arg_0, align 8
  %arg_0.repack1 = getelementptr inbounds { ptr, { i32, i32 } }, ptr %arg_0, i64 0, i32 1
  store i32 %var_44, ptr %arg_0.repack1, align 8
  %arg_0.repack1.repack3 = getelementptr inbounds { ptr, { i32, i32 } }, ptr %arg_0, i64 0, i32 1, i32 1
  store i32 %arg_2, ptr %arg_0.repack1.repack3, align 4
  ret void
}

define void @fn_45(ptr nocapture writeonly sret(i32) %arg_0, { i32, i32 } %arg_1, { ptr, {} } %arg_2) {
entry_0:
  %var_50 = extractvalue { i32, i32 } %arg_1, 0
  %var_51 = extractvalue { i32, i32 } %arg_1, 1
  %var_52 = extractvalue { ptr, {} } %arg_2, 0
  %var_54 = alloca { ptr, { i32 } }, align 8
  call void %var_52(ptr nonnull %var_54, {} zeroinitializer, i32 %var_50)
  %var_55.fca.0.load = load ptr, ptr %var_54, align 8
  %var_55.fca.1.0.gep = getelementptr inbounds { ptr, { i32 } }, ptr %var_54, i64 0, i32 1, i32 0
  %var_55.fca.1.0.load = load i32, ptr %var_55.fca.1.0.gep, align 8
  %var_57 = insertvalue { i32 } poison, i32 %var_55.fca.1.0.load, 0
  %var_58 = alloca i32, align 4
  call void %var_55.fca.0.load(ptr nonnull %var_58, { i32 } %var_57, i32 %var_51)
  %var_59 = load i32, ptr %var_58, align 4
  store i32 %var_59, ptr %arg_0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_82(ptr nocapture writeonly sret({ ptr, { i32 } }) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  %var_88 = insertvalue { i32 } undef, i32 %arg_2, 0
  %var_93 = insertvalue { ptr, { i32 } } { ptr @fn_85, { i32 } undef }, { i32 } %var_88, 1
  store { ptr, { i32 } } %var_93, ptr %arg_0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_85(ptr nocapture writeonly sret(i32) %arg_0, { i32 } %arg_1, i32 %arg_2) #1 {
entry_0:
  %var_89 = extractvalue { i32 } %arg_1, 0
  store i32 %var_89, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > church tuple > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > church tuple > stdout 1`] = `
[
  "1",
]
`;

exports[`simply typed lambda calc compilation > church tuple 2 > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = constant i32 1
@const_2 = constant i32 2
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_24 = alloca {  }
    %var_25 = load {  }, ptr %var_24
    store {  } %var_25, ptr %var_24
    %var_26 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_27 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_26
    %var_28 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_27, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_29 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_28, {  } %var_25, 1
    store { void (i32*, {  }, i32)*, {  } } %var_29, ptr %var_26
    %var_31 = alloca {  }
    %var_32 = load {  }, ptr %var_31
    store {  } %var_32, ptr %var_31
    %var_37 = alloca { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } }
    %var_38 = load { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } }, ptr %var_37
    %var_39 = insertvalue { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_38, void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })* @fn_30, 0
    %var_40 = insertvalue { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_39, {  } %var_32, 1
    store { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_40, ptr %var_37
    %var_41 = load i32, ptr @const_1
    %var_42 = load i32, ptr @const_2
    %var_44 = alloca {  }
    %var_45 = load {  }, ptr %var_44
    store {  } %var_45, ptr %var_44
    %var_46 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_47 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_46
    %var_48 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_47, void (i32*, {  }, i32)* @fn_43, 0
    %var_49 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_48, {  } %var_45, 1
    store { void (i32*, {  }, i32)*, {  } } %var_49, ptr %var_46
    %var_50 = extractvalue { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_40, 0
    %var_51 = extractvalue { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_40, 1
    %var_52 = alloca i32
    call void %var_50(i32* %var_52, {  } %var_51, i32 %var_41, i32 %var_42, { void (i32*, {  }, i32, i32)*, {  } } %var_49)
    %var_53 = load i32, ptr %var_52
    %var_54 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_29, 0
    %var_55 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_29, 1
    %var_56 = alloca i32
    call void %var_54(i32* %var_56, {  } %var_55, i32 %var_53)
    %var_57 = load i32, ptr %var_56
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_30(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2, i32 %arg_3, { void (i32*, {  }, i32, i32)*, {  } } %arg_4) {
  entry_0: 
    %var_33 = extractvalue { void (i32*, {  }, i32, i32)*, {  } } %arg_4, 0
    %var_34 = extractvalue { void (i32*, {  }, i32, i32)*, {  } } %arg_4, 1
    %var_35 = alloca i32
    call void %var_33(i32* %var_35, {  } %var_34, i32 %arg_2, i32 %arg_3)
    %var_36 = load i32, ptr %var_35
    store i32 %var_36, ptr %arg_0
    ret void
}
define void @fn_43(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    store i32 %arg_2, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > church tuple 2 > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = local_unnamed_addr constant i32 1
@const_2 = local_unnamed_addr constant i32 2
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, i32 1)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

define void @fn_30(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2, i32 %arg_3, { ptr, {} } %arg_4) local_unnamed_addr {
entry_0:
  %var_33 = extractvalue { ptr, {} } %arg_4, 0
  %var_35 = alloca i32, align 4
  call void %var_33(ptr nonnull %var_35, {} zeroinitializer, i32 %arg_2, i32 %arg_3)
  %var_36 = load i32, ptr %var_35, align 4
  store i32 %var_36, ptr %arg_0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_43(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > church tuple 2 > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > church tuple 2 > stdout 1`] = `
[
  "1",
]
`;

exports[`simply typed lambda calc compilation > either > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_29 = alloca {  }
    %var_30 = load {  }, ptr %var_29
    store {  } %var_30, ptr %var_29
    %var_31 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_32 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_31
    %var_33 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_32, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_34 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_33, {  } %var_30, 1
    store { void (i32*, {  }, i32)*, {  } } %var_34, ptr %var_31
    %var_36 = alloca {  }
    %var_37 = load {  }, ptr %var_36
    store {  } %var_37, ptr %var_36
    %var_62 = alloca { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } }
    %var_63 = load { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_62
    %var_64 = insertvalue { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } } %var_63, void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)* @fn_35, 0
    %var_65 = insertvalue { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } } %var_64, {  } %var_37, 1
    store { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } } %var_65, ptr %var_62
    %var_66 = load i32, ptr @const_1
    %var_67 = extractvalue { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } } %var_65, 0
    %var_68 = extractvalue { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } } %var_65, 1
    %var_69 = alloca { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }
    call void %var_67({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }* %var_69, {  } %var_68, i32 %var_66)
    %var_70 = load { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }, ptr %var_69
    %var_72 = alloca {  }
    %var_73 = load {  }, ptr %var_72
    store {  } %var_73, ptr %var_72
    %var_74 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_75 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_74
    %var_76 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_75, void (i32*, {  }, i32)* @fn_71, 0
    %var_77 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_76, {  } %var_73, 1
    store { void (i32*, {  }, i32)*, {  } } %var_77, ptr %var_74
    %var_78 = extractvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_70, 0
    %var_79 = extractvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_70, 1
    %var_80 = alloca { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }
    call void %var_78({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }* %var_80, { i32 } %var_79, { void (i32*, {  }, i32)*, {  } } %var_77)
    %var_81 = load { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }, ptr %var_80
    %var_83 = alloca {  }
    %var_84 = load {  }, ptr %var_83
    store {  } %var_84, ptr %var_83
    %var_85 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_86 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_85
    %var_87 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_86, void (i32*, {  }, i32)* @fn_82, 0
    %var_88 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_87, {  } %var_84, 1
    store { void (i32*, {  }, i32)*, {  } } %var_88, ptr %var_85
    %var_89 = extractvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_81, 0
    %var_90 = extractvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_81, 1
    %var_91 = alloca i32
    call void %var_89(i32* %var_91, { { void (i32*, {  }, i32)*, {  } }, i32 } %var_90, { void (i32*, {  }, i32)*, {  } } %var_88)
    %var_92 = load i32, ptr %var_91
    %var_93 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_34, 0
    %var_94 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_34, 1
    %var_95 = alloca i32
    call void %var_93(i32* %var_95, {  } %var_94, i32 %var_92)
    %var_96 = load i32, ptr %var_95
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_35(ptr sret({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_39 = alloca { i32 }
    %var_40 = load { i32 }, ptr %var_39
    %var_41 = insertvalue { i32 } %var_40, i32 %arg_2, 0
    store { i32 } %var_41, ptr %var_39
    %var_58 = alloca { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }
    %var_59 = load { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }, ptr %var_58
    %var_60 = insertvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_59, void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })* @fn_38, 0
    %var_61 = insertvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_60, { i32 } %var_41, 1
    store { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_61, ptr %var_58
    store { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_61, ptr %arg_0
    ret void
}
define void @fn_38(ptr sret({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }) %arg_0, { i32 } %arg_1, { void (i32*, {  }, i32)*, {  } } %arg_2) {
  entry_0: 
    %var_42 = extractvalue { i32 } %arg_1, 0
    %var_44 = alloca { { void (i32*, {  }, i32)*, {  } }, i32 }
    %var_45 = load { { void (i32*, {  }, i32)*, {  } }, i32 }, ptr %var_44
    %var_46 = insertvalue { { void (i32*, {  }, i32)*, {  } }, i32 } %var_45, { void (i32*, {  }, i32)*, {  } } %arg_2, 0
    %var_47 = insertvalue { { void (i32*, {  }, i32)*, {  } }, i32 } %var_46, i32 %var_42, 1
    store { { void (i32*, {  }, i32)*, {  } }, i32 } %var_47, ptr %var_44
    %var_54 = alloca { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }
    %var_55 = load { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }, ptr %var_54
    %var_56 = insertvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_55, void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })* @fn_43, 0
    %var_57 = insertvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_56, { { void (i32*, {  }, i32)*, {  } }, i32 } %var_47, 1
    store { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_57, ptr %var_54
    store { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_57, ptr %arg_0
    ret void
}
define void @fn_43(ptr sret(i32) %arg_0, { { void (i32*, {  }, i32)*, {  } }, i32 } %arg_1, { void (i32*, {  }, i32)*, {  } } %arg_2) {
  entry_0: 
    %var_48 = extractvalue { { void (i32*, {  }, i32)*, {  } }, i32 } %arg_1, 0
    %var_49 = extractvalue { { void (i32*, {  }, i32)*, {  } }, i32 } %arg_1, 1
    %var_50 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_48, 0
    %var_51 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_48, 1
    %var_52 = alloca i32
    call void %var_50(i32* %var_52, {  } %var_51, i32 %var_49)
    %var_53 = load i32, ptr %var_52
    store i32 %var_53, ptr %arg_0
    ret void
}
define void @fn_71(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    store i32 %arg_2, ptr %arg_0
    ret void
}
define void @fn_82(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    store i32 %arg_2, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > either > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, i32 1)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_35(ptr nocapture writeonly sret({ ptr, { i32 } }) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  %var_41 = insertvalue { i32 } undef, i32 %arg_2, 0
  %var_61 = insertvalue { ptr, { i32 } } { ptr @fn_38, { i32 } undef }, { i32 } %var_41, 1
  store { ptr, { i32 } } %var_61, ptr %arg_0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_38(ptr nocapture writeonly sret({ ptr, { { ptr, {} }, i32 } }) %arg_0, { i32 } %arg_1, { ptr, {} } %arg_2) #1 {
entry_0:
  %var_42 = extractvalue { i32 } %arg_1, 0
  %var_46 = insertvalue { { ptr, {} }, i32 } { { ptr, {} } { ptr undef, {} poison }, i32 undef }, { ptr, {} } %arg_2, 0
  %var_47 = insertvalue { { ptr, {} }, i32 } %var_46, i32 %var_42, 1
  store ptr @fn_43, ptr %arg_0, align 8
  %arg_0.repack1 = getelementptr inbounds { ptr, { { ptr, {} }, i32 } }, ptr %arg_0, i64 0, i32 1
  store { { ptr, {} }, i32 } %var_47, ptr %arg_0.repack1, align 8
  ret void
}

define void @fn_43(ptr nocapture writeonly sret(i32) %arg_0, { { ptr, {} }, i32 } %arg_1, { ptr, {} } %arg_2) {
entry_0:
  %var_48 = extractvalue { { ptr, {} }, i32 } %arg_1, 0
  %var_49 = extractvalue { { ptr, {} }, i32 } %arg_1, 1
  %var_50 = extractvalue { ptr, {} } %var_48, 0
  %var_52 = alloca i32, align 4
  call void %var_50(ptr nonnull %var_52, {} zeroinitializer, i32 %var_49)
  %var_53 = load i32, ptr %var_52, align 4
  store i32 %var_53, ptr %arg_0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_71(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_82(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > either > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > either > stdout 1`] = `
[
  "1",
]
`;

exports[`simply typed lambda calc compilation > either 2 > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_25 = alloca {  }
    %var_26 = load {  }, ptr %var_25
    store {  } %var_26, ptr %var_25
    %var_27 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_28 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_27
    %var_29 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_28, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_30 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_29, {  } %var_26, 1
    store { void (i32*, {  }, i32)*, {  } } %var_30, ptr %var_27
    %var_32 = alloca {  }
    %var_33 = load {  }, ptr %var_32
    store {  } %var_33, ptr %var_32
    %var_38 = alloca { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } }
    %var_39 = load { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } }, ptr %var_38
    %var_40 = insertvalue { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_39, void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })* @fn_31, 0
    %var_41 = insertvalue { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_40, {  } %var_33, 1
    store { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_41, ptr %var_38
    %var_42 = load i32, ptr @const_1
    %var_44 = alloca {  }
    %var_45 = load {  }, ptr %var_44
    store {  } %var_45, ptr %var_44
    %var_46 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_47 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_46
    %var_48 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_47, void (i32*, {  }, i32)* @fn_43, 0
    %var_49 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_48, {  } %var_45, 1
    store { void (i32*, {  }, i32)*, {  } } %var_49, ptr %var_46
    %var_51 = alloca {  }
    %var_52 = load {  }, ptr %var_51
    store {  } %var_52, ptr %var_51
    %var_53 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_54 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_53
    %var_55 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_54, void (i32*, {  }, i32)* @fn_50, 0
    %var_56 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_55, {  } %var_52, 1
    store { void (i32*, {  }, i32)*, {  } } %var_56, ptr %var_53
    %var_57 = extractvalue { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_41, 0
    %var_58 = extractvalue { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_41, 1
    %var_59 = alloca i32
    call void %var_57(i32* %var_59, {  } %var_58, i32 %var_42, { void (i32*, {  }, i32)*, {  } } %var_49, { void (i32*, {  }, i32)*, {  } } %var_56)
    %var_60 = load i32, ptr %var_59
    %var_61 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_30, 0
    %var_62 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_30, 1
    %var_63 = alloca i32
    call void %var_61(i32* %var_63, {  } %var_62, i32 %var_60)
    %var_64 = load i32, ptr %var_63
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_31(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2, { void (i32*, {  }, i32)*, {  } } %arg_3, { void (i32*, {  }, i32)*, {  } } %arg_4) {
  entry_0: 
    %var_34 = extractvalue { void (i32*, {  }, i32)*, {  } } %arg_3, 0
    %var_35 = extractvalue { void (i32*, {  }, i32)*, {  } } %arg_3, 1
    %var_36 = alloca i32
    call void %var_34(i32* %var_36, {  } %var_35, i32 %arg_2)
    %var_37 = load i32, ptr %var_36
    store i32 %var_37, ptr %arg_0
    ret void
}
define void @fn_43(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    store i32 %arg_2, ptr %arg_0
    ret void
}
define void @fn_50(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    store i32 %arg_2, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > either 2 > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, i32 1)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

define void @fn_31(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2, { ptr, {} } %arg_3, { ptr, {} } %arg_4) local_unnamed_addr {
entry_0:
  %var_34 = extractvalue { ptr, {} } %arg_3, 0
  %var_36 = alloca i32, align 4
  call void %var_34(ptr nonnull %var_36, {} zeroinitializer, i32 %arg_2)
  %var_37 = load i32, ptr %var_36, align 4
  store i32 %var_37, ptr %arg_0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_43(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_50(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > either 2 > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > either 2 > stdout 1`] = `
[
  "1",
]
`;

exports[`simply typed lambda calc compilation > function application and literal print > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = constant i32 2
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_17 = alloca {  }
    %var_18 = load {  }, ptr %var_17
    store {  } %var_18, ptr %var_17
    %var_19 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_20 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_19
    %var_21 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_20, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_22 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_21, {  } %var_18, 1
    store { void (i32*, {  }, i32)*, {  } } %var_22, ptr %var_19
    %var_24 = alloca {  }
    %var_25 = load {  }, ptr %var_24
    store {  } %var_25, ptr %var_24
    %var_27 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_28 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_27
    %var_29 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_28, void (i32*, {  }, i32)* @fn_23, 0
    %var_30 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_29, {  } %var_25, 1
    store { void (i32*, {  }, i32)*, {  } } %var_30, ptr %var_27
    %var_31 = load i32, ptr @const_1
    %var_32 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_30, 0
    %var_33 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_30, 1
    %var_34 = alloca i32
    call void %var_32(i32* %var_34, {  } %var_33, i32 %var_31)
    %var_35 = load i32, ptr %var_34
    %var_36 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_22, 0
    %var_37 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_22, 1
    %var_38 = alloca i32
    call void %var_36(i32* %var_38, {  } %var_37, i32 %var_35)
    %var_39 = load i32, ptr %var_38
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_23(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_26 = add i32 %arg_2, %arg_2
    store i32 %var_26, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > function application and literal print > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = local_unnamed_addr constant i32 2
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, i32 4)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_23(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  %var_26 = shl i32 %arg_2, 1
  store i32 %var_26, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > function application and literal print > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > function application and literal print > stdout 1`] = `
[
  "4",
]
`;

exports[`simply typed lambda calc compilation > function closure > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = constant i32 2
@const_2 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_23 = alloca {  }
    %var_24 = load {  }, ptr %var_23
    store {  } %var_24, ptr %var_23
    %var_25 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_26 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_25
    %var_27 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_26, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_28 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_27, {  } %var_24, 1
    store { void (i32*, {  }, i32)*, {  } } %var_28, ptr %var_25
    %var_30 = alloca {  }
    %var_31 = load {  }, ptr %var_30
    store {  } %var_31, ptr %var_30
    %var_44 = alloca { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }
    %var_45 = load { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_44
    %var_46 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_45, void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)* @fn_29, 0
    %var_47 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_46, {  } %var_31, 1
    store { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_47, ptr %var_44
    %var_48 = load i32, ptr @const_2
    %var_49 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_47, 0
    %var_50 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_47, 1
    %var_51 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    call void %var_49({ void (i32*, { i32 }, i32)*, { i32 } }* %var_51, {  } %var_50, i32 %var_48)
    %var_52 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_51
    %var_53 = load i32, ptr @const_1
    %var_54 = extractvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_52, 0
    %var_55 = extractvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_52, 1
    %var_56 = alloca i32
    call void %var_54(i32* %var_56, { i32 } %var_55, i32 %var_53)
    %var_57 = load i32, ptr %var_56
    %var_58 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_28, 0
    %var_59 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_28, 1
    %var_60 = alloca i32
    call void %var_58(i32* %var_60, {  } %var_59, i32 %var_57)
    %var_61 = load i32, ptr %var_60
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_29(ptr sret({ void (i32*, { i32 }, i32)*, { i32 } }) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_33 = alloca { i32 }
    %var_34 = load { i32 }, ptr %var_33
    %var_35 = insertvalue { i32 } %var_34, i32 %arg_2, 0
    store { i32 } %var_35, ptr %var_33
    %var_40 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    %var_41 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_40
    %var_42 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_41, void (i32*, { i32 }, i32)* @fn_32, 0
    %var_43 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_42, { i32 } %var_35, 1
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_43, ptr %var_40
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_43, ptr %arg_0
    ret void
}
define void @fn_32(ptr sret(i32) %arg_0, { i32 } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_36 = extractvalue { i32 } %arg_1, 0
    %var_37 = load i32, ptr @const_1
    %var_38 = mul i32 %var_37, %var_36
    %var_39 = add i32 %arg_2, %var_38
    store i32 %var_39, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > function closure > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = local_unnamed_addr constant i32 2
@const_2 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, i32 4)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_29(ptr nocapture writeonly sret({ ptr, { i32 } }) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  %var_35 = insertvalue { i32 } undef, i32 %arg_2, 0
  %var_43 = insertvalue { ptr, { i32 } } { ptr @fn_32, { i32 } undef }, { i32 } %var_35, 1
  store { ptr, { i32 } } %var_43, ptr %arg_0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_32(ptr nocapture writeonly sret(i32) %arg_0, { i32 } %arg_1, i32 %arg_2) #1 {
entry_0:
  %var_36 = extractvalue { i32 } %arg_1, 0
  %var_38 = shl i32 %var_36, 1
  %var_39 = add i32 %var_38, %arg_2
  store i32 %var_39, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > function closure > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > function closure > stdout 1`] = `
[
  "4",
]
`;

exports[`simply typed lambda calc compilation > function deep closure > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = constant i32 1
@const_2 = constant i32 3
@const_3 = constant i32 5
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_27 = alloca {  }
    %var_28 = load {  }, ptr %var_27
    store {  } %var_28, ptr %var_27
    %var_29 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_30 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_29
    %var_31 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_30, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_32 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_31, {  } %var_28, 1
    store { void (i32*, {  }, i32)*, {  } } %var_32, ptr %var_29
    %var_34 = alloca {  }
    %var_35 = load {  }, ptr %var_34
    store {  } %var_35, ptr %var_34
    %var_58 = alloca { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }
    %var_59 = load { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_58
    %var_60 = insertvalue { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_59, void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)* @fn_33, 0
    %var_61 = insertvalue { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_60, {  } %var_35, 1
    store { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_61, ptr %var_58
    %var_62 = load i32, ptr @const_1
    %var_63 = extractvalue { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_61, 0
    %var_64 = extractvalue { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_61, 1
    %var_65 = alloca { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }
    call void %var_63({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }* %var_65, {  } %var_64, i32 %var_62)
    %var_66 = load { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }, ptr %var_65
    %var_67 = load i32, ptr @const_2
    %var_68 = extractvalue { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_66, 0
    %var_69 = extractvalue { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_66, 1
    %var_70 = alloca { void (i32*, { i32, i32 }, i32)*, { i32, i32 } }
    call void %var_68({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }* %var_70, { i32 } %var_69, i32 %var_67)
    %var_71 = load { void (i32*, { i32, i32 }, i32)*, { i32, i32 } }, ptr %var_70
    %var_72 = load i32, ptr @const_3
    %var_73 = extractvalue { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_71, 0
    %var_74 = extractvalue { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_71, 1
    %var_75 = alloca i32
    call void %var_73(i32* %var_75, { i32, i32 } %var_74, i32 %var_72)
    %var_76 = load i32, ptr %var_75
    %var_77 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_32, 0
    %var_78 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_32, 1
    %var_79 = alloca i32
    call void %var_77(i32* %var_79, {  } %var_78, i32 %var_76)
    %var_80 = load i32, ptr %var_79
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_33(ptr sret({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_37 = alloca { i32 }
    %var_38 = load { i32 }, ptr %var_37
    %var_39 = insertvalue { i32 } %var_38, i32 %arg_2, 0
    store { i32 } %var_39, ptr %var_37
    %var_54 = alloca { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }
    %var_55 = load { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }, ptr %var_54
    %var_56 = insertvalue { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_55, void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)* @fn_36, 0
    %var_57 = insertvalue { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_56, { i32 } %var_39, 1
    store { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_57, ptr %var_54
    store { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_57, ptr %arg_0
    ret void
}
define void @fn_36(ptr sret({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }) %arg_0, { i32 } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_40 = extractvalue { i32 } %arg_1, 0
    %var_42 = alloca { i32, i32 }
    %var_43 = load { i32, i32 }, ptr %var_42
    %var_44 = insertvalue { i32, i32 } %var_43, i32 %var_40, 0
    %var_45 = insertvalue { i32, i32 } %var_44, i32 %arg_2, 1
    store { i32, i32 } %var_45, ptr %var_42
    %var_50 = alloca { void (i32*, { i32, i32 }, i32)*, { i32, i32 } }
    %var_51 = load { void (i32*, { i32, i32 }, i32)*, { i32, i32 } }, ptr %var_50
    %var_52 = insertvalue { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_51, void (i32*, { i32, i32 }, i32)* @fn_41, 0
    %var_53 = insertvalue { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_52, { i32, i32 } %var_45, 1
    store { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_53, ptr %var_50
    store { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_53, ptr %arg_0
    ret void
}
define void @fn_41(ptr sret(i32) %arg_0, { i32, i32 } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_46 = extractvalue { i32, i32 } %arg_1, 0
    %var_47 = extractvalue { i32, i32 } %arg_1, 1
    %var_48 = add i32 %var_47, %arg_2
    %var_49 = add i32 %var_46, %var_48
    store i32 %var_49, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > function deep closure > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = local_unnamed_addr constant i32 1
@const_2 = local_unnamed_addr constant i32 3
@const_3 = local_unnamed_addr constant i32 5
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, i32 9)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_33(ptr nocapture writeonly sret({ ptr, { i32 } }) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  %var_39 = insertvalue { i32 } undef, i32 %arg_2, 0
  %var_57 = insertvalue { ptr, { i32 } } { ptr @fn_36, { i32 } undef }, { i32 } %var_39, 1
  store { ptr, { i32 } } %var_57, ptr %arg_0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_36(ptr nocapture writeonly sret({ ptr, { i32, i32 } }) %arg_0, { i32 } %arg_1, i32 %arg_2) #1 {
entry_0:
  %var_40 = extractvalue { i32 } %arg_1, 0
  store ptr @fn_41, ptr %arg_0, align 8
  %arg_0.repack1 = getelementptr inbounds { ptr, { i32, i32 } }, ptr %arg_0, i64 0, i32 1
  store i32 %var_40, ptr %arg_0.repack1, align 8
  %arg_0.repack1.repack3 = getelementptr inbounds { ptr, { i32, i32 } }, ptr %arg_0, i64 0, i32 1, i32 1
  store i32 %arg_2, ptr %arg_0.repack1.repack3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_41(ptr nocapture writeonly sret(i32) %arg_0, { i32, i32 } %arg_1, i32 %arg_2) #1 {
entry_0:
  %var_46 = extractvalue { i32, i32 } %arg_1, 0
  %var_47 = extractvalue { i32, i32 } %arg_1, 1
  %var_48 = add i32 %var_47, %arg_2
  %var_49 = add i32 %var_48, %var_46
  store i32 %var_49, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > function deep closure > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > function deep closure > stdout 1`] = `
[
  "9",
]
`;

exports[`simply typed lambda calc compilation > function multiple args > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = constant i32 2
@const_2 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_21 = alloca {  }
    %var_22 = load {  }, ptr %var_21
    store {  } %var_22, ptr %var_21
    %var_23 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_24 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_23
    %var_25 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_24, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_26 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_25, {  } %var_22, 1
    store { void (i32*, {  }, i32)*, {  } } %var_26, ptr %var_23
    %var_28 = alloca {  }
    %var_29 = load {  }, ptr %var_28
    store {  } %var_29, ptr %var_28
    %var_33 = alloca { void (i32*, {  }, i32, i32)*, {  } }
    %var_34 = load { void (i32*, {  }, i32, i32)*, {  } }, ptr %var_33
    %var_35 = insertvalue { void (i32*, {  }, i32, i32)*, {  } } %var_34, void (i32*, {  }, i32, i32)* @fn_27, 0
    %var_36 = insertvalue { void (i32*, {  }, i32, i32)*, {  } } %var_35, {  } %var_29, 1
    store { void (i32*, {  }, i32, i32)*, {  } } %var_36, ptr %var_33
    %var_37 = load i32, ptr @const_2
    %var_38 = load i32, ptr @const_1
    %var_39 = extractvalue { void (i32*, {  }, i32, i32)*, {  } } %var_36, 0
    %var_40 = extractvalue { void (i32*, {  }, i32, i32)*, {  } } %var_36, 1
    %var_41 = alloca i32
    call void %var_39(i32* %var_41, {  } %var_40, i32 %var_37, i32 %var_38)
    %var_42 = load i32, ptr %var_41
    %var_43 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_26, 0
    %var_44 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_26, 1
    %var_45 = alloca i32
    call void %var_43(i32* %var_45, {  } %var_44, i32 %var_42)
    %var_46 = load i32, ptr %var_45
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_27(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2, i32 %arg_3) {
  entry_0: 
    %var_30 = load i32, ptr @const_1
    %var_31 = mul i32 %var_30, %arg_2
    %var_32 = add i32 %arg_3, %var_31
    store i32 %var_32, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > function multiple args > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = local_unnamed_addr constant i32 2
@const_2 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, i32 4)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_27(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2, i32 %arg_3) local_unnamed_addr #1 {
entry_0:
  %var_31 = shl i32 %arg_2, 1
  %var_32 = add i32 %var_31, %arg_3
  store i32 %var_32, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > function multiple args > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > function multiple args > stdout 1`] = `
[
  "4",
]
`;

exports[`simply typed lambda calc compilation > hello world > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%s\\00"
@const_1 = constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_11 = alloca {  }
    %var_12 = load {  }, ptr %var_11
    store {  } %var_12, ptr %var_11
    %var_13 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_14 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_13
    %var_15 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_14, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_16 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_15, {  } %var_12, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_16, ptr %var_13
    %var_17 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_16, 0
    %var_18 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_16, 1
    %var_19 = alloca i8*
    call void %var_17(i8** %var_19, {  } %var_18, i8* @const_1)
    %var_20 = load i8*, ptr %var_19
    ret i32 0
}
define void @"generated_print_i8*"(ptr sret(i8*) %arg_0, {  } %arg_1, i8* %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i8* %arg_2)
    store i8* %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`simply typed lambda calc compilation > hello world > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%s\\00"
@const_1 = constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, ptr nonnull @const_1)
  ret i32 0
}

define void @"generated_print_i8*"(ptr nocapture writeonly sret(ptr) %arg_0, {} %arg_1, ptr %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, ptr %arg_2)
  store ptr %arg_2, ptr %arg_0, align 8
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`simply typed lambda calc compilation > hello world > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > hello world > stdout 1`] = `
[
  "hello world!",
]
`;

exports[`simply typed lambda calc compilation > hello world string > compiled 1`] = `
"@const_0 = constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    ret i32 0
}
"
`;

exports[`simply typed lambda calc compilation > hello world string > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = local_unnamed_addr constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef i32 @main() local_unnamed_addr #0 {
main:
  ret i32 0
}

attributes #0 = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) }
"
`;

exports[`simply typed lambda calc compilation > hello world string > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > hello world string > stdout 1`] = `[]`;

exports[`simply typed lambda calc compilation > print number > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_11 = alloca {  }
    %var_12 = load {  }, ptr %var_11
    store {  } %var_12, ptr %var_11
    %var_13 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_14 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_13
    %var_15 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_14, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_16 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_15, {  } %var_12, 1
    store { void (i32*, {  }, i32)*, {  } } %var_16, ptr %var_13
    %var_17 = load i32, ptr @const_1
    %var_18 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_16, 0
    %var_19 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_16, 1
    %var_20 = alloca i32
    call void %var_18(i32* %var_20, {  } %var_19, i32 %var_17)
    %var_21 = load i32, ptr %var_20
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`simply typed lambda calc compilation > print number > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, i32 1)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`simply typed lambda calc compilation > print number > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > print number > stdout 1`] = `
[
  "1",
]
`;

exports[`structured programming compilation > block > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = constant i32 123
@const_2 = constant i32 234
@const_3 = constant i32 345
@const_4 = constant i32 456
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_16 = alloca {  }
    %var_17 = load {  }, ptr %var_16
    store {  } %var_17, ptr %var_16
    %var_18 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_19 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_18
    %var_20 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_19, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_21 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_20, {  } %var_17, 1
    store { void (i32*, {  }, i32)*, {  } } %var_21, ptr %var_18
    %var_22 = load i32, ptr @const_1
    %var_23 = load i32, ptr @const_2
    %var_24 = load i32, ptr @const_3
    %var_25 = load i32, ptr @const_4
    %var_26 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_21, 0
    %var_27 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_21, 1
    %var_28 = alloca i32
    call void %var_26(i32* %var_28, {  } %var_27, i32 %var_25)
    %var_29 = load i32, ptr %var_28
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > block > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = local_unnamed_addr constant i32 123
@const_2 = local_unnamed_addr constant i32 234
@const_3 = local_unnamed_addr constant i32 345
@const_4 = local_unnamed_addr constant i32 456
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, i32 456)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > block > stderr 1`] = `[]`;

exports[`structured programming compilation > block > stdout 1`] = `
[
  "456",
]
`;

exports[`structured programming compilation > block variable assingment > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = constant i32 123
@const_2 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_21 = alloca {  }
    %var_22 = load {  }, ptr %var_21
    store {  } %var_22, ptr %var_21
    %var_23 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_24 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_23
    %var_25 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_24, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_26 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_25, {  } %var_22, 1
    store { void (i32*, {  }, i32)*, {  } } %var_26, ptr %var_23
    %var_27 = load i32, ptr @const_1
    %var_28 = load i32, ptr @const_2
    %var_29 = add i32 %var_27, %var_28
    %var_30 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_26, 0
    %var_31 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_26, 1
    %var_32 = alloca i32
    call void %var_30(i32* %var_32, {  } %var_31, i32 %var_29)
    %var_33 = load i32, ptr %var_32
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > block variable assingment > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = local_unnamed_addr constant i32 123
@const_2 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, i32 124)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > block variable assingment > stderr 1`] = `[]`;

exports[`structured programming compilation > block variable assingment > stdout 1`] = `
[
  "124",
]
`;

exports[`structured programming compilation > block variable declaration > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = constant i32 123
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_16 = alloca {  }
    %var_17 = load {  }, ptr %var_16
    store {  } %var_17, ptr %var_16
    %var_18 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_19 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_18
    %var_20 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_19, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_21 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_20, {  } %var_17, 1
    store { void (i32*, {  }, i32)*, {  } } %var_21, ptr %var_18
    %var_22 = load i32, ptr @const_1
    %var_23 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_21, 0
    %var_24 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_21, 1
    %var_25 = alloca i32
    call void %var_23(i32* %var_25, {  } %var_24, i32 %var_22)
    %var_26 = load i32, ptr %var_25
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > block variable declaration > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = local_unnamed_addr constant i32 123
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, i32 123)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > block variable declaration > stderr 1`] = `[]`;

exports[`structured programming compilation > block variable declaration > stdout 1`] = `
[
  "123",
]
`;

exports[`structured programming compilation > block variable shadowing > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = constant i32 123
@const_2 = constant i32 234
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_19 = alloca {  }
    %var_20 = load {  }, ptr %var_19
    store {  } %var_20, ptr %var_19
    %var_21 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_22 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_21
    %var_23 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_22, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_24 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_23, {  } %var_20, 1
    store { void (i32*, {  }, i32)*, {  } } %var_24, ptr %var_21
    %var_25 = load i32, ptr @const_1
    %var_26 = load i32, ptr @const_2
    %var_27 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_24, 0
    %var_28 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_24, 1
    %var_29 = alloca i32
    call void %var_27(i32* %var_29, {  } %var_28, i32 %var_26)
    %var_30 = load i32, ptr %var_29
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > block variable shadowing > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = local_unnamed_addr constant i32 123
@const_2 = local_unnamed_addr constant i32 234
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, i32 234)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > block variable shadowing > stderr 1`] = `[]`;

exports[`structured programming compilation > block variable shadowing > stdout 1`] = `
[
  "234",
]
`;

exports[`structured programming compilation > hello world twice > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%s\\00"
@const_1 = constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_14 = alloca {  }
    %var_15 = load {  }, ptr %var_14
    store {  } %var_15, ptr %var_14
    %var_16 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_17 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_16
    %var_18 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_17, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_19 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_18, {  } %var_15, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_19, ptr %var_16
    %var_20 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_19, 0
    %var_21 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_19, 1
    %var_22 = alloca i8*
    call void %var_20(i8** %var_22, {  } %var_21, i8* @const_1)
    %var_23 = load i8*, ptr %var_22
    %var_24 = alloca {  }
    %var_25 = load {  }, ptr %var_24
    store {  } %var_25, ptr %var_24
    %var_26 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_27 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_26
    %var_28 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_27, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_29 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_28, {  } %var_25, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_29, ptr %var_26
    %var_30 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_29, 0
    %var_31 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_29, 1
    %var_32 = alloca i8*
    call void %var_30(i8** %var_32, {  } %var_31, i8* @const_1)
    %var_33 = load i8*, ptr %var_32
    ret i32 0
}
define void @"generated_print_i8*"(ptr sret(i8*) %arg_0, {  } %arg_1, i8* %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i8* %arg_2)
    store i8* %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > hello world twice > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%s\\00"
@const_1 = constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, ptr nonnull @const_1)
  tail call void @printf(ptr nonnull @const_0, ptr nonnull @const_1)
  ret i32 0
}

define void @"generated_print_i8*"(ptr nocapture writeonly sret(ptr) %arg_0, {} %arg_1, ptr %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, ptr %arg_2)
  store ptr %arg_2, ptr %arg_0, align 8
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > hello world twice > stderr 1`] = `[]`;

exports[`structured programming compilation > hello world twice > stdout 1`] = `
[
  "hello world!hello world!",
]
`;

exports[`structured programming compilation > if-then > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = constant i1 1
@const_2 = constant i32 123
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_15 = alloca {  }
    %var_16 = load {  }, ptr %var_15
    store {  } %var_16, ptr %var_15
    %var_17 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_18 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_17
    %var_19 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_18, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_20 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_19, {  } %var_16, 1
    store { void (i32*, {  }, i32)*, {  } } %var_20, ptr %var_17
    %var_21 = load i1, ptr @const_1
    br i1 %var_21, label %then_1, label %if_rest22
  then_1: 
    %var_23 = load i32, ptr @const_2
    br label %if_rest22
  if_rest22: 
    %var_24 = phi i32 [%var_23, %then_1], [undef, %main]
    %var_25 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_20, 0
    %var_26 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_20, 1
    %var_27 = alloca i32
    call void %var_25(i32* %var_27, {  } %var_26, i32 %var_24)
    %var_28 = load i32, ptr %var_27
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > if-then > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = local_unnamed_addr constant i1 true
@const_2 = local_unnamed_addr constant i32 123
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, i32 123)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > if-then > stderr 1`] = `[]`;

exports[`structured programming compilation > if-then > stdout 1`] = `
[
  "123",
]
`;

exports[`structured programming compilation > if-then-else > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = constant i1 0
@const_2 = constant i32 123
@const_3 = constant i32 456
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_18 = alloca {  }
    %var_19 = load {  }, ptr %var_18
    store {  } %var_19, ptr %var_18
    %var_20 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_21 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_20
    %var_22 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_21, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_23 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_22, {  } %var_19, 1
    store { void (i32*, {  }, i32)*, {  } } %var_23, ptr %var_20
    %var_24 = load i1, ptr @const_1
    br i1 %var_24, label %then_1, label %else_2
  then_1: 
    %var_26 = load i32, ptr @const_2
    br label %if_rest25
  else_2: 
    %var_27 = load i32, ptr @const_3
    br label %if_rest25
  if_rest25: 
    %var_28 = phi i32 [%var_26, %then_1], [%var_27, %else_2]
    %var_29 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_23, 0
    %var_30 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_23, 1
    %var_31 = alloca i32
    call void %var_29(i32* %var_31, {  } %var_30, i32 %var_28)
    %var_32 = load i32, ptr %var_31
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > if-then-else > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = local_unnamed_addr constant i1 false
@const_2 = local_unnamed_addr constant i32 123
@const_3 = local_unnamed_addr constant i32 456
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, i32 456)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > if-then-else > stderr 1`] = `[]`;

exports[`structured programming compilation > if-then-else > stdout 1`] = `
[
  "456",
]
`;

exports[`structured programming compilation > sequence > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = constant i32 123
@const_2 = constant i32 234
@const_3 = constant i32 345
@const_4 = constant i32 456
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_15 = alloca {  }
    %var_16 = load {  }, ptr %var_15
    store {  } %var_16, ptr %var_15
    %var_17 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_18 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_17
    %var_19 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_18, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_20 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_19, {  } %var_16, 1
    store { void (i32*, {  }, i32)*, {  } } %var_20, ptr %var_17
    %var_21 = load i32, ptr @const_1
    %var_22 = load i32, ptr @const_2
    %var_23 = load i32, ptr @const_3
    %var_24 = load i32, ptr @const_4
    %var_25 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_20, 0
    %var_26 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_20, 1
    %var_27 = alloca i32
    call void %var_25(i32* %var_27, {  } %var_26, i32 %var_24)
    %var_28 = load i32, ptr %var_27
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > sequence > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = local_unnamed_addr constant i32 123
@const_2 = local_unnamed_addr constant i32 234
@const_3 = local_unnamed_addr constant i32 345
@const_4 = local_unnamed_addr constant i32 456
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, i32 456)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > sequence > stderr 1`] = `[]`;

exports[`structured programming compilation > sequence > stdout 1`] = `
[
  "456",
]
`;

exports[`structured programming compilation > two prints > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%s\\00"
@const_1 = constant [13 x i8] c"hello world!\\00"
@const_2 = constant [15 x i8] c"hello world 2!\\00"
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_14 = alloca {  }
    %var_15 = load {  }, ptr %var_14
    store {  } %var_15, ptr %var_14
    %var_16 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_17 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_16
    %var_18 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_17, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_19 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_18, {  } %var_15, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_19, ptr %var_16
    %var_20 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_19, 0
    %var_21 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_19, 1
    %var_22 = alloca i8*
    call void %var_20(i8** %var_22, {  } %var_21, i8* @const_1)
    %var_23 = load i8*, ptr %var_22
    %var_24 = alloca {  }
    %var_25 = load {  }, ptr %var_24
    store {  } %var_25, ptr %var_24
    %var_26 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_27 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_26
    %var_28 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_27, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_29 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_28, {  } %var_25, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_29, ptr %var_26
    %var_30 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_29, 0
    %var_31 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_29, 1
    %var_32 = alloca i8*
    call void %var_30(i8** %var_32, {  } %var_31, i8* @const_2)
    %var_33 = load i8*, ptr %var_32
    ret i32 0
}
define void @"generated_print_i8*"(ptr sret(i8*) %arg_0, {  } %arg_1, i8* %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i8* %arg_2)
    store i8* %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > two prints > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%s\\00"
@const_1 = constant [13 x i8] c"hello world!\\00"
@const_2 = constant [15 x i8] c"hello world 2!\\00"
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, ptr nonnull @const_1)
  tail call void @printf(ptr nonnull @const_0, ptr nonnull @const_2)
  ret i32 0
}

define void @"generated_print_i8*"(ptr nocapture writeonly sret(ptr) %arg_0, {} %arg_1, ptr %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, ptr %arg_2)
  store ptr %arg_2, ptr %arg_0, align 8
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > two prints > stderr 1`] = `[]`;

exports[`structured programming compilation > two prints > stdout 1`] = `
[
  "hello world!hello world 2!",
]
`;
