// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`data structures compilation > atom (global symbol) > compiled 1`] = `
"@const_31 = constant i64 0
@const_37 = constant [7 x i8] c"atom_a\\00"
@symbols_metadata_array = constant [1 x { i8* }] [{ i8* } { i8* @const_37 }]
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_7 = alloca {  }
    %var_8 = load {  }, ptr %var_7
    store {  } %var_8, ptr %var_7
    %var_27 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_28 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_27
    %var_29 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_28, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_30 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_29, {  } %var_8, 1
    store { void (i64*, {  }, i64)*, {  } } %var_30, ptr %var_27
    %var_32 = load i64, ptr @const_31
    %var_33 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_30, 0
    %var_34 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_30, 1
    %var_35 = alloca i64
    call void %var_33(i64* %var_35, {  } %var_34, i64 %var_32)
    %var_36 = load i64, ptr %var_35
    ret i32 0
}
define void @"generated_print_symbol"(ptr sret(i64) %var_9, {  } %var_10, i64 %var_11) {
  entry12: 
    %var_13 = alloca {  }
    %var_14 = load {  }, ptr %var_13
    store {  } %var_14, ptr %var_13
    %var_19 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_20 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_19
    %var_21 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_20, void (i64*, {  }, i64)* @print_symbol_wrap, 0
    %var_22 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_21, {  } %var_14, 1
    store { void (i64*, {  }, i64)*, {  } } %var_22, ptr %var_19
    %var_23 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_22, 0
    %var_24 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_22, 1
    %var_25 = alloca i64
    call void %var_23(i64* %var_25, {  } %var_24, i64 %var_11)
    %var_26 = load i64, ptr %var_25
    store i64 %var_11, ptr %var_9
    ret void
}
declare void @print_symbol(i64)
define void @print_symbol_wrap(ptr sret(i64) %var_15, {  } %var_16, i64 %var_17) {
  entry18: 
    call void @print_symbol(i64 %var_17)
    store i64 %var_17, ptr %var_15
    ret void
}
"
`;

exports[`data structures compilation > atom (global symbol) > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_31 = local_unnamed_addr constant i64 0
@const_37 = constant [7 x i8] c"atom_a\\00"
@symbols_metadata_array = constant [1 x { ptr }] [{ ptr } { ptr @const_37 }]
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @print_symbol(i64 0)
  ret i32 0
}

define void @generated_print_symbol(ptr nocapture writeonly sret(i64) %var_9, {} %var_10, i64 %var_11) local_unnamed_addr {
entry12:
  tail call void @print_symbol(i64 %var_11)
  store i64 %var_11, ptr %var_9, align 8
  ret void
}

declare void @print_symbol(i64) local_unnamed_addr

define void @print_symbol_wrap(ptr nocapture writeonly sret(i64) %var_15, {} %var_16, i64 %var_17) local_unnamed_addr {
entry18:
  tail call void @print_symbol(i64 %var_17)
  store i64 %var_17, ptr %var_15, align 8
  ret void
}
"
`;

exports[`data structures compilation > atom (global symbol) > stderr 1`] = `[]`;

exports[`data structures compilation > atom (global symbol) > stdout 1`] = `
[
  "symbol(atom_a)",
]
`;

exports[`data structures compilation > boolean false > compiled 1`] = `
"@const_13 = constant [5 x i8] c"true\\00"
@const_14 = constant [6 x i8] c"false\\00"
@const_16 = constant [3 x i8] c"%s\\00"
@const_21 = constant i1 0
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_7 = alloca {  }
    %var_8 = load {  }, ptr %var_7
    store {  } %var_8, ptr %var_7
    %var_17 = alloca { void (i1*, {  }, i1)*, {  } }
    %var_18 = load { void (i1*, {  }, i1)*, {  } }, ptr %var_17
    %var_19 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_18, void (i1*, {  }, i1)* @"generated_print_i1", 0
    %var_20 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_19, {  } %var_8, 1
    store { void (i1*, {  }, i1)*, {  } } %var_20, ptr %var_17
    %var_22 = load i1, ptr @const_21
    %var_23 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_20, 0
    %var_24 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_20, 1
    %var_25 = alloca i1
    call void %var_23(i1* %var_25, {  } %var_24, i1 %var_22)
    %var_26 = load i1, ptr %var_25
    ret i32 0
}
define void @"generated_print_i1"(ptr sret(i1) %var_9, {  } %var_10, i1 %var_11) {
  entry12: 
    %var_15 = select i1 %var_11, [5 x i8]* @const_13, [5 x i8]* @const_14
    call void @printf(i8* @const_16, [5 x i8]* %var_15)
    store i1 %var_11, ptr %var_9
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`data structures compilation > boolean false > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_13 = constant [5 x i8] c"true\\00"
@const_14 = constant [6 x i8] c"false\\00"
@const_16 = constant [3 x i8] c"%s\\00"
@const_21 = local_unnamed_addr constant i1 false
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_16, ptr nonnull @const_14)
  ret i32 0
}

define void @generated_print_i1(ptr nocapture writeonly sret(i1) %var_9, {} %var_10, i1 %var_11) local_unnamed_addr {
entry12:
  %var_15 = select i1 %var_11, ptr @const_13, ptr @const_14
  tail call void @printf(ptr nonnull @const_16, ptr nonnull %var_15)
  store i1 %var_11, ptr %var_9, align 1
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`data structures compilation > boolean false > stderr 1`] = `[]`;

exports[`data structures compilation > boolean false > stdout 1`] = `
[
  "false",
]
`;

exports[`data structures compilation > boolean true > compiled 1`] = `
"@const_13 = constant [5 x i8] c"true\\00"
@const_14 = constant [6 x i8] c"false\\00"
@const_16 = constant [3 x i8] c"%s\\00"
@const_21 = constant i1 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_7 = alloca {  }
    %var_8 = load {  }, ptr %var_7
    store {  } %var_8, ptr %var_7
    %var_17 = alloca { void (i1*, {  }, i1)*, {  } }
    %var_18 = load { void (i1*, {  }, i1)*, {  } }, ptr %var_17
    %var_19 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_18, void (i1*, {  }, i1)* @"generated_print_i1", 0
    %var_20 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_19, {  } %var_8, 1
    store { void (i1*, {  }, i1)*, {  } } %var_20, ptr %var_17
    %var_22 = load i1, ptr @const_21
    %var_23 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_20, 0
    %var_24 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_20, 1
    %var_25 = alloca i1
    call void %var_23(i1* %var_25, {  } %var_24, i1 %var_22)
    %var_26 = load i1, ptr %var_25
    ret i32 0
}
define void @"generated_print_i1"(ptr sret(i1) %var_9, {  } %var_10, i1 %var_11) {
  entry12: 
    %var_15 = select i1 %var_11, [5 x i8]* @const_13, [5 x i8]* @const_14
    call void @printf(i8* @const_16, [5 x i8]* %var_15)
    store i1 %var_11, ptr %var_9
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`data structures compilation > boolean true > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_13 = constant [5 x i8] c"true\\00"
@const_14 = constant [6 x i8] c"false\\00"
@const_16 = constant [3 x i8] c"%s\\00"
@const_21 = local_unnamed_addr constant i1 true
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_16, ptr nonnull @const_13)
  ret i32 0
}

define void @generated_print_i1(ptr nocapture writeonly sret(i1) %var_9, {} %var_10, i1 %var_11) local_unnamed_addr {
entry12:
  %var_15 = select i1 %var_11, ptr @const_13, ptr @const_14
  tail call void @printf(ptr nonnull @const_16, ptr nonnull %var_15)
  store i1 %var_11, ptr %var_9, align 1
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`data structures compilation > boolean true > stderr 1`] = `[]`;

exports[`data structures compilation > boolean true > stdout 1`] = `
[
  "true",
]
`;

exports[`data structures compilation > symbol > compiled 1`] = `
"@const_31 = constant i64 0
@const_37 = constant [10 x i8] c"symbol_ab\\00"
@symbols_metadata_array = constant [1 x { i8* }] [{ i8* } { i8* @const_37 }]
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_7 = alloca {  }
    %var_8 = load {  }, ptr %var_7
    store {  } %var_8, ptr %var_7
    %var_27 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_28 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_27
    %var_29 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_28, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_30 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_29, {  } %var_8, 1
    store { void (i64*, {  }, i64)*, {  } } %var_30, ptr %var_27
    %var_32 = load i64, ptr @const_31
    %var_33 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_30, 0
    %var_34 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_30, 1
    %var_35 = alloca i64
    call void %var_33(i64* %var_35, {  } %var_34, i64 %var_32)
    %var_36 = load i64, ptr %var_35
    ret i32 0
}
define void @"generated_print_symbol"(ptr sret(i64) %var_9, {  } %var_10, i64 %var_11) {
  entry12: 
    %var_13 = alloca {  }
    %var_14 = load {  }, ptr %var_13
    store {  } %var_14, ptr %var_13
    %var_19 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_20 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_19
    %var_21 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_20, void (i64*, {  }, i64)* @print_symbol_wrap, 0
    %var_22 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_21, {  } %var_14, 1
    store { void (i64*, {  }, i64)*, {  } } %var_22, ptr %var_19
    %var_23 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_22, 0
    %var_24 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_22, 1
    %var_25 = alloca i64
    call void %var_23(i64* %var_25, {  } %var_24, i64 %var_11)
    %var_26 = load i64, ptr %var_25
    store i64 %var_11, ptr %var_9
    ret void
}
declare void @print_symbol(i64)
define void @print_symbol_wrap(ptr sret(i64) %var_15, {  } %var_16, i64 %var_17) {
  entry18: 
    call void @print_symbol(i64 %var_17)
    store i64 %var_17, ptr %var_15
    ret void
}
"
`;

exports[`data structures compilation > symbol > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_31 = local_unnamed_addr constant i64 0
@const_37 = constant [10 x i8] c"symbol_ab\\00"
@symbols_metadata_array = constant [1 x { ptr }] [{ ptr } { ptr @const_37 }]
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @print_symbol(i64 0)
  ret i32 0
}

define void @generated_print_symbol(ptr nocapture writeonly sret(i64) %var_9, {} %var_10, i64 %var_11) local_unnamed_addr {
entry12:
  tail call void @print_symbol(i64 %var_11)
  store i64 %var_11, ptr %var_9, align 8
  ret void
}

declare void @print_symbol(i64) local_unnamed_addr

define void @print_symbol_wrap(ptr nocapture writeonly sret(i64) %var_15, {} %var_16, i64 %var_17) local_unnamed_addr {
entry18:
  tail call void @print_symbol(i64 %var_17)
  store i64 %var_17, ptr %var_15, align 8
  ret void
}
"
`;

exports[`data structures compilation > symbol > stderr 1`] = `[]`;

exports[`data structures compilation > symbol > stdout 1`] = `
[
  "symbol(symbol_ab)",
]
`;

exports[`data structures compilation > tuple > compiled 1`] = `
"@const_16 = constant [7 x i8] c"tuple(\\00"
@const_17 = constant [3 x i8] c"%s\\00"
@const_25 = constant [3 x i8] c"%i\\00"
@const_34 = constant [3 x i8] c", \\00"
@const_50 = constant [2 x i8] c")\\00"
@const_55 = constant i32 1
@const_60 = constant [3 x i8] c"ab\\00"
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_10 = alloca {  }
    %var_11 = load {  }, ptr %var_10
    store {  } %var_11, ptr %var_10
    %var_51 = alloca { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } }
    %var_52 = load { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } }, ptr %var_51
    %var_53 = insertvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_52, void ({ i32, i8* }*, {  }, { i32, i8* })* @"generated_print_(i32, i8*)", 0
    %var_54 = insertvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_53, {  } %var_11, 1
    store { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_54, ptr %var_51
    %var_56 = load i32, ptr @const_55
    %var_57 = alloca { i32 }
    %var_58 = load { i32 }, ptr %var_57
    %var_59 = insertvalue { i32 } %var_58, i32 %var_56, 0
    store { i32 } %var_59, ptr %var_57
    %var_61 = extractvalue { i32 } %var_59, 0
    %var_62 = alloca { i32, [3 x i8]* }
    %var_63 = load { i32, [3 x i8]* }, ptr %var_62
    %var_64 = insertvalue { i32, [3 x i8]* } %var_63, i32 %var_61, 0
    %var_65 = insertvalue { i32, [3 x i8]* } %var_64, [3 x i8]* @const_60, 1
    store { i32, [3 x i8]* } %var_65, ptr %var_62
    %var_66 = extractvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_54, 0
    %var_67 = extractvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_54, 1
    %var_68 = alloca { i32, i8* }
    call void %var_66({ i32, i8* }* %var_68, {  } %var_67, { i32, i8* } %var_65)
    %var_69 = load { i32, i8* }, ptr %var_68
    ret i32 0
}
define void @"generated_print_(i32, i8*)"(ptr sret({ i32, i8* }) %var_12, {  } %var_13, { i32, i8* } %var_14) {
  entry15: 
    call void @printf(i8* @const_17, [7 x i8]* @const_16)
    %var_18 = extractvalue { i32, i8* } %var_14, 0
    %var_19 = alloca {  }
    %var_20 = load {  }, ptr %var_19
    store {  } %var_20, ptr %var_19
    %var_26 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_27 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_26
    %var_28 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_27, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_29 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_28, {  } %var_20, 1
    store { void (i32*, {  }, i32)*, {  } } %var_29, ptr %var_26
    %var_30 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_29, 0
    %var_31 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_29, 1
    %var_32 = alloca i32
    call void %var_30(i32* %var_32, {  } %var_31, i32 %var_18)
    %var_33 = load i32, ptr %var_32
    call void @printf(i8* @const_17, [3 x i8]* @const_34)
    %var_35 = extractvalue { i32, i8* } %var_14, 1
    %var_36 = alloca {  }
    %var_37 = load {  }, ptr %var_36
    store {  } %var_37, ptr %var_36
    %var_42 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_43 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_42
    %var_44 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_43, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_45 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_44, {  } %var_37, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_45, ptr %var_42
    %var_46 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_45, 0
    %var_47 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_45, 1
    %var_48 = alloca i8*
    call void %var_46(i8** %var_48, {  } %var_47, i8* %var_35)
    %var_49 = load i8*, ptr %var_48
    call void @printf(i8* @const_17, [2 x i8]* @const_50)
    store { i32, i8* } %var_14, ptr %var_12
    ret void
}
declare i32 @printf(i8*, ...)
define void @"generated_print_i32"(ptr sret(i32) %var_21, {  } %var_22, i32 %var_23) {
  entry24: 
    call void @printf(i8* @const_25, i32 %var_23)
    store i32 %var_23, ptr %var_21
    ret void
}
define void @"generated_print_i8*"(ptr sret(i8*) %var_38, {  } %var_39, i8* %var_40) {
  entry41: 
    call void @printf(i8* @const_17, i8* %var_40)
    store i8* %var_40, ptr %var_38
    ret void
}
"
`;

exports[`data structures compilation > tuple > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_16 = constant [7 x i8] c"tuple(\\00"
@const_17 = constant [3 x i8] c"%s\\00"
@const_25 = constant [3 x i8] c"%i\\00"
@const_34 = constant [3 x i8] c", \\00"
@const_50 = constant [2 x i8] c")\\00"
@const_55 = local_unnamed_addr constant i32 1
@const_60 = constant [3 x i8] c"ab\\00"
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_17, ptr nonnull @const_16)
  tail call void @printf(ptr nonnull @const_25, i32 1)
  tail call void @printf(ptr nonnull @const_17, ptr nonnull @const_34)
  tail call void @printf(ptr nonnull @const_17, ptr nonnull @const_60)
  tail call void @printf(ptr nonnull @const_17, ptr nonnull @const_50)
  ret i32 0
}

define void @"generated_print_(i32, i8*)"(ptr nocapture writeonly sret({ i32, ptr }) %var_12, {} %var_13, { i32, ptr } %var_14) local_unnamed_addr {
entry15:
  tail call void @printf(ptr nonnull @const_17, ptr nonnull @const_16)
  %var_18 = extractvalue { i32, ptr } %var_14, 0
  tail call void @printf(ptr nonnull @const_25, i32 %var_18)
  tail call void @printf(ptr nonnull @const_17, ptr nonnull @const_34)
  %var_35 = extractvalue { i32, ptr } %var_14, 1
  tail call void @printf(ptr nonnull @const_17, ptr %var_35)
  tail call void @printf(ptr nonnull @const_17, ptr nonnull @const_50)
  store { i32, ptr } %var_14, ptr %var_12, align 8
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_21, {} %var_22, i32 %var_23) local_unnamed_addr {
entry24:
  tail call void @printf(ptr nonnull @const_25, i32 %var_23)
  store i32 %var_23, ptr %var_21, align 4
  ret void
}

define void @"generated_print_i8*"(ptr nocapture writeonly sret(ptr) %var_38, {} %var_39, ptr %var_40) local_unnamed_addr {
entry41:
  tail call void @printf(ptr nonnull @const_17, ptr %var_40)
  store ptr %var_40, ptr %var_38, align 8
  ret void
}

attributes #0 = { nofree nounwind }
"
`;

exports[`data structures compilation > tuple > stderr 1`] = `[]`;

exports[`data structures compilation > tuple > stdout 1`] = `
[
  "tuple(1, ab)",
]
`;

exports[`data structures compilation > unit > compiled 1`] = `
"@const_31 = constant i64 0
@const_37 = constant [5 x i8] c"unit\\00"
@symbols_metadata_array = constant [1 x { i8* }] [{ i8* } { i8* @const_37 }]
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_7 = alloca {  }
    %var_8 = load {  }, ptr %var_7
    store {  } %var_8, ptr %var_7
    %var_27 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_28 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_27
    %var_29 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_28, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_30 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_29, {  } %var_8, 1
    store { void (i64*, {  }, i64)*, {  } } %var_30, ptr %var_27
    %var_32 = load i64, ptr @const_31
    %var_33 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_30, 0
    %var_34 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_30, 1
    %var_35 = alloca i64
    call void %var_33(i64* %var_35, {  } %var_34, i64 %var_32)
    %var_36 = load i64, ptr %var_35
    ret i32 0
}
define void @"generated_print_symbol"(ptr sret(i64) %var_9, {  } %var_10, i64 %var_11) {
  entry12: 
    %var_13 = alloca {  }
    %var_14 = load {  }, ptr %var_13
    store {  } %var_14, ptr %var_13
    %var_19 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_20 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_19
    %var_21 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_20, void (i64*, {  }, i64)* @print_symbol_wrap, 0
    %var_22 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_21, {  } %var_14, 1
    store { void (i64*, {  }, i64)*, {  } } %var_22, ptr %var_19
    %var_23 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_22, 0
    %var_24 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_22, 1
    %var_25 = alloca i64
    call void %var_23(i64* %var_25, {  } %var_24, i64 %var_11)
    %var_26 = load i64, ptr %var_25
    store i64 %var_11, ptr %var_9
    ret void
}
declare void @print_symbol(i64)
define void @print_symbol_wrap(ptr sret(i64) %var_15, {  } %var_16, i64 %var_17) {
  entry18: 
    call void @print_symbol(i64 %var_17)
    store i64 %var_17, ptr %var_15
    ret void
}
"
`;

exports[`data structures compilation > unit > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_31 = local_unnamed_addr constant i64 0
@const_37 = constant [5 x i8] c"unit\\00"
@symbols_metadata_array = constant [1 x { ptr }] [{ ptr } { ptr @const_37 }]
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @print_symbol(i64 0)
  ret i32 0
}

define void @generated_print_symbol(ptr nocapture writeonly sret(i64) %var_9, {} %var_10, i64 %var_11) local_unnamed_addr {
entry12:
  tail call void @print_symbol(i64 %var_11)
  store i64 %var_11, ptr %var_9, align 8
  ret void
}

declare void @print_symbol(i64) local_unnamed_addr

define void @print_symbol_wrap(ptr nocapture writeonly sret(i64) %var_15, {} %var_16, i64 %var_17) local_unnamed_addr {
entry18:
  tail call void @print_symbol(i64 %var_17)
  store i64 %var_17, ptr %var_15, align 8
  ret void
}
"
`;

exports[`data structures compilation > unit > stderr 1`] = `[]`;

exports[`data structures compilation > unit > stdout 1`] = `
[
  "symbol(unit)",
]
`;

exports[`generic print > compiled 1`] = `
"@const_94 = constant [4 x i8] c"fn[\\00"
@const_95 = constant [3 x i8] c"%s\\00"
@const_96 = constant [2 x i8] c"]\\00"
@const_126 = constant [2 x i8] c"
\\00"
@const_145 = constant [3 x i8] c"%i\\00"
@const_182 = constant i32 1
@const_245 = constant [7 x i8] c"tuple(\\00"
@const_257 = constant [3 x i8] c", \\00"
@const_269 = constant [2 x i8] c")\\00"
@const_278 = constant [3 x i8] c"ab\\00"
@const_325 = constant [3 x i8] c"%f\\00"
@const_330 = constant float 1.25
@const_372 = constant [5 x i8] c"true\\00"
@const_373 = constant [6 x i8] c"false\\00"
@const_379 = constant i1 1
@const_401 = constant i1 0
@const_441 = constant i64 0
@const_463 = constant i64 1
@const_485 = constant i64 2
@const_491 = constant [5 x i8] c"unit\\00"
@const_492 = constant [12 x i8] c"atom_atom_a\\00"
@const_493 = constant [16 x i8] c"symbol_symbol_a\\00"
@symbols_metadata_array = constant [3 x { i8* }] [{ i8* } { i8* @const_491 }, { i8* } { i8* @const_492 }, { i8* } { i8* @const_493 }]
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_87 = alloca {  }
    %var_88 = load {  }, ptr %var_87
    store {  } %var_88, ptr %var_87
    %var_97 = alloca { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } }
    %var_98 = load { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } }, ptr %var_97
    %var_99 = insertvalue { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_98, void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })* @"generated_print_i32[](i32)", 0
    %var_100 = insertvalue { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_99, {  } %var_88, 1
    store { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_100, ptr %var_97
    %var_102 = alloca {  }
    %var_103 = load {  }, ptr %var_102
    store {  } %var_103, ptr %var_102
    %var_108 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_109 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_108
    %var_110 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_109, void (i32*, {  }, i32)* @fn_101, 0
    %var_111 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_110, {  } %var_103, 1
    store { void (i32*, {  }, i32)*, {  } } %var_111, ptr %var_108
    %var_112 = extractvalue { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_100, 0
    %var_113 = extractvalue { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_100, 1
    %var_114 = alloca { void (i32*, {  }, i32)*, {  } }
    call void %var_112({ void (i32*, {  }, i32)*, {  } }* %var_114, {  } %var_113, { void (i32*, {  }, i32)*, {  } } %var_111)
    %var_115 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_114
    %var_116 = alloca {  }
    %var_117 = load {  }, ptr %var_116
    store {  } %var_117, ptr %var_116
    %var_122 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_123 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_122
    %var_124 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_123, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_125 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_124, {  } %var_117, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_125, ptr %var_122
    %var_127 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_125, 0
    %var_128 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_125, 1
    %var_129 = alloca i8*
    call void %var_127(i8** %var_129, {  } %var_128, i8* @const_126)
    %var_130 = load i8*, ptr %var_129
    %var_131 = alloca {  }
    %var_132 = load {  }, ptr %var_131
    store {  } %var_132, ptr %var_131
    %var_154 = alloca { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } }
    %var_155 = load { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } }, ptr %var_154
    %var_156 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } } %var_155, void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })* @"generated_print_i32[i32](i32)", 0
    %var_157 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } } %var_156, {  } %var_132, 1
    store { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } } %var_157, ptr %var_154
    %var_159 = alloca {  }
    %var_160 = load {  }, ptr %var_159
    store {  } %var_160, ptr %var_159
    %var_178 = alloca { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }
    %var_179 = load { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_178
    %var_180 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_179, void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)* @fn_158, 0
    %var_181 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_180, {  } %var_160, 1
    store { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_181, ptr %var_178
    %var_183 = load i32, ptr @const_182
    %var_184 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_181, 0
    %var_185 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_181, 1
    %var_186 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    call void %var_184({ void (i32*, { i32 }, i32)*, { i32 } }* %var_186, {  } %var_185, i32 %var_183)
    %var_187 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_186
    %var_188 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } } %var_157, 0
    %var_189 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } } %var_157, 1
    %var_190 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    call void %var_188({ void (i32*, { i32 }, i32)*, { i32 } }* %var_190, {  } %var_189, { void (i32*, { i32 }, i32)*, { i32 } } %var_187)
    %var_191 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_190
    %var_192 = alloca {  }
    %var_193 = load {  }, ptr %var_192
    store {  } %var_193, ptr %var_192
    %var_194 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_195 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_194
    %var_196 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_195, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_197 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_196, {  } %var_193, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_197, ptr %var_194
    %var_198 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_197, 0
    %var_199 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_197, 1
    %var_200 = alloca i8*
    call void %var_198(i8** %var_200, {  } %var_199, i8* @const_126)
    %var_201 = load i8*, ptr %var_200
    %var_202 = alloca {  }
    %var_203 = load {  }, ptr %var_202
    store {  } %var_203, ptr %var_202
    %var_209 = alloca { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } }
    %var_210 = load { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } }, ptr %var_209
    %var_211 = insertvalue { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_210, void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })* @"generated_print_i32[](i32, i32)", 0
    %var_212 = insertvalue { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_211, {  } %var_203, 1
    store { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_212, ptr %var_209
    %var_214 = alloca {  }
    %var_215 = load {  }, ptr %var_214
    store {  } %var_215, ptr %var_214
    %var_221 = alloca { void (i32*, {  }, i32, i32)*, {  } }
    %var_222 = load { void (i32*, {  }, i32, i32)*, {  } }, ptr %var_221
    %var_223 = insertvalue { void (i32*, {  }, i32, i32)*, {  } } %var_222, void (i32*, {  }, i32, i32)* @fn_213, 0
    %var_224 = insertvalue { void (i32*, {  }, i32, i32)*, {  } } %var_223, {  } %var_215, 1
    store { void (i32*, {  }, i32, i32)*, {  } } %var_224, ptr %var_221
    %var_225 = extractvalue { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_212, 0
    %var_226 = extractvalue { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_212, 1
    %var_227 = alloca { void (i32*, {  }, i32, i32)*, {  } }
    call void %var_225({ void (i32*, {  }, i32, i32)*, {  } }* %var_227, {  } %var_226, { void (i32*, {  }, i32, i32)*, {  } } %var_224)
    %var_228 = load { void (i32*, {  }, i32, i32)*, {  } }, ptr %var_227
    %var_229 = alloca {  }
    %var_230 = load {  }, ptr %var_229
    store {  } %var_230, ptr %var_229
    %var_231 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_232 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_231
    %var_233 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_232, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_234 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_233, {  } %var_230, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_234, ptr %var_231
    %var_235 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_234, 0
    %var_236 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_234, 1
    %var_237 = alloca i8*
    call void %var_235(i8** %var_237, {  } %var_236, i8* @const_126)
    %var_238 = load i8*, ptr %var_237
    %var_239 = alloca {  }
    %var_240 = load {  }, ptr %var_239
    store {  } %var_240, ptr %var_239
    %var_270 = alloca { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } }
    %var_271 = load { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } }, ptr %var_270
    %var_272 = insertvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_271, void ({ i32, i8* }*, {  }, { i32, i8* })* @"generated_print_(i32, i8*)", 0
    %var_273 = insertvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_272, {  } %var_240, 1
    store { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_273, ptr %var_270
    %var_274 = load i32, ptr @const_182
    %var_275 = alloca { i32 }
    %var_276 = load { i32 }, ptr %var_275
    %var_277 = insertvalue { i32 } %var_276, i32 %var_274, 0
    store { i32 } %var_277, ptr %var_275
    %var_279 = extractvalue { i32 } %var_277, 0
    %var_280 = alloca { i32, [3 x i8]* }
    %var_281 = load { i32, [3 x i8]* }, ptr %var_280
    %var_282 = insertvalue { i32, [3 x i8]* } %var_281, i32 %var_279, 0
    %var_283 = insertvalue { i32, [3 x i8]* } %var_282, [3 x i8]* @const_278, 1
    store { i32, [3 x i8]* } %var_283, ptr %var_280
    %var_284 = extractvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_273, 0
    %var_285 = extractvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_273, 1
    %var_286 = alloca { i32, i8* }
    call void %var_284({ i32, i8* }* %var_286, {  } %var_285, { i32, i8* } %var_283)
    %var_287 = load { i32, i8* }, ptr %var_286
    %var_288 = alloca {  }
    %var_289 = load {  }, ptr %var_288
    store {  } %var_289, ptr %var_288
    %var_290 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_291 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_290
    %var_292 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_291, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_293 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_292, {  } %var_289, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_293, ptr %var_290
    %var_294 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_293, 0
    %var_295 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_293, 1
    %var_296 = alloca i8*
    call void %var_294(i8** %var_296, {  } %var_295, i8* @const_126)
    %var_297 = load i8*, ptr %var_296
    %var_298 = alloca {  }
    %var_299 = load {  }, ptr %var_298
    store {  } %var_299, ptr %var_298
    %var_300 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_301 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_300
    %var_302 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_301, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_303 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_302, {  } %var_299, 1
    store { void (i32*, {  }, i32)*, {  } } %var_303, ptr %var_300
    %var_304 = load i32, ptr @const_182
    %var_305 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_303, 0
    %var_306 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_303, 1
    %var_307 = alloca i32
    call void %var_305(i32* %var_307, {  } %var_306, i32 %var_304)
    %var_308 = load i32, ptr %var_307
    %var_309 = alloca {  }
    %var_310 = load {  }, ptr %var_309
    store {  } %var_310, ptr %var_309
    %var_311 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_312 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_311
    %var_313 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_312, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_314 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_313, {  } %var_310, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_314, ptr %var_311
    %var_315 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_314, 0
    %var_316 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_314, 1
    %var_317 = alloca i8*
    call void %var_315(i8** %var_317, {  } %var_316, i8* @const_126)
    %var_318 = load i8*, ptr %var_317
    %var_319 = alloca {  }
    %var_320 = load {  }, ptr %var_319
    store {  } %var_320, ptr %var_319
    %var_326 = alloca { void (float*, {  }, float)*, {  } }
    %var_327 = load { void (float*, {  }, float)*, {  } }, ptr %var_326
    %var_328 = insertvalue { void (float*, {  }, float)*, {  } } %var_327, void (float*, {  }, float)* @"generated_print_f32", 0
    %var_329 = insertvalue { void (float*, {  }, float)*, {  } } %var_328, {  } %var_320, 1
    store { void (float*, {  }, float)*, {  } } %var_329, ptr %var_326
    %var_331 = load float, ptr @const_330
    %var_332 = extractvalue { void (float*, {  }, float)*, {  } } %var_329, 0
    %var_333 = extractvalue { void (float*, {  }, float)*, {  } } %var_329, 1
    %var_334 = alloca float
    call void %var_332(float* %var_334, {  } %var_333, float %var_331)
    %var_335 = load float, ptr %var_334
    %var_336 = alloca {  }
    %var_337 = load {  }, ptr %var_336
    store {  } %var_337, ptr %var_336
    %var_338 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_339 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_338
    %var_340 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_339, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_341 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_340, {  } %var_337, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_341, ptr %var_338
    %var_342 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_341, 0
    %var_343 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_341, 1
    %var_344 = alloca i8*
    call void %var_342(i8** %var_344, {  } %var_343, i8* @const_126)
    %var_345 = load i8*, ptr %var_344
    %var_346 = alloca {  }
    %var_347 = load {  }, ptr %var_346
    store {  } %var_347, ptr %var_346
    %var_348 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_349 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_348
    %var_350 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_349, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_351 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_350, {  } %var_347, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_351, ptr %var_348
    %var_352 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_351, 0
    %var_353 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_351, 1
    %var_354 = alloca i8*
    call void %var_352(i8** %var_354, {  } %var_353, i8* @const_278)
    %var_355 = load i8*, ptr %var_354
    %var_356 = alloca {  }
    %var_357 = load {  }, ptr %var_356
    store {  } %var_357, ptr %var_356
    %var_358 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_359 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_358
    %var_360 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_359, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_361 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_360, {  } %var_357, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_361, ptr %var_358
    %var_362 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_361, 0
    %var_363 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_361, 1
    %var_364 = alloca i8*
    call void %var_362(i8** %var_364, {  } %var_363, i8* @const_126)
    %var_365 = load i8*, ptr %var_364
    %var_366 = alloca {  }
    %var_367 = load {  }, ptr %var_366
    store {  } %var_367, ptr %var_366
    %var_375 = alloca { void (i1*, {  }, i1)*, {  } }
    %var_376 = load { void (i1*, {  }, i1)*, {  } }, ptr %var_375
    %var_377 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_376, void (i1*, {  }, i1)* @"generated_print_i1", 0
    %var_378 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_377, {  } %var_367, 1
    store { void (i1*, {  }, i1)*, {  } } %var_378, ptr %var_375
    %var_380 = load i1, ptr @const_379
    %var_381 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_378, 0
    %var_382 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_378, 1
    %var_383 = alloca i1
    call void %var_381(i1* %var_383, {  } %var_382, i1 %var_380)
    %var_384 = load i1, ptr %var_383
    %var_385 = alloca {  }
    %var_386 = load {  }, ptr %var_385
    store {  } %var_386, ptr %var_385
    %var_387 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_388 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_387
    %var_389 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_388, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_390 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_389, {  } %var_386, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_390, ptr %var_387
    %var_391 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_390, 0
    %var_392 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_390, 1
    %var_393 = alloca i8*
    call void %var_391(i8** %var_393, {  } %var_392, i8* @const_126)
    %var_394 = load i8*, ptr %var_393
    %var_395 = alloca {  }
    %var_396 = load {  }, ptr %var_395
    store {  } %var_396, ptr %var_395
    %var_397 = alloca { void (i1*, {  }, i1)*, {  } }
    %var_398 = load { void (i1*, {  }, i1)*, {  } }, ptr %var_397
    %var_399 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_398, void (i1*, {  }, i1)* @"generated_print_i1", 0
    %var_400 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_399, {  } %var_396, 1
    store { void (i1*, {  }, i1)*, {  } } %var_400, ptr %var_397
    %var_402 = load i1, ptr @const_401
    %var_403 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_400, 0
    %var_404 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_400, 1
    %var_405 = alloca i1
    call void %var_403(i1* %var_405, {  } %var_404, i1 %var_402)
    %var_406 = load i1, ptr %var_405
    %var_407 = alloca {  }
    %var_408 = load {  }, ptr %var_407
    store {  } %var_408, ptr %var_407
    %var_409 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_410 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_409
    %var_411 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_410, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_412 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_411, {  } %var_408, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_412, ptr %var_409
    %var_413 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_412, 0
    %var_414 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_412, 1
    %var_415 = alloca i8*
    call void %var_413(i8** %var_415, {  } %var_414, i8* @const_126)
    %var_416 = load i8*, ptr %var_415
    %var_417 = alloca {  }
    %var_418 = load {  }, ptr %var_417
    store {  } %var_418, ptr %var_417
    %var_437 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_438 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_437
    %var_439 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_438, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_440 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_439, {  } %var_418, 1
    store { void (i64*, {  }, i64)*, {  } } %var_440, ptr %var_437
    %var_442 = load i64, ptr @const_441
    %var_443 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_440, 0
    %var_444 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_440, 1
    %var_445 = alloca i64
    call void %var_443(i64* %var_445, {  } %var_444, i64 %var_442)
    %var_446 = load i64, ptr %var_445
    %var_447 = alloca {  }
    %var_448 = load {  }, ptr %var_447
    store {  } %var_448, ptr %var_447
    %var_449 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_450 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_449
    %var_451 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_450, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_452 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_451, {  } %var_448, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_452, ptr %var_449
    %var_453 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_452, 0
    %var_454 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_452, 1
    %var_455 = alloca i8*
    call void %var_453(i8** %var_455, {  } %var_454, i8* @const_126)
    %var_456 = load i8*, ptr %var_455
    %var_457 = alloca {  }
    %var_458 = load {  }, ptr %var_457
    store {  } %var_458, ptr %var_457
    %var_459 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_460 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_459
    %var_461 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_460, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_462 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_461, {  } %var_458, 1
    store { void (i64*, {  }, i64)*, {  } } %var_462, ptr %var_459
    %var_464 = load i64, ptr @const_463
    %var_465 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_462, 0
    %var_466 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_462, 1
    %var_467 = alloca i64
    call void %var_465(i64* %var_467, {  } %var_466, i64 %var_464)
    %var_468 = load i64, ptr %var_467
    %var_469 = alloca {  }
    %var_470 = load {  }, ptr %var_469
    store {  } %var_470, ptr %var_469
    %var_471 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_472 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_471
    %var_473 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_472, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_474 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_473, {  } %var_470, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_474, ptr %var_471
    %var_475 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_474, 0
    %var_476 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_474, 1
    %var_477 = alloca i8*
    call void %var_475(i8** %var_477, {  } %var_476, i8* @const_126)
    %var_478 = load i8*, ptr %var_477
    %var_479 = alloca {  }
    %var_480 = load {  }, ptr %var_479
    store {  } %var_480, ptr %var_479
    %var_481 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_482 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_481
    %var_483 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_482, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_484 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_483, {  } %var_480, 1
    store { void (i64*, {  }, i64)*, {  } } %var_484, ptr %var_481
    %var_486 = load i64, ptr @const_485
    %var_487 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_484, 0
    %var_488 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_484, 1
    %var_489 = alloca i64
    call void %var_487(i64* %var_489, {  } %var_488, i64 %var_486)
    %var_490 = load i64, ptr %var_489
    ret i32 0
}
define void @"generated_print_i32[](i32)"(ptr sret({ void (i32*, {  }, i32)*, {  } }) %var_89, {  } %var_90, { void (i32*, {  }, i32)*, {  } } %var_91) {
  entry92: 
    %var_93 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_91, 1
    call void @printf(i8* @const_95, [4 x i8]* @const_94)
    call void @printf(i8* @const_95, [2 x i8]* @const_96)
    store { void (i32*, {  }, i32)*, {  } } %var_91, ptr %var_89
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_101(ptr sret(i32) %var_104, {  } %var_105, i32 %var_106) {
  entry107: 
    store i32 %var_106, ptr %var_104
    ret void
}
define void @"generated_print_i8*"(ptr sret(i8*) %var_118, {  } %var_119, i8* %var_120) {
  entry121: 
    call void @printf(i8* @const_95, i8* %var_120)
    store i8* %var_120, ptr %var_118
    ret void
}
define void @"generated_print_i32[i32](i32)"(ptr sret({ void (i32*, { i32 }, i32)*, { i32 } }) %var_133, {  } %var_134, { void (i32*, { i32 }, i32)*, { i32 } } %var_135) {
  entry136: 
    %var_137 = extractvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_135, 1
    call void @printf(i8* @const_95, [4 x i8]* @const_94)
    %var_138 = extractvalue { i32 } %var_137, 0
    %var_139 = alloca {  }
    %var_140 = load {  }, ptr %var_139
    store {  } %var_140, ptr %var_139
    %var_146 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_147 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_146
    %var_148 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_147, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_149 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_148, {  } %var_140, 1
    store { void (i32*, {  }, i32)*, {  } } %var_149, ptr %var_146
    %var_150 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_149, 0
    %var_151 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_149, 1
    %var_152 = alloca i32
    call void %var_150(i32* %var_152, {  } %var_151, i32 %var_138)
    %var_153 = load i32, ptr %var_152
    call void @printf(i8* @const_95, [2 x i8]* @const_96)
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_135, ptr %var_133
    ret void
}
define void @"generated_print_i32"(ptr sret(i32) %var_141, {  } %var_142, i32 %var_143) {
  entry144: 
    call void @printf(i8* @const_145, i32 %var_143)
    store i32 %var_143, ptr %var_141
    ret void
}
define void @fn_158(ptr sret({ void (i32*, { i32 }, i32)*, { i32 } }) %var_161, {  } %var_162, i32 %var_163) {
  entry164: 
    %var_166 = alloca { i32 }
    %var_167 = load { i32 }, ptr %var_166
    %var_168 = insertvalue { i32 } %var_167, i32 %var_163, 0
    store { i32 } %var_168, ptr %var_166
    %var_174 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    %var_175 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_174
    %var_176 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_175, void (i32*, { i32 }, i32)* @fn_165, 0
    %var_177 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_176, { i32 } %var_168, 1
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_177, ptr %var_174
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_177, ptr %var_161
    ret void
}
define void @fn_165(ptr sret(i32) %var_169, { i32 } %var_170, i32 %var_171) {
  entry172: 
    %var_173 = extractvalue { i32 } %var_170, 0
    store i32 %var_173, ptr %var_169
    ret void
}
define void @"generated_print_i32[](i32, i32)"(ptr sret({ void (i32*, {  }, i32, i32)*, {  } }) %var_204, {  } %var_205, { void (i32*, {  }, i32, i32)*, {  } } %var_206) {
  entry207: 
    %var_208 = extractvalue { void (i32*, {  }, i32, i32)*, {  } } %var_206, 1
    call void @printf(i8* @const_95, [4 x i8]* @const_94)
    call void @printf(i8* @const_95, [2 x i8]* @const_96)
    store { void (i32*, {  }, i32, i32)*, {  } } %var_206, ptr %var_204
    ret void
}
define void @fn_213(ptr sret(i32) %var_216, {  } %var_217, i32 %var_218, i32 %var_219) {
  entry220: 
    store i32 %var_218, ptr %var_216
    ret void
}
define void @"generated_print_(i32, i8*)"(ptr sret({ i32, i8* }) %var_241, {  } %var_242, { i32, i8* } %var_243) {
  entry244: 
    call void @printf(i8* @const_95, [7 x i8]* @const_245)
    %var_246 = extractvalue { i32, i8* } %var_243, 0
    %var_247 = alloca {  }
    %var_248 = load {  }, ptr %var_247
    store {  } %var_248, ptr %var_247
    %var_249 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_250 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_249
    %var_251 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_250, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_252 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_251, {  } %var_248, 1
    store { void (i32*, {  }, i32)*, {  } } %var_252, ptr %var_249
    %var_253 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_252, 0
    %var_254 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_252, 1
    %var_255 = alloca i32
    call void %var_253(i32* %var_255, {  } %var_254, i32 %var_246)
    %var_256 = load i32, ptr %var_255
    call void @printf(i8* @const_95, [3 x i8]* @const_257)
    %var_258 = extractvalue { i32, i8* } %var_243, 1
    %var_259 = alloca {  }
    %var_260 = load {  }, ptr %var_259
    store {  } %var_260, ptr %var_259
    %var_261 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_262 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_261
    %var_263 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_262, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_264 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_263, {  } %var_260, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_264, ptr %var_261
    %var_265 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_264, 0
    %var_266 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_264, 1
    %var_267 = alloca i8*
    call void %var_265(i8** %var_267, {  } %var_266, i8* %var_258)
    %var_268 = load i8*, ptr %var_267
    call void @printf(i8* @const_95, [2 x i8]* @const_269)
    store { i32, i8* } %var_243, ptr %var_241
    ret void
}
define void @"generated_print_f32"(ptr sret(float) %var_321, {  } %var_322, float %var_323) {
  entry324: 
    call void @printf(i8* @const_325, float %var_323)
    store float %var_323, ptr %var_321
    ret void
}
define void @"generated_print_i1"(ptr sret(i1) %var_368, {  } %var_369, i1 %var_370) {
  entry371: 
    %var_374 = select i1 %var_370, [5 x i8]* @const_372, [5 x i8]* @const_373
    call void @printf(i8* @const_95, [5 x i8]* %var_374)
    store i1 %var_370, ptr %var_368
    ret void
}
define void @"generated_print_symbol"(ptr sret(i64) %var_419, {  } %var_420, i64 %var_421) {
  entry422: 
    %var_423 = alloca {  }
    %var_424 = load {  }, ptr %var_423
    store {  } %var_424, ptr %var_423
    %var_429 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_430 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_429
    %var_431 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_430, void (i64*, {  }, i64)* @print_symbol_wrap, 0
    %var_432 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_431, {  } %var_424, 1
    store { void (i64*, {  }, i64)*, {  } } %var_432, ptr %var_429
    %var_433 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_432, 0
    %var_434 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_432, 1
    %var_435 = alloca i64
    call void %var_433(i64* %var_435, {  } %var_434, i64 %var_421)
    %var_436 = load i64, ptr %var_435
    store i64 %var_421, ptr %var_419
    ret void
}
declare void @print_symbol(i64)
define void @print_symbol_wrap(ptr sret(i64) %var_425, {  } %var_426, i64 %var_427) {
  entry428: 
    call void @print_symbol(i64 %var_427)
    store i64 %var_427, ptr %var_425
    ret void
}
"
`;

exports[`generic print > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_94 = constant [4 x i8] c"fn[\\00"
@const_95 = constant [3 x i8] c"%s\\00"
@const_96 = constant [2 x i8] c"]\\00"
@const_126 = constant [2 x i8] c"\\0A\\00"
@const_145 = constant [3 x i8] c"%i\\00"
@const_182 = local_unnamed_addr constant i32 1
@const_245 = constant [7 x i8] c"tuple(\\00"
@const_257 = constant [3 x i8] c", \\00"
@const_269 = constant [2 x i8] c")\\00"
@const_278 = constant [3 x i8] c"ab\\00"
@const_325 = constant [3 x i8] c"%f\\00"
@const_330 = local_unnamed_addr constant float 1.250000e+00
@const_372 = constant [5 x i8] c"true\\00"
@const_373 = constant [6 x i8] c"false\\00"
@const_379 = local_unnamed_addr constant i1 true
@const_401 = local_unnamed_addr constant i1 false
@const_441 = local_unnamed_addr constant i64 0
@const_463 = local_unnamed_addr constant i64 1
@const_485 = local_unnamed_addr constant i64 2
@const_491 = constant [5 x i8] c"unit\\00"
@const_492 = constant [12 x i8] c"atom_atom_a\\00"
@const_493 = constant [16 x i8] c"symbol_symbol_a\\00"
@symbols_metadata_array = constant [3 x { ptr }] [{ ptr } { ptr @const_491 }, { ptr } { ptr @const_492 }, { ptr } { ptr @const_493 }]
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_94)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_96)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_126)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_94)
  tail call void @printf(ptr nonnull @const_145, i32 1)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_96)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_126)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_94)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_96)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_126)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_245)
  tail call void @printf(ptr nonnull @const_145, i32 1)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_257)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_278)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_269)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_126)
  tail call void @printf(ptr nonnull @const_145, i32 1)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_126)
  tail call void @printf(ptr nonnull @const_325, float 1.250000e+00)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_126)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_278)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_126)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_372)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_126)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_373)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_126)
  tail call void @print_symbol(i64 0)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_126)
  tail call void @print_symbol(i64 1)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_126)
  tail call void @print_symbol(i64 2)
  ret i32 0
}

define void @"generated_print_i32[](i32)"(ptr nocapture writeonly sret({ ptr, {} }) %var_89, {} %var_90, { ptr, {} } %var_91) local_unnamed_addr {
entry92:
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_94)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_96)
  %var_91.elt = extractvalue { ptr, {} } %var_91, 0
  store ptr %var_91.elt, ptr %var_89, align 8
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_101(ptr nocapture writeonly sret(i32) %var_104, {} %var_105, i32 %var_106) local_unnamed_addr #1 {
entry107:
  store i32 %var_106, ptr %var_104, align 4
  ret void
}

define void @"generated_print_i8*"(ptr nocapture writeonly sret(ptr) %var_118, {} %var_119, ptr %var_120) local_unnamed_addr {
entry121:
  tail call void @printf(ptr nonnull @const_95, ptr %var_120)
  store ptr %var_120, ptr %var_118, align 8
  ret void
}

define void @"generated_print_i32[i32](i32)"(ptr nocapture writeonly sret({ ptr, { i32 } }) %var_133, {} %var_134, { ptr, { i32 } } %var_135) local_unnamed_addr {
entry136:
  %var_137 = extractvalue { ptr, { i32 } } %var_135, 1
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_94)
  %var_138 = extractvalue { i32 } %var_137, 0
  tail call void @printf(ptr nonnull @const_145, i32 %var_138)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_96)
  store { ptr, { i32 } } %var_135, ptr %var_133, align 8
  ret void
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_141, {} %var_142, i32 %var_143) local_unnamed_addr {
entry144:
  tail call void @printf(ptr nonnull @const_145, i32 %var_143)
  store i32 %var_143, ptr %var_141, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_158(ptr nocapture writeonly sret({ ptr, { i32 } }) %var_161, {} %var_162, i32 %var_163) local_unnamed_addr #1 {
entry164:
  %var_168 = insertvalue { i32 } undef, i32 %var_163, 0
  %var_177 = insertvalue { ptr, { i32 } } { ptr @fn_165, { i32 } undef }, { i32 } %var_168, 1
  store { ptr, { i32 } } %var_177, ptr %var_161, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_165(ptr nocapture writeonly sret(i32) %var_169, { i32 } %var_170, i32 %var_171) #1 {
entry172:
  %var_173 = extractvalue { i32 } %var_170, 0
  store i32 %var_173, ptr %var_169, align 4
  ret void
}

define void @"generated_print_i32[](i32, i32)"(ptr nocapture writeonly sret({ ptr, {} }) %var_204, {} %var_205, { ptr, {} } %var_206) local_unnamed_addr {
entry207:
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_94)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_96)
  %var_206.elt = extractvalue { ptr, {} } %var_206, 0
  store ptr %var_206.elt, ptr %var_204, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_213(ptr nocapture writeonly sret(i32) %var_216, {} %var_217, i32 %var_218, i32 %var_219) local_unnamed_addr #1 {
entry220:
  store i32 %var_218, ptr %var_216, align 4
  ret void
}

define void @"generated_print_(i32, i8*)"(ptr nocapture writeonly sret({ i32, ptr }) %var_241, {} %var_242, { i32, ptr } %var_243) local_unnamed_addr {
entry244:
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_245)
  %var_246 = extractvalue { i32, ptr } %var_243, 0
  tail call void @printf(ptr nonnull @const_145, i32 %var_246)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_257)
  %var_258 = extractvalue { i32, ptr } %var_243, 1
  tail call void @printf(ptr nonnull @const_95, ptr %var_258)
  tail call void @printf(ptr nonnull @const_95, ptr nonnull @const_269)
  store { i32, ptr } %var_243, ptr %var_241, align 8
  ret void
}

define void @generated_print_f32(ptr nocapture writeonly sret(float) %var_321, {} %var_322, float %var_323) local_unnamed_addr {
entry324:
  tail call void @printf(ptr nonnull @const_325, float %var_323)
  store float %var_323, ptr %var_321, align 4
  ret void
}

define void @generated_print_i1(ptr nocapture writeonly sret(i1) %var_368, {} %var_369, i1 %var_370) local_unnamed_addr {
entry371:
  %var_374 = select i1 %var_370, ptr @const_372, ptr @const_373
  tail call void @printf(ptr nonnull @const_95, ptr nonnull %var_374)
  store i1 %var_370, ptr %var_368, align 1
  ret void
}

define void @generated_print_symbol(ptr nocapture
 writeonly sret(i64) %var_419, {} %var_420, i64 %var_421) local_unnamed_addr {
entry422:
  tail call void @print_symbol(i64 %var_421)
  store i64 %var_421, ptr %var_419, align 8
  ret void
}

declare void @print_symbol(i64) local_unnamed_addr

define void @print_symbol_wrap(ptr nocapture writeonly sret(i64) %var_425, {} %var_426, i64 %var_427) local_unnamed_addr {
entry428:
  tail call void @print_symbol(i64 %var_427)
  store i64 %var_427, ptr %var_425, align 8
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`generic print > stderr 1`] = `[]`;

exports[`generic print > stdout 1`] = `
[
  "fn[]
fn[1]
fn[]
tuple(1, ab)
1
0.000000
ab
true
false
symbol(unit)
symbol(atom_atom_a)
symbol(symbol_symbol_a)",
]
`;

exports[`simply typed lambda calc compilation > apply > compiled 1`] = `
"@const_25 = constant [3 x i8] c"%i\\00"
@const_73 = constant i32 2
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_19 = alloca {  }
    %var_20 = load {  }, ptr %var_19
    store {  } %var_20, ptr %var_19
    %var_26 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_27 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_26
    %var_28 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_27, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_29 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_28, {  } %var_20, 1
    store { void (i32*, {  }, i32)*, {  } } %var_29, ptr %var_26
    %var_31 = alloca {  }
    %var_32 = load {  }, ptr %var_31
    store {  } %var_32, ptr %var_31
    %var_54 = alloca { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } }
    %var_55 = load { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } }, ptr %var_54
    %var_56 = insertvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_55, void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })* @fn_30, 0
    %var_57 = insertvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_56, {  } %var_32, 1
    store { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_57, ptr %var_54
    %var_59 = alloca {  }
    %var_60 = load {  }, ptr %var_59
    store {  } %var_60, ptr %var_59
    %var_65 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_66 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_65
    %var_67 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_66, void (i32*, {  }, i32)* @fn_58, 0
    %var_68 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_67, {  } %var_60, 1
    store { void (i32*, {  }, i32)*, {  } } %var_68, ptr %var_65
    %var_69 = extractvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_57, 0
    %var_70 = extractvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_57, 1
    %var_71 = alloca { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }
    call void %var_69({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }* %var_71, {  } %var_70, { void (i32*, {  }, i32)*, {  } } %var_68)
    %var_72 = load { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }, ptr %var_71
    %var_74 = load i32, ptr @const_73
    %var_75 = extractvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_72, 0
    %var_76 = extractvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_72, 1
    %var_77 = alloca i32
    call void %var_75(i32* %var_77, { { void (i32*, {  }, i32)*, {  } } } %var_76, i32 %var_74)
    %var_78 = load i32, ptr %var_77
    %var_79 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_29, 0
    %var_80 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_29, 1
    %var_81 = alloca i32
    call void %var_79(i32* %var_81, {  } %var_80, i32 %var_78)
    %var_82 = load i32, ptr %var_81
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %var_21, {  } %var_22, i32 %var_23) {
  entry24: 
    call void @printf(i8* @const_25, i32 %var_23)
    store i32 %var_23, ptr %var_21
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_30(ptr sret({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }) %var_33, {  } %var_34, { void (i32*, {  }, i32)*, {  } } %var_35) {
  entry36: 
    %var_38 = alloca { { void (i32*, {  }, i32)*, {  } } }
    %var_39 = load { { void (i32*, {  }, i32)*, {  } } }, ptr %var_38
    %var_40 = insertvalue { { void (i32*, {  }, i32)*, {  } } } %var_39, { void (i32*, {  }, i32)*, {  } } %var_35, 0
    store { { void (i32*, {  }, i32)*, {  } } } %var_40, ptr %var_38
    %var_50 = alloca { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }
    %var_51 = load { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }, ptr %var_50
    %var_52 = insertvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_51, void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)* @fn_37, 0
    %var_53 = insertvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_52, { { void (i32*, {  }, i32)*, {  } } } %var_40, 1
    store { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_53, ptr %var_50
    store { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_53, ptr %var_33
    ret void
}
define void @fn_37(ptr sret(i32) %var_41, { { void (i32*, {  }, i32)*, {  } } } %var_42, i32 %var_43) {
  entry44: 
    %var_45 = extractvalue { { void (i32*, {  }, i32)*, {  } } } %var_42, 0
    %var_46 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_45, 0
    %var_47 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_45, 1
    %var_48 = alloca i32
    call void %var_46(i32* %var_48, {  } %var_47, i32 %var_43)
    %var_49 = load i32, ptr %var_48
    store i32 %var_49, ptr %var_41
    ret void
}
define void @fn_58(ptr sret(i32) %var_61, {  } %var_62, i32 %var_63) {
  entry64: 
    store i32 %var_63, ptr %var_61
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > apply > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_25 = constant [3 x i8] c"%i\\00"
@const_73 = local_unnamed_addr constant i32 2
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_25, i32 2)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_21, {} %var_22, i32 %var_23) local_unnamed_addr {
entry24:
  tail call void @printf(ptr nonnull @const_25, i32 %var_23)
  store i32 %var_23, ptr %var_21, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_30(ptr nocapture writeonly sret({ ptr, { { ptr, {} } } }) %var_33, {} %var_34, { ptr, {} } %var_35) local_unnamed_addr #1 {
entry36:
  store ptr @fn_37, ptr %var_33, align 8
  %var_33.repack1 = getelementptr inbounds { ptr, { { ptr, {} } } }, ptr %var_33, i64 0, i32 1
  %var_35.elt = extractvalue { ptr, {} } %var_35, 0
  store ptr %var_35.elt, ptr %var_33.repack1, align 8
  ret void
}

define void @fn_37(ptr nocapture writeonly sret(i32) %var_41, { { ptr, {} } } %var_42, i32 %var_43) {
entry44:
  %var_45 = extractvalue { { ptr, {} } } %var_42, 0
  %var_46 = extractvalue { ptr, {} } %var_45, 0
  %var_48 = alloca i32, align 4
  call void %var_46(ptr nonnull %var_48, {} zeroinitializer, i32 %var_43)
  %var_49 = load i32, ptr %var_48, align 4
  store i32 %var_49, ptr %var_41, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_58(ptr nocapture writeonly sret(i32) %var_61, {} %var_62, i32 %var_63) local_unnamed_addr #1 {
entry64:
  store i32 %var_63, ptr %var_61, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > apply > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > apply > stdout 1`] = `
[
  "2",
]
`;

exports[`simply typed lambda calc compilation > church tuple > compiled 1`] = `
"@const_33 = constant [3 x i8] c"%i\\00"
@const_85 = constant i32 1
@const_91 = constant i32 2
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_27 = alloca {  }
    %var_28 = load {  }, ptr %var_27
    store {  } %var_28, ptr %var_27
    %var_34 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_35 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_34
    %var_36 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_35, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_37 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_36, {  } %var_28, 1
    store { void (i32*, {  }, i32)*, {  } } %var_37, ptr %var_34
    %var_39 = alloca {  }
    %var_40 = load {  }, ptr %var_39
    store {  } %var_40, ptr %var_39
    %var_81 = alloca { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }
    %var_82 = load { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_81
    %var_83 = insertvalue { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_82, void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)* @fn_38, 0
    %var_84 = insertvalue { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_83, {  } %var_40, 1
    store { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_84, ptr %var_81
    %var_86 = load i32, ptr @const_85
    %var_87 = extractvalue { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_84, 0
    %var_88 = extractvalue { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_84, 1
    %var_89 = alloca { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }
    call void %var_87({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }* %var_89, {  } %var_88, i32 %var_86)
    %var_90 = load { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }, ptr %var_89
    %var_92 = load i32, ptr @const_91
    %var_93 = extractvalue { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_90, 0
    %var_94 = extractvalue { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_90, 1
    %var_95 = alloca { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }
    call void %var_93({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }* %var_95, { i32 } %var_94, i32 %var_92)
    %var_96 = load { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }, ptr %var_95
    %var_98 = alloca {  }
    %var_99 = load {  }, ptr %var_98
    store {  } %var_99, ptr %var_98
    %var_117 = alloca { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }
    %var_118 = load { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_117
    %var_119 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_118, void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)* @fn_97, 0
    %var_120 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_119, {  } %var_99, 1
    store { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_120, ptr %var_117
    %var_121 = extractvalue { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_96, 0
    %var_122 = extractvalue { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_96, 1
    %var_123 = alloca i32
    call void %var_121(i32* %var_123, { i32, i32 } %var_122, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_120)
    %var_124 = load i32, ptr %var_123
    %var_125 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_37, 0
    %var_126 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_37, 1
    %var_127 = alloca i32
    call void %var_125(i32* %var_127, {  } %var_126, i32 %var_124)
    %var_128 = load i32, ptr %var_127
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %var_29, {  } %var_30, i32 %var_31) {
  entry32: 
    call void @printf(i8* @const_33, i32 %var_31)
    store i32 %var_31, ptr %var_29
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_38(ptr sret({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }) %var_41, {  } %var_42, i32 %var_43) {
  entry44: 
    %var_46 = alloca { i32 }
    %var_47 = load { i32 }, ptr %var_46
    %var_48 = insertvalue { i32 } %var_47, i32 %var_43, 0
    store { i32 } %var_48, ptr %var_46
    %var_77 = alloca { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }
    %var_78 = load { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }, ptr %var_77
    %var_79 = insertvalue { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_78, void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)* @fn_45, 0
    %var_80 = insertvalue { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_79, { i32 } %var_48, 1
    store { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_80, ptr %var_77
    store { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_80, ptr %var_41
    ret void
}
define void @fn_45(ptr sret({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }) %var_49, { i32 } %var_50, i32 %var_51) {
  entry52: 
    %var_53 = extractvalue { i32 } %var_50, 0
    %var_55 = alloca { i32, i32 }
    %var_56 = load { i32, i32 }, ptr %var_55
    %var_57 = insertvalue { i32, i32 } %var_56, i32 %var_53, 0
    %var_58 = insertvalue { i32, i32 } %var_57, i32 %var_51, 1
    store { i32, i32 } %var_58, ptr %var_55
    %var_73 = alloca { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }
    %var_74 = load { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }, ptr %var_73
    %var_75 = insertvalue { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_74, void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })* @fn_54, 0
    %var_76 = insertvalue { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_75, { i32, i32 } %var_58, 1
    store { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_76, ptr %var_73
    store { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_76, ptr %var_49
    ret void
}
define void @fn_54(ptr sret(i32) %var_59, { i32, i32 } %var_60, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_61) {
  entry62: 
    %var_63 = extractvalue { i32, i32 } %var_60, 0
    %var_64 = extractvalue { i32, i32 } %var_60, 1
    %var_65 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_61, 0
    %var_66 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_61, 1
    %var_67 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    call void %var_65({ void (i32*, { i32 }, i32)*, { i32 } }* %var_67, {  } %var_66, i32 %var_63)
    %var_68 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_67
    %var_69 = extractvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_68, 0
    %var_70 = extractvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_68, 1
    %var_71 = alloca i32
    call void %var_69(i32* %var_71, { i32 } %var_70, i32 %var_64)
    %var_72 = load i32, ptr %var_71
    store i32 %var_72, ptr %var_59
    ret void
}
define void @fn_97(ptr sret({ void (i32*, { i32 }, i32)*, { i32 } }) %var_100, {  } %var_101, i32 %var_102) {
  entry103: 
    %var_105 = alloca { i32 }
    %var_106 = load { i32 }, ptr %var_105
    %var_107 = insertvalue { i32 } %var_106, i32 %var_102, 0
    store { i32 } %var_107, ptr %var_105
    %var_113 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    %var_114 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_113
    %var_115 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_114, void (i32*, { i32 }, i32)* @fn_104, 0
    %var_116 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_115, { i32 } %var_107, 1
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_116, ptr %var_113
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_116, ptr %var_100
    ret void
}
define void @fn_104(ptr sret(i32) %var_108, { i32 } %var_109, i32 %var_110) {
  entry111: 
    %var_112 = extractvalue { i32 } %var_109, 0
    store i32 %var_112, ptr %var_108
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > church tuple > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_33 = constant [3 x i8] c"%i\\00"
@const_85 = local_unnamed_addr constant i32 1
@const_91 = local_unnamed_addr constant i32 2
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_33, i32 1)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_29, {} %var_30, i32 %var_31) local_unnamed_addr {
entry32:
  tail call void @printf(ptr nonnull @const_33, i32 %var_31)
  store i32 %var_31, ptr %var_29, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_38(ptr nocapture writeonly sret({ ptr, { i32 } }) %var_41, {} %var_42, i32 %var_43) local_unnamed_addr #1 {
entry44:
  %var_48 = insertvalue { i32 } undef, i32 %var_43, 0
  %var_80 = insertvalue { ptr, { i32 } } { ptr @fn_45, { i32 } undef }, { i32 } %var_48, 1
  store { ptr, { i32 } } %var_80, ptr %var_41, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_45(ptr nocapture writeonly sret({ ptr, { i32, i32 } }) %var_49, { i32 } %var_50, i32 %var_51) #1 {
entry52:
  %var_53 = extractvalue { i32 } %var_50, 0
  store ptr @fn_54, ptr %var_49, align 8
  %var_49.repack1 = getelementptr inbounds { ptr, { i32, i32 } }, ptr %var_49, i64 0, i32 1
  store i32 %var_53, ptr %var_49.repack1, align 8
  %var_49.repack1.repack3 = getelementptr inbounds { ptr, { i32, i32 } }, ptr %var_49, i64 0, i32 1, i32 1
  store i32 %var_51, ptr %var_49.repack1.repack3, align 4
  ret void
}

define void @fn_54(ptr nocapture writeonly sret(i32) %var_59, { i32, i32 } %var_60, { ptr, {} } %var_61) {
entry62:
  %var_63 = extractvalue { i32, i32 } %var_60, 0
  %var_64 = extractvalue { i32, i32 } %var_60, 1
  %var_65 = extractvalue { ptr, {} } %var_61, 0
  %var_67 = alloca { ptr, { i32 } }, align 8
  call void %var_65(ptr nonnull %var_67, {} zeroinitializer, i32 %var_63)
  %var_68.fca.0.load = load ptr, ptr %var_67, align 8
  %var_68.fca.1.0.gep = getelementptr inbounds { ptr, { i32 } }, ptr %var_67, i64 0, i32 1, i32 0
  %var_68.fca.1.0.load = load i32, ptr %var_68.fca.1.0.gep, align 8
  %var_70 = insertvalue { i32 } poison, i32 %var_68.fca.1.0.load, 0
  %var_71 = alloca i32, align 4
  call void %var_68.fca.0.load(ptr nonnull %var_71, { i32 } %var_70, i32 %var_64)
  %var_72 = load i32, ptr %var_71, align 4
  store i32 %var_72, ptr %var_59, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_97(ptr nocapture writeonly sret({ ptr, { i32 } }) %var_100, {} %var_101, i32 %var_102) local_unnamed_addr #1 {
entry103:
  %var_107 = insertvalue { i32 } undef, i32 %var_102, 0
  %var_116 = insertvalue { ptr, { i32 } } { ptr @fn_104, { i32 } undef }, { i32 } %var_107, 1
  store { ptr, { i32 } } %var_116, ptr %var_100, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_104(ptr nocapture writeonly sret(i32) %var_108, { i32 } %var_109, i32 %var_110) #1 {
entry111:
  %var_112 = extractvalue { i32 } %var_109, 0
  store i32 %var_112, ptr %var_108, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > church tuple > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > church tuple > stdout 1`] = `
[
  "1",
]
`;

exports[`simply typed lambda calc compilation > church tuple 2 > compiled 1`] = `
"@const_26 = constant [3 x i8] c"%i\\00"
@const_48 = constant i32 1
@const_50 = constant i32 2
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_20 = alloca {  }
    %var_21 = load {  }, ptr %var_20
    store {  } %var_21, ptr %var_20
    %var_27 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_28 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_27
    %var_29 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_28, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_30 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_29, {  } %var_21, 1
    store { void (i32*, {  }, i32)*, {  } } %var_30, ptr %var_27
    %var_32 = alloca {  }
    %var_33 = load {  }, ptr %var_32
    store {  } %var_33, ptr %var_32
    %var_44 = alloca { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } }
    %var_45 = load { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } }, ptr %var_44
    %var_46 = insertvalue { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_45, void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })* @fn_31, 0
    %var_47 = insertvalue { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_46, {  } %var_33, 1
    store { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_47, ptr %var_44
    %var_49 = load i32, ptr @const_48
    %var_51 = load i32, ptr @const_50
    %var_53 = alloca {  }
    %var_54 = load {  }, ptr %var_53
    store {  } %var_54, ptr %var_53
    %var_59 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_60 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_59
    %var_61 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_60, void (i32*, {  }, i32)* @fn_52, 0
    %var_62 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_61, {  } %var_54, 1
    store { void (i32*, {  }, i32)*, {  } } %var_62, ptr %var_59
    %var_63 = extractvalue { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_47, 0
    %var_64 = extractvalue { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_47, 1
    %var_65 = alloca i32
    call void %var_63(i32* %var_65, {  } %var_64, i32 %var_49, i32 %var_51, { void (i32*, {  }, i32, i32)*, {  } } %var_62)
    %var_66 = load i32, ptr %var_65
    %var_67 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_30, 0
    %var_68 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_30, 1
    %var_69 = alloca i32
    call void %var_67(i32* %var_69, {  } %var_68, i32 %var_66)
    %var_70 = load i32, ptr %var_69
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %var_22, {  } %var_23, i32 %var_24) {
  entry25: 
    call void @printf(i8* @const_26, i32 %var_24)
    store i32 %var_24, ptr %var_22
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_31(ptr sret(i32) %var_34, {  } %var_35, i32 %var_36, i32 %var_37, { void (i32*, {  }, i32, i32)*, {  } } %var_38) {
  entry39: 
    %var_40 = extractvalue { void (i32*, {  }, i32, i32)*, {  } } %var_38, 0
    %var_41 = extractvalue { void (i32*, {  }, i32, i32)*, {  } } %var_38, 1
    %var_42 = alloca i32
    call void %var_40(i32* %var_42, {  } %var_41, i32 %var_36, i32 %var_37)
    %var_43 = load i32, ptr %var_42
    store i32 %var_43, ptr %var_34
    ret void
}
define void @fn_52(ptr sret(i32) %var_55, {  } %var_56, i32 %var_57) {
  entry58: 
    store i32 %var_57, ptr %var_55
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > church tuple 2 > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_26 = constant [3 x i8] c"%i\\00"
@const_48 = local_unnamed_addr constant i32 1
@const_50 = local_unnamed_addr constant i32 2
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_26, i32 1)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_22, {} %var_23, i32 %var_24) local_unnamed_addr {
entry25:
  tail call void @printf(ptr nonnull @const_26, i32 %var_24)
  store i32 %var_24, ptr %var_22, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

define void @fn_31(ptr nocapture writeonly sret(i32) %var_34, {} %var_35, i32 %var_36, i32 %var_37, { ptr, {} } %var_38) local_unnamed_addr {
entry39:
  %var_40 = extractvalue { ptr, {} } %var_38, 0
  %var_42 = alloca i32, align 4
  call void %var_40(ptr nonnull %var_42, {} zeroinitializer, i32 %var_36, i32 %var_37)
  %var_43 = load i32, ptr %var_42, align 4
  store i32 %var_43, ptr %var_34, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_52(ptr nocapture writeonly sret(i32) %var_55, {} %var_56, i32 %var_57) local_unnamed_addr #1 {
entry58:
  store i32 %var_57, ptr %var_55, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > church tuple 2 > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > church tuple 2 > stdout 1`] = `
[
  "1",
]
`;

exports[`simply typed lambda calc compilation > either > compiled 1`] = `
"@const_31 = constant [3 x i8] c"%i\\00"
@const_79 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_25 = alloca {  }
    %var_26 = load {  }, ptr %var_25
    store {  } %var_26, ptr %var_25
    %var_32 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_33 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_32
    %var_34 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_33, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_35 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_34, {  } %var_26, 1
    store { void (i32*, {  }, i32)*, {  } } %var_35, ptr %var_32
    %var_37 = alloca {  }
    %var_38 = load {  }, ptr %var_37
    store {  } %var_38, ptr %var_37
    %var_75 = alloca { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } }
    %var_76 = load { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_75
    %var_77 = insertvalue { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } } %var_76, void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)* @fn_36, 0
    %var_78 = insertvalue { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } } %var_77, {  } %var_38, 1
    store { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } } %var_78, ptr %var_75
    %var_80 = load i32, ptr @const_79
    %var_81 = extractvalue { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } } %var_78, 0
    %var_82 = extractvalue { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } } %var_78, 1
    %var_83 = alloca { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }
    call void %var_81({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }* %var_83, {  } %var_82, i32 %var_80)
    %var_84 = load { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }, ptr %var_83
    %var_86 = alloca {  }
    %var_87 = load {  }, ptr %var_86
    store {  } %var_87, ptr %var_86
    %var_92 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_93 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_92
    %var_94 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_93, void (i32*, {  }, i32)* @fn_85, 0
    %var_95 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_94, {  } %var_87, 1
    store { void (i32*, {  }, i32)*, {  } } %var_95, ptr %var_92
    %var_96 = extractvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_84, 0
    %var_97 = extractvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_84, 1
    %var_98 = alloca { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }
    call void %var_96({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }* %var_98, { i32 } %var_97, { void (i32*, {  }, i32)*, {  } } %var_95)
    %var_99 = load { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }, ptr %var_98
    %var_101 = alloca {  }
    %var_102 = load {  }, ptr %var_101
    store {  } %var_102, ptr %var_101
    %var_107 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_108 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_107
    %var_109 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_108, void (i32*, {  }, i32)* @fn_100, 0
    %var_110 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_109, {  } %var_102, 1
    store { void (i32*, {  }, i32)*, {  } } %var_110, ptr %var_107
    %var_111 = extractvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_99, 0
    %var_112 = extractvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_99, 1
    %var_113 = alloca i32
    call void %var_111(i32* %var_113, { { void (i32*, {  }, i32)*, {  } }, i32 } %var_112, { void (i32*, {  }, i32)*, {  } } %var_110)
    %var_114 = load i32, ptr %var_113
    %var_115 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_35, 0
    %var_116 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_35, 1
    %var_117 = alloca i32
    call void %var_115(i32* %var_117, {  } %var_116, i32 %var_114)
    %var_118 = load i32, ptr %var_117
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %var_27, {  } %var_28, i32 %var_29) {
  entry30: 
    call void @printf(i8* @const_31, i32 %var_29)
    store i32 %var_29, ptr %var_27
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_36(ptr sret({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }) %var_39, {  } %var_40, i32 %var_41) {
  entry42: 
    %var_44 = alloca { i32 }
    %var_45 = load { i32 }, ptr %var_44
    %var_46 = insertvalue { i32 } %var_45, i32 %var_41, 0
    store { i32 } %var_46, ptr %var_44
    %var_71 = alloca { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }
    %var_72 = load { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }, ptr %var_71
    %var_73 = insertvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_72, void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })* @fn_43, 0
    %var_74 = insertvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_73, { i32 } %var_46, 1
    store { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_74, ptr %var_71
    store { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_74, ptr %var_39
    ret void
}
define void @fn_43(ptr sret({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }) %var_47, { i32 } %var_48, { void (i32*, {  }, i32)*, {  } } %var_49) {
  entry50: 
    %var_51 = extractvalue { i32 } %var_48, 0
    %var_53 = alloca { { void (i32*, {  }, i32)*, {  } }, i32 }
    %var_54 = load { { void (i32*, {  }, i32)*, {  } }, i32 }, ptr %var_53
    %var_55 = insertvalue { { void (i32*, {  }, i32)*, {  } }, i32 } %var_54, { void (i32*, {  }, i32)*, {  } } %var_49, 0
    %var_56 = insertvalue { { void (i32*, {  }, i32)*, {  } }, i32 } %var_55, i32 %var_51, 1
    store { { void (i32*, {  }, i32)*, {  } }, i32 } %var_56, ptr %var_53
    %var_67 = alloca { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }
    %var_68 = load { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }, ptr %var_67
    %var_69 = insertvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_68, void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })* @fn_52, 0
    %var_70 = insertvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_69, { { void (i32*, {  }, i32)*, {  } }, i32 } %var_56, 1
    store { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_70, ptr %var_67
    store { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_70, ptr %var_47
    ret void
}
define void @fn_52(ptr sret(i32) %var_57, { { void (i32*, {  }, i32)*, {  } }, i32 } %var_58, { void (i32*, {  }, i32)*, {  } } %var_59) {
  entry60: 
    %var_61 = extractvalue { { void (i32*, {  }, i32)*, {  } }, i32 } %var_58, 0
    %var_62 = extractvalue { { void (i32*, {  }, i32)*, {  } }, i32 } %var_58, 1
    %var_63 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_61, 0
    %var_64 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_61, 1
    %var_65 = alloca i32
    call void %var_63(i32* %var_65, {  } %var_64, i32 %var_62)
    %var_66 = load i32, ptr %var_65
    store i32 %var_66, ptr %var_57
    ret void
}
define void @fn_85(ptr sret(i32) %var_88, {  } %var_89, i32 %var_90) {
  entry91: 
    store i32 %var_90, ptr %var_88
    ret void
}
define void @fn_100(ptr sret(i32) %var_103, {  } %var_104, i32 %var_105) {
  entry106: 
    store i32 %var_105, ptr %var_103
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > either > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_31 = constant [3 x i8] c"%i\\00"
@const_79 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_31, i32 1)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_27, {} %var_28, i32 %var_29) local_unnamed_addr {
entry30:
  tail call void @printf(ptr nonnull @const_31, i32 %var_29)
  store i32 %var_29, ptr %var_27, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_36(ptr nocapture writeonly sret({ ptr, { i32 } }) %var_39, {} %var_40, i32 %var_41) local_unnamed_addr #1 {
entry42:
  %var_46 = insertvalue { i32 } undef, i32 %var_41, 0
  %var_74 = insertvalue { ptr, { i32 } } { ptr @fn_43, { i32 } undef }, { i32 } %var_46, 1
  store { ptr, { i32 } } %var_74, ptr %var_39, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_43(ptr nocapture writeonly sret({ ptr, { { ptr, {} }, i32 } }) %var_47, { i32 } %var_48, { ptr, {} } %var_49) #1 {
entry50:
  %var_51 = extractvalue { i32 } %var_48, 0
  %var_55 = insertvalue { { ptr, {} }, i32 } { { ptr, {} } { ptr undef, {} poison }, i32 undef }, { ptr, {} } %var_49, 0
  %var_56 = insertvalue { { ptr, {} }, i32 } %var_55, i32 %var_51, 1
  store ptr @fn_52, ptr %var_47, align 8
  %var_47.repack1 = getelementptr inbounds { ptr, { { ptr, {} }, i32 } }, ptr %var_47, i64 0, i32 1
  store { { ptr, {} }, i32 } %var_56, ptr %var_47.repack1, align 8
  ret void
}

define void @fn_52(ptr nocapture writeonly sret(i32) %var_57, { { ptr, {} }, i32 } %var_58, { ptr, {} } %var_59) {
entry60:
  %var_61 = extractvalue { { ptr, {} }, i32 } %var_58, 0
  %var_62 = extractvalue { { ptr, {} }, i32 } %var_58, 1
  %var_63 = extractvalue { ptr, {} } %var_61, 0
  %var_65 = alloca i32, align 4
  call void %var_63(ptr nonnull %var_65, {} zeroinitializer, i32 %var_62)
  %var_66 = load i32, ptr %var_65, align 4
  store i32 %var_66, ptr %var_57, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_85(ptr nocapture writeonly sret(i32) %var_88, {} %var_89, i32 %var_90) local_unnamed_addr #1 {
entry91:
  store i32 %var_90, ptr %var_88, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_100(ptr nocapture writeonly sret(i32) %var_103, {} %var_104, i32 %var_105) local_unnamed_addr #1 {
entry106:
  store i32 %var_105, ptr %var_103, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > either > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > either > stdout 1`] = `
[
  "1",
]
`;

exports[`simply typed lambda calc compilation > either 2 > compiled 1`] = `
"@const_27 = constant [3 x i8] c"%i\\00"
@const_49 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_21 = alloca {  }
    %var_22 = load {  }, ptr %var_21
    store {  } %var_22, ptr %var_21
    %var_28 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_29 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_28
    %var_30 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_29, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_31 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_30, {  } %var_22, 1
    store { void (i32*, {  }, i32)*, {  } } %var_31, ptr %var_28
    %var_33 = alloca {  }
    %var_34 = load {  }, ptr %var_33
    store {  } %var_34, ptr %var_33
    %var_45 = alloca { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } }
    %var_46 = load { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } }, ptr %var_45
    %var_47 = insertvalue { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_46, void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })* @fn_32, 0
    %var_48 = insertvalue { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_47, {  } %var_34, 1
    store { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_48, ptr %var_45
    %var_50 = load i32, ptr @const_49
    %var_52 = alloca {  }
    %var_53 = load {  }, ptr %var_52
    store {  } %var_53, ptr %var_52
    %var_58 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_59 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_58
    %var_60 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_59, void (i32*, {  }, i32)* @fn_51, 0
    %var_61 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_60, {  } %var_53, 1
    store { void (i32*, {  }, i32)*, {  } } %var_61, ptr %var_58
    %var_63 = alloca {  }
    %var_64 = load {  }, ptr %var_63
    store {  } %var_64, ptr %var_63
    %var_69 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_70 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_69
    %var_71 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_70, void (i32*, {  }, i32)* @fn_62, 0
    %var_72 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_71, {  } %var_64, 1
    store { void (i32*, {  }, i32)*, {  } } %var_72, ptr %var_69
    %var_73 = extractvalue { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_48, 0
    %var_74 = extractvalue { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_48, 1
    %var_75 = alloca i32
    call void %var_73(i32* %var_75, {  } %var_74, i32 %var_50, { void (i32*, {  }, i32)*, {  } } %var_61, { void (i32*, {  }, i32)*, {  } } %var_72)
    %var_76 = load i32, ptr %var_75
    %var_77 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_31, 0
    %var_78 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_31, 1
    %var_79 = alloca i32
    call void %var_77(i32* %var_79, {  } %var_78, i32 %var_76)
    %var_80 = load i32, ptr %var_79
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %var_23, {  } %var_24, i32 %var_25) {
  entry26: 
    call void @printf(i8* @const_27, i32 %var_25)
    store i32 %var_25, ptr %var_23
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_32(ptr sret(i32) %var_35, {  } %var_36, i32 %var_37, { void (i32*, {  }, i32)*, {  } } %var_38, { void (i32*, {  }, i32)*, {  } } %var_39) {
  entry40: 
    %var_41 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_38, 0
    %var_42 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_38, 1
    %var_43 = alloca i32
    call void %var_41(i32* %var_43, {  } %var_42, i32 %var_37)
    %var_44 = load i32, ptr %var_43
    store i32 %var_44, ptr %var_35
    ret void
}
define void @fn_51(ptr sret(i32) %var_54, {  } %var_55, i32 %var_56) {
  entry57: 
    store i32 %var_56, ptr %var_54
    ret void
}
define void @fn_62(ptr sret(i32) %var_65, {  } %var_66, i32 %var_67) {
  entry68: 
    store i32 %var_67, ptr %var_65
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > either 2 > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_27 = constant [3 x i8] c"%i\\00"
@const_49 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_27, i32 1)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_23, {} %var_24, i32 %var_25) local_unnamed_addr {
entry26:
  tail call void @printf(ptr nonnull @const_27, i32 %var_25)
  store i32 %var_25, ptr %var_23, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

define void @fn_32(ptr nocapture writeonly sret(i32) %var_35, {} %var_36, i32 %var_37, { ptr, {} } %var_38, { ptr, {} } %var_39) local_unnamed_addr {
entry40:
  %var_41 = extractvalue { ptr, {} } %var_38, 0
  %var_43 = alloca i32, align 4
  call void %var_41(ptr nonnull %var_43, {} zeroinitializer, i32 %var_37)
  %var_44 = load i32, ptr %var_43, align 4
  store i32 %var_44, ptr %var_35, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_51(ptr nocapture writeonly sret(i32) %var_54, {} %var_55, i32 %var_56) local_unnamed_addr #1 {
entry57:
  store i32 %var_56, ptr %var_54, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_62(ptr nocapture writeonly sret(i32) %var_65, {} %var_66, i32 %var_67) local_unnamed_addr #1 {
entry68:
  store i32 %var_67, ptr %var_65, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > either 2 > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > either 2 > stdout 1`] = `
[
  "1",
]
`;

exports[`simply typed lambda calc compilation > function application and literal print > compiled 1`] = `
"@const_19 = constant [3 x i8] c"%i\\00"
@const_36 = constant i32 2
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_13 = alloca {  }
    %var_14 = load {  }, ptr %var_13
    store {  } %var_14, ptr %var_13
    %var_20 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_21 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_20
    %var_22 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_21, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_23 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_22, {  } %var_14, 1
    store { void (i32*, {  }, i32)*, {  } } %var_23, ptr %var_20
    %var_25 = alloca {  }
    %var_26 = load {  }, ptr %var_25
    store {  } %var_26, ptr %var_25
    %var_32 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_33 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_32
    %var_34 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_33, void (i32*, {  }, i32)* @fn_24, 0
    %var_35 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_34, {  } %var_26, 1
    store { void (i32*, {  }, i32)*, {  } } %var_35, ptr %var_32
    %var_37 = load i32, ptr @const_36
    %var_38 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_35, 0
    %var_39 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_35, 1
    %var_40 = alloca i32
    call void %var_38(i32* %var_40, {  } %var_39, i32 %var_37)
    %var_41 = load i32, ptr %var_40
    %var_42 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_23, 0
    %var_43 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_23, 1
    %var_44 = alloca i32
    call void %var_42(i32* %var_44, {  } %var_43, i32 %var_41)
    %var_45 = load i32, ptr %var_44
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %var_15, {  } %var_16, i32 %var_17) {
  entry18: 
    call void @printf(i8* @const_19, i32 %var_17)
    store i32 %var_17, ptr %var_15
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_24(ptr sret(i32) %var_27, {  } %var_28, i32 %var_29) {
  entry30: 
    %var_31 = add i32 %var_29, %var_29
    store i32 %var_31, ptr %var_27
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > function application and literal print > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_19 = constant [3 x i8] c"%i\\00"
@const_36 = local_unnamed_addr constant i32 2
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_19, i32 4)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_15, {} %var_16, i32 %var_17) local_unnamed_addr {
entry18:
  tail call void @printf(ptr nonnull @const_19, i32 %var_17)
  store i32 %var_17, ptr %var_15, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_24(ptr nocapture writeonly sret(i32) %var_27, {} %var_28, i32 %var_29) local_unnamed_addr #1 {
entry30:
  %var_31 = shl i32 %var_29, 1
  store i32 %var_31, ptr %var_27, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > function application and literal print > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > function application and literal print > stdout 1`] = `
[
  "4",
]
`;

exports[`simply typed lambda calc compilation > function closure > compiled 1`] = `
"@const_25 = constant [3 x i8] c"%i\\00"
@const_46 = constant i32 2
@const_58 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_19 = alloca {  }
    %var_20 = load {  }, ptr %var_19
    store {  } %var_20, ptr %var_19
    %var_26 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_27 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_26
    %var_28 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_27, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_29 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_28, {  } %var_20, 1
    store { void (i32*, {  }, i32)*, {  } } %var_29, ptr %var_26
    %var_31 = alloca {  }
    %var_32 = load {  }, ptr %var_31
    store {  } %var_32, ptr %var_31
    %var_54 = alloca { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }
    %var_55 = load { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_54
    %var_56 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_55, void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)* @fn_30, 0
    %var_57 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_56, {  } %var_32, 1
    store { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_57, ptr %var_54
    %var_59 = load i32, ptr @const_58
    %var_60 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_57, 0
    %var_61 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_57, 1
    %var_62 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    call void %var_60({ void (i32*, { i32 }, i32)*, { i32 } }* %var_62, {  } %var_61, i32 %var_59)
    %var_63 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_62
    %var_64 = load i32, ptr @const_46
    %var_65 = extractvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_63, 0
    %var_66 = extractvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_63, 1
    %var_67 = alloca i32
    call void %var_65(i32* %var_67, { i32 } %var_66, i32 %var_64)
    %var_68 = load i32, ptr %var_67
    %var_69 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_29, 0
    %var_70 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_29, 1
    %var_71 = alloca i32
    call void %var_69(i32* %var_71, {  } %var_70, i32 %var_68)
    %var_72 = load i32, ptr %var_71
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %var_21, {  } %var_22, i32 %var_23) {
  entry24: 
    call void @printf(i8* @const_25, i32 %var_23)
    store i32 %var_23, ptr %var_21
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_30(ptr sret({ void (i32*, { i32 }, i32)*, { i32 } }) %var_33, {  } %var_34, i32 %var_35) {
  entry36: 
    %var_38 = alloca { i32 }
    %var_39 = load { i32 }, ptr %var_38
    %var_40 = insertvalue { i32 } %var_39, i32 %var_35, 0
    store { i32 } %var_40, ptr %var_38
    %var_50 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    %var_51 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_50
    %var_52 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_51, void (i32*, { i32 }, i32)* @fn_37, 0
    %var_53 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_52, { i32 } %var_40, 1
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_53, ptr %var_50
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_53, ptr %var_33
    ret void
}
define void @fn_37(ptr sret(i32) %var_41, { i32 } %var_42, i32 %var_43) {
  entry44: 
    %var_45 = extractvalue { i32 } %var_42, 0
    %var_47 = load i32, ptr @const_46
    %var_48 = mul i32 %var_47, %var_45
    %var_49 = add i32 %var_43, %var_48
    store i32 %var_49, ptr %var_41
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > function closure > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_25 = constant [3 x i8] c"%i\\00"
@const_46 = local_unnamed_addr constant i32 2
@const_58 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_25, i32 4)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_21, {} %var_22, i32 %var_23) local_unnamed_addr {
entry24:
  tail call void @printf(ptr nonnull @const_25, i32 %var_23)
  store i32 %var_23, ptr %var_21, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_30(ptr nocapture writeonly sret({ ptr, { i32 } }) %var_33, {} %var_34, i32 %var_35) local_unnamed_addr #1 {
entry36:
  %var_40 = insertvalue { i32 } undef, i32 %var_35, 0
  %var_53 = insertvalue { ptr, { i32 } } { ptr @fn_37, { i32 } undef }, { i32 } %var_40, 1
  store { ptr, { i32 } } %var_53, ptr %var_33, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_37(ptr nocapture writeonly sret(i32) %var_41, { i32 } %var_42, i32 %var_43) #1 {
entry44:
  %var_45 = extractvalue { i32 } %var_42, 0
  %var_48 = shl i32 %var_45, 1
  %var_49 = add i32 %var_48, %var_43
  store i32 %var_49, ptr %var_41, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > function closure > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > function closure > stdout 1`] = `
[
  "4",
]
`;

exports[`simply typed lambda calc compilation > function deep closure > compiled 1`] = `
"@const_29 = constant [3 x i8] c"%i\\00"
@const_75 = constant i32 1
@const_81 = constant i32 3
@const_87 = constant i32 5
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_23 = alloca {  }
    %var_24 = load {  }, ptr %var_23
    store {  } %var_24, ptr %var_23
    %var_30 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_31 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_30
    %var_32 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_31, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_33 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_32, {  } %var_24, 1
    store { void (i32*, {  }, i32)*, {  } } %var_33, ptr %var_30
    %var_35 = alloca {  }
    %var_36 = load {  }, ptr %var_35
    store {  } %var_36, ptr %var_35
    %var_71 = alloca { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }
    %var_72 = load { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_71
    %var_73 = insertvalue { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_72, void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)* @fn_34, 0
    %var_74 = insertvalue { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_73, {  } %var_36, 1
    store { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_74, ptr %var_71
    %var_76 = load i32, ptr @const_75
    %var_77 = extractvalue { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_74, 0
    %var_78 = extractvalue { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_74, 1
    %var_79 = alloca { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }
    call void %var_77({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }* %var_79, {  } %var_78, i32 %var_76)
    %var_80 = load { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }, ptr %var_79
    %var_82 = load i32, ptr @const_81
    %var_83 = extractvalue { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_80, 0
    %var_84 = extractvalue { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_80, 1
    %var_85 = alloca { void (i32*, { i32, i32 }, i32)*, { i32, i32 } }
    call void %var_83({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }* %var_85, { i32 } %var_84, i32 %var_82)
    %var_86 = load { void (i32*, { i32, i32 }, i32)*, { i32, i32 } }, ptr %var_85
    %var_88 = load i32, ptr @const_87
    %var_89 = extractvalue { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_86, 0
    %var_90 = extractvalue { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_86, 1
    %var_91 = alloca i32
    call void %var_89(i32* %var_91, { i32, i32 } %var_90, i32 %var_88)
    %var_92 = load i32, ptr %var_91
    %var_93 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_33, 0
    %var_94 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_33, 1
    %var_95 = alloca i32
    call void %var_93(i32* %var_95, {  } %var_94, i32 %var_92)
    %var_96 = load i32, ptr %var_95
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %var_25, {  } %var_26, i32 %var_27) {
  entry28: 
    call void @printf(i8* @const_29, i32 %var_27)
    store i32 %var_27, ptr %var_25
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_34(ptr sret({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }) %var_37, {  } %var_38, i32 %var_39) {
  entry40: 
    %var_42 = alloca { i32 }
    %var_43 = load { i32 }, ptr %var_42
    %var_44 = insertvalue { i32 } %var_43, i32 %var_39, 0
    store { i32 } %var_44, ptr %var_42
    %var_67 = alloca { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }
    %var_68 = load { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }, ptr %var_67
    %var_69 = insertvalue { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_68, void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)* @fn_41, 0
    %var_70 = insertvalue { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_69, { i32 } %var_44, 1
    store { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_70, ptr %var_67
    store { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_70, ptr %var_37
    ret void
}
define void @fn_41(ptr sret({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }) %var_45, { i32 } %var_46, i32 %var_47) {
  entry48: 
    %var_49 = extractvalue { i32 } %var_46, 0
    %var_51 = alloca { i32, i32 }
    %var_52 = load { i32, i32 }, ptr %var_51
    %var_53 = insertvalue { i32, i32 } %var_52, i32 %var_49, 0
    %var_54 = insertvalue { i32, i32 } %var_53, i32 %var_47, 1
    store { i32, i32 } %var_54, ptr %var_51
    %var_63 = alloca { void (i32*, { i32, i32 }, i32)*, { i32, i32 } }
    %var_64 = load { void (i32*, { i32, i32 }, i32)*, { i32, i32 } }, ptr %var_63
    %var_65 = insertvalue { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_64, void (i32*, { i32, i32 }, i32)* @fn_50, 0
    %var_66 = insertvalue { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_65, { i32, i32 } %var_54, 1
    store { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_66, ptr %var_63
    store { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_66, ptr %var_45
    ret void
}
define void @fn_50(ptr sret(i32) %var_55, { i32, i32 } %var_56, i32 %var_57) {
  entry58: 
    %var_59 = extractvalue { i32, i32 } %var_56, 0
    %var_60 = extractvalue { i32, i32 } %var_56, 1
    %var_61 = add i32 %var_60, %var_57
    %var_62 = add i32 %var_59, %var_61
    store i32 %var_62, ptr %var_55
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > function deep closure > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_29 = constant [3 x i8] c"%i\\00"
@const_75 = local_unnamed_addr constant i32 1
@const_81 = local_unnamed_addr constant i32 3
@const_87 = local_unnamed_addr constant i32 5
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_29, i32 9)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_25, {} %var_26, i32 %var_27) local_unnamed_addr {
entry28:
  tail call void @printf(ptr nonnull @const_29, i32 %var_27)
  store i32 %var_27, ptr %var_25, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_34(ptr nocapture writeonly sret({ ptr, { i32 } }) %var_37, {} %var_38, i32 %var_39) local_unnamed_addr #1 {
entry40:
  %var_44 = insertvalue { i32 } undef, i32 %var_39, 0
  %var_70 = insertvalue { ptr, { i32 } } { ptr @fn_41, { i32 } undef }, { i32 } %var_44, 1
  store { ptr, { i32 } } %var_70, ptr %var_37, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_41(ptr nocapture writeonly sret({ ptr, { i32, i32 } }) %var_45, { i32 } %var_46, i32 %var_47) #1 {
entry48:
  %var_49 = extractvalue { i32 } %var_46, 0
  store ptr @fn_50, ptr %var_45, align 8
  %var_45.repack1 = getelementptr inbounds { ptr, { i32, i32 } }, ptr %var_45, i64 0, i32 1
  store i32 %var_49, ptr %var_45.repack1, align 8
  %var_45.repack1.repack3 = getelementptr inbounds { ptr, { i32, i32 } }, ptr %var_45, i64 0, i32 1, i32 1
  store i32 %var_47, ptr %var_45.repack1.repack3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_50(ptr nocapture writeonly sret(i32) %var_55, { i32, i32 } %var_56, i32 %var_57) #1 {
entry58:
  %var_59 = extractvalue { i32, i32 } %var_56, 0
  %var_60 = extractvalue { i32, i32 } %var_56, 1
  %var_61 = add i32 %var_60, %var_57
  %var_62 = add i32 %var_61, %var_59
  store i32 %var_62, ptr %var_55, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > function deep closure > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > function deep closure > stdout 1`] = `
[
  "9",
]
`;

exports[`simply typed lambda calc compilation > function multiple args > compiled 1`] = `
"@const_23 = constant [3 x i8] c"%i\\00"
@const_36 = constant i32 2
@const_44 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_17 = alloca {  }
    %var_18 = load {  }, ptr %var_17
    store {  } %var_18, ptr %var_17
    %var_24 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_25 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_24
    %var_26 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_25, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_27 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_26, {  } %var_18, 1
    store { void (i32*, {  }, i32)*, {  } } %var_27, ptr %var_24
    %var_29 = alloca {  }
    %var_30 = load {  }, ptr %var_29
    store {  } %var_30, ptr %var_29
    %var_40 = alloca { void (i32*, {  }, i32, i32)*, {  } }
    %var_41 = load { void (i32*, {  }, i32, i32)*, {  } }, ptr %var_40
    %var_42 = insertvalue { void (i32*, {  }, i32, i32)*, {  } } %var_41, void (i32*, {  }, i32, i32)* @fn_28, 0
    %var_43 = insertvalue { void (i32*, {  }, i32, i32)*, {  } } %var_42, {  } %var_30, 1
    store { void (i32*, {  }, i32, i32)*, {  } } %var_43, ptr %var_40
    %var_45 = load i32, ptr @const_44
    %var_46 = load i32, ptr @const_36
    %var_47 = extractvalue { void (i32*, {  }, i32, i32)*, {  } } %var_43, 0
    %var_48 = extractvalue { void (i32*, {  }, i32, i32)*, {  } } %var_43, 1
    %var_49 = alloca i32
    call void %var_47(i32* %var_49, {  } %var_48, i32 %var_45, i32 %var_46)
    %var_50 = load i32, ptr %var_49
    %var_51 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_27, 0
    %var_52 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_27, 1
    %var_53 = alloca i32
    call void %var_51(i32* %var_53, {  } %var_52, i32 %var_50)
    %var_54 = load i32, ptr %var_53
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %var_19, {  } %var_20, i32 %var_21) {
  entry22: 
    call void @printf(i8* @const_23, i32 %var_21)
    store i32 %var_21, ptr %var_19
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_28(ptr sret(i32) %var_31, {  } %var_32, i32 %var_33, i32 %var_34) {
  entry35: 
    %var_37 = load i32, ptr @const_36
    %var_38 = mul i32 %var_37, %var_33
    %var_39 = add i32 %var_34, %var_38
    store i32 %var_39, ptr %var_31
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > function multiple args > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_23 = constant [3 x i8] c"%i\\00"
@const_36 = local_unnamed_addr constant i32 2
@const_44 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_23, i32 4)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_19, {} %var_20, i32 %var_21) local_unnamed_addr {
entry22:
  tail call void @printf(ptr nonnull @const_23, i32 %var_21)
  store i32 %var_21, ptr %var_19, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_28(ptr nocapture writeonly sret(i32) %var_31, {} %var_32, i32 %var_33, i32 %var_34) local_unnamed_addr #1 {
entry35:
  %var_38 = shl i32 %var_33, 1
  %var_39 = add i32 %var_38, %var_34
  store i32 %var_39, ptr %var_31, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > function multiple args > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > function multiple args > stdout 1`] = `
[
  "4",
]
`;

exports[`simply typed lambda calc compilation > hello world > compiled 1`] = `
"@const_13 = constant [3 x i8] c"%s\\00"
@const_18 = constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_7 = alloca {  }
    %var_8 = load {  }, ptr %var_7
    store {  } %var_8, ptr %var_7
    %var_14 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_15 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_14
    %var_16 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_15, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_17 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_16, {  } %var_8, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_17, ptr %var_14
    %var_19 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_17, 0
    %var_20 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_17, 1
    %var_21 = alloca i8*
    call void %var_19(i8** %var_21, {  } %var_20, i8* @const_18)
    %var_22 = load i8*, ptr %var_21
    ret i32 0
}
define void @"generated_print_i8*"(ptr sret(i8*) %var_9, {  } %var_10, i8* %var_11) {
  entry12: 
    call void @printf(i8* @const_13, i8* %var_11)
    store i8* %var_11, ptr %var_9
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`simply typed lambda calc compilation > hello world > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_13 = constant [3 x i8] c"%s\\00"
@const_18 = constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_13, ptr nonnull @const_18)
  ret i32 0
}

define void @"generated_print_i8*"(ptr nocapture writeonly sret(ptr) %var_9, {} %var_10, ptr %var_11) local_unnamed_addr {
entry12:
  tail call void @printf(ptr nonnull @const_13, ptr %var_11)
  store ptr %var_11, ptr %var_9, align 8
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`simply typed lambda calc compilation > hello world > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > hello world > stdout 1`] = `
[
  "hello world!",
]
`;

exports[`simply typed lambda calc compilation > hello world string > compiled 1`] = `
"@const_5 = constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    ret i32 0
}
"
`;

exports[`simply typed lambda calc compilation > hello world string > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_5 = local_unnamed_addr constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef i32 @main() local_unnamed_addr #0 {
main:
  ret i32 0
}

attributes #0 = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) }
"
`;

exports[`simply typed lambda calc compilation > hello world string > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > hello world string > stdout 1`] = `[]`;

exports[`simply typed lambda calc compilation > print number > compiled 1`] = `
"@const_13 = constant [3 x i8] c"%i\\00"
@const_18 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_7 = alloca {  }
    %var_8 = load {  }, ptr %var_7
    store {  } %var_8, ptr %var_7
    %var_14 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_15 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_14
    %var_16 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_15, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_17 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_16, {  } %var_8, 1
    store { void (i32*, {  }, i32)*, {  } } %var_17, ptr %var_14
    %var_19 = load i32, ptr @const_18
    %var_20 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_17, 0
    %var_21 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_17, 1
    %var_22 = alloca i32
    call void %var_20(i32* %var_22, {  } %var_21, i32 %var_19)
    %var_23 = load i32, ptr %var_22
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %var_9, {  } %var_10, i32 %var_11) {
  entry12: 
    call void @printf(i8* @const_13, i32 %var_11)
    store i32 %var_11, ptr %var_9
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`simply typed lambda calc compilation > print number > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_13 = constant [3 x i8] c"%i\\00"
@const_18 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_13, i32 1)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_9, {} %var_10, i32 %var_11) local_unnamed_addr {
entry12:
  tail call void @printf(ptr nonnull @const_13, i32 %var_11)
  store i32 %var_11, ptr %var_9, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`simply typed lambda calc compilation > print number > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > print number > stdout 1`] = `
[
  "1",
]
`;

exports[`structured programming compilation > block > compiled 1`] = `
"@const_18 = constant [3 x i8] c"%i\\00"
@const_23 = constant i32 123
@const_25 = constant i32 234
@const_27 = constant i32 345
@const_29 = constant i32 456
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_12 = alloca {  }
    %var_13 = load {  }, ptr %var_12
    store {  } %var_13, ptr %var_12
    %var_19 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_20 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_19
    %var_21 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_20, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_22 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_21, {  } %var_13, 1
    store { void (i32*, {  }, i32)*, {  } } %var_22, ptr %var_19
    %var_24 = load i32, ptr @const_23
    %var_26 = load i32, ptr @const_25
    %var_28 = load i32, ptr @const_27
    %var_30 = load i32, ptr @const_29
    %var_31 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_22, 0
    %var_32 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_22, 1
    %var_33 = alloca i32
    call void %var_31(i32* %var_33, {  } %var_32, i32 %var_30)
    %var_34 = load i32, ptr %var_33
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %var_14, {  } %var_15, i32 %var_16) {
  entry17: 
    call void @printf(i8* @const_18, i32 %var_16)
    store i32 %var_16, ptr %var_14
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > block > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_18 = constant [3 x i8] c"%i\\00"
@const_23 = local_unnamed_addr constant i32 123
@const_25 = local_unnamed_addr constant i32 234
@const_27 = local_unnamed_addr constant i32 345
@const_29 = local_unnamed_addr constant i32 456
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_18, i32 456)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_14, {} %var_15, i32 %var_16) local_unnamed_addr {
entry17:
  tail call void @printf(ptr nonnull @const_18, i32 %var_16)
  store i32 %var_16, ptr %var_14, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > block > stderr 1`] = `[]`;

exports[`structured programming compilation > block > stdout 1`] = `
[
  "456",
]
`;

exports[`structured programming compilation > block variable assingment > compiled 1`] = `
"@const_23 = constant [3 x i8] c"%i\\00"
@const_28 = constant i32 123
@const_30 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_17 = alloca {  }
    %var_18 = load {  }, ptr %var_17
    store {  } %var_18, ptr %var_17
    %var_24 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_25 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_24
    %var_26 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_25, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_27 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_26, {  } %var_18, 1
    store { void (i32*, {  }, i32)*, {  } } %var_27, ptr %var_24
    %var_29 = load i32, ptr @const_28
    %var_31 = load i32, ptr @const_30
    %var_32 = add i32 %var_29, %var_31
    %var_33 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_27, 0
    %var_34 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_27, 1
    %var_35 = alloca i32
    call void %var_33(i32* %var_35, {  } %var_34, i32 %var_32)
    %var_36 = load i32, ptr %var_35
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %var_19, {  } %var_20, i32 %var_21) {
  entry22: 
    call void @printf(i8* @const_23, i32 %var_21)
    store i32 %var_21, ptr %var_19
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > block variable assingment > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_23 = constant [3 x i8] c"%i\\00"
@const_28 = local_unnamed_addr constant i32 123
@const_30 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_23, i32 124)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_19, {} %var_20, i32 %var_21) local_unnamed_addr {
entry22:
  tail call void @printf(ptr nonnull @const_23, i32 %var_21)
  store i32 %var_21, ptr %var_19, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > block variable assingment > stderr 1`] = `[]`;

exports[`structured programming compilation > block variable assingment > stdout 1`] = `
[
  "124",
]
`;

exports[`structured programming compilation > block variable declaration > compiled 1`] = `
"@const_18 = constant [3 x i8] c"%i\\00"
@const_23 = constant i32 123
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_12 = alloca {  }
    %var_13 = load {  }, ptr %var_12
    store {  } %var_13, ptr %var_12
    %var_19 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_20 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_19
    %var_21 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_20, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_22 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_21, {  } %var_13, 1
    store { void (i32*, {  }, i32)*, {  } } %var_22, ptr %var_19
    %var_24 = load i32, ptr @const_23
    %var_25 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_22, 0
    %var_26 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_22, 1
    %var_27 = alloca i32
    call void %var_25(i32* %var_27, {  } %var_26, i32 %var_24)
    %var_28 = load i32, ptr %var_27
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %var_14, {  } %var_15, i32 %var_16) {
  entry17: 
    call void @printf(i8* @const_18, i32 %var_16)
    store i32 %var_16, ptr %var_14
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > block variable declaration > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_18 = constant [3 x i8] c"%i\\00"
@const_23 = local_unnamed_addr constant i32 123
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_18, i32 123)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_14, {} %var_15, i32 %var_16) local_unnamed_addr {
entry17:
  tail call void @printf(ptr nonnull @const_18, i32 %var_16)
  store i32 %var_16, ptr %var_14, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > block variable declaration > stderr 1`] = `[]`;

exports[`structured programming compilation > block variable declaration > stdout 1`] = `
[
  "123",
]
`;

exports[`structured programming compilation > block variable shadowing > compiled 1`] = `
"@const_21 = constant [3 x i8] c"%i\\00"
@const_26 = constant i32 123
@const_28 = constant i32 234
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_15 = alloca {  }
    %var_16 = load {  }, ptr %var_15
    store {  } %var_16, ptr %var_15
    %var_22 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_23 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_22
    %var_24 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_23, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_25 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_24, {  } %var_16, 1
    store { void (i32*, {  }, i32)*, {  } } %var_25, ptr %var_22
    %var_27 = load i32, ptr @const_26
    %var_29 = load i32, ptr @const_28
    %var_30 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_25, 0
    %var_31 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_25, 1
    %var_32 = alloca i32
    call void %var_30(i32* %var_32, {  } %var_31, i32 %var_29)
    %var_33 = load i32, ptr %var_32
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %var_17, {  } %var_18, i32 %var_19) {
  entry20: 
    call void @printf(i8* @const_21, i32 %var_19)
    store i32 %var_19, ptr %var_17
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > block variable shadowing > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_21 = constant [3 x i8] c"%i\\00"
@const_26 = local_unnamed_addr constant i32 123
@const_28 = local_unnamed_addr constant i32 234
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_21, i32 234)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_17, {} %var_18, i32 %var_19) local_unnamed_addr {
entry20:
  tail call void @printf(ptr nonnull @const_21, i32 %var_19)
  store i32 %var_19, ptr %var_17, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > block variable shadowing > stderr 1`] = `[]`;

exports[`structured programming compilation > block variable shadowing > stdout 1`] = `
[
  "234",
]
`;

exports[`structured programming compilation > hello world twice > compiled 1`] = `
"@const_16 = constant [3 x i8] c"%s\\00"
@const_21 = constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_10 = alloca {  }
    %var_11 = load {  }, ptr %var_10
    store {  } %var_11, ptr %var_10
    %var_17 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_18 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_17
    %var_19 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_18, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_20 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_19, {  } %var_11, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_20, ptr %var_17
    %var_22 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_20, 0
    %var_23 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_20, 1
    %var_24 = alloca i8*
    call void %var_22(i8** %var_24, {  } %var_23, i8* @const_21)
    %var_25 = load i8*, ptr %var_24
    %var_26 = alloca {  }
    %var_27 = load {  }, ptr %var_26
    store {  } %var_27, ptr %var_26
    %var_28 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_29 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_28
    %var_30 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_29, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_31 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_30, {  } %var_27, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_31, ptr %var_28
    %var_32 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_31, 0
    %var_33 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_31, 1
    %var_34 = alloca i8*
    call void %var_32(i8** %var_34, {  } %var_33, i8* @const_21)
    %var_35 = load i8*, ptr %var_34
    ret i32 0
}
define void @"generated_print_i8*"(ptr sret(i8*) %var_12, {  } %var_13, i8* %var_14) {
  entry15: 
    call void @printf(i8* @const_16, i8* %var_14)
    store i8* %var_14, ptr %var_12
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > hello world twice > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_16 = constant [3 x i8] c"%s\\00"
@const_21 = constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_16, ptr nonnull @const_21)
  tail call void @printf(ptr nonnull @const_16, ptr nonnull @const_21)
  ret i32 0
}

define void @"generated_print_i8*"(ptr nocapture writeonly sret(ptr) %var_12, {} %var_13, ptr %var_14) local_unnamed_addr {
entry15:
  tail call void @printf(ptr nonnull @const_16, ptr %var_14)
  store ptr %var_14, ptr %var_12, align 8
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > hello world twice > stderr 1`] = `[]`;

exports[`structured programming compilation > hello world twice > stdout 1`] = `
[
  "hello world!hello world!",
]
`;

exports[`structured programming compilation > if-then > compiled 1`] = `
"@const_17 = constant [3 x i8] c"%i\\00"
@const_22 = constant i1 1
@const_26 = constant i32 123
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_11 = alloca {  }
    %var_12 = load {  }, ptr %var_11
    store {  } %var_12, ptr %var_11
    %var_18 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_19 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_18
    %var_20 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_19, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_21 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_20, {  } %var_12, 1
    store { void (i32*, {  }, i32)*, {  } } %var_21, ptr %var_18
    %var_23 = load i1, ptr @const_22
    br i1 %var_23, label %then25, label %if_rest24
  then25: 
    %var_27 = load i32, ptr @const_26
    br label %if_rest24
  if_rest24: 
    %var_28 = phi i32 [%var_27, %then25], [undef, %main]
    %var_29 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_21, 0
    %var_30 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_21, 1
    %var_31 = alloca i32
    call void %var_29(i32* %var_31, {  } %var_30, i32 %var_28)
    %var_32 = load i32, ptr %var_31
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %var_13, {  } %var_14, i32 %var_15) {
  entry16: 
    call void @printf(i8* @const_17, i32 %var_15)
    store i32 %var_15, ptr %var_13
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > if-then > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_17 = constant [3 x i8] c"%i\\00"
@const_22 = local_unnamed_addr constant i1 true
@const_26 = local_unnamed_addr constant i32 123
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_17, i32 123)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_13, {} %var_14, i32 %var_15) local_unnamed_addr {
entry16:
  tail call void @printf(ptr nonnull @const_17, i32 %var_15)
  store i32 %var_15, ptr %var_13, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > if-then > stderr 1`] = `[]`;

exports[`structured programming compilation > if-then > stdout 1`] = `
[
  "123",
]
`;

exports[`structured programming compilation > if-then-else > compiled 1`] = `
"@const_20 = constant [3 x i8] c"%i\\00"
@const_25 = constant i1 0
@const_29 = constant i32 123
@const_32 = constant i32 456
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_14 = alloca {  }
    %var_15 = load {  }, ptr %var_14
    store {  } %var_15, ptr %var_14
    %var_21 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_22 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_21
    %var_23 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_22, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_24 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_23, {  } %var_15, 1
    store { void (i32*, {  }, i32)*, {  } } %var_24, ptr %var_21
    %var_26 = load i1, ptr @const_25
    br i1 %var_26, label %then28, label %else31
  then28: 
    %var_30 = load i32, ptr @const_29
    br label %if_rest27
  else31: 
    %var_33 = load i32, ptr @const_32
    br label %if_rest27
  if_rest27: 
    %var_34 = phi i32 [%var_30, %then28], [%var_33, %else31]
    %var_35 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_24, 0
    %var_36 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_24, 1
    %var_37 = alloca i32
    call void %var_35(i32* %var_37, {  } %var_36, i32 %var_34)
    %var_38 = load i32, ptr %var_37
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %var_16, {  } %var_17, i32 %var_18) {
  entry19: 
    call void @printf(i8* @const_20, i32 %var_18)
    store i32 %var_18, ptr %var_16
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > if-then-else > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_20 = constant [3 x i8] c"%i\\00"
@const_25 = local_unnamed_addr constant i1 false
@const_29 = local_unnamed_addr constant i32 123
@const_32 = local_unnamed_addr constant i32 456
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_20, i32 456)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_16, {} %var_17, i32 %var_18) local_unnamed_addr {
entry19:
  tail call void @printf(ptr nonnull @const_20, i32 %var_18)
  store i32 %var_18, ptr %var_16, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > if-then-else > stderr 1`] = `[]`;

exports[`structured programming compilation > if-then-else > stdout 1`] = `
[
  "456",
]
`;

exports[`structured programming compilation > sequence > compiled 1`] = `
"@const_17 = constant [3 x i8] c"%i\\00"
@const_22 = constant i32 123
@const_24 = constant i32 234
@const_26 = constant i32 345
@const_28 = constant i32 456
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_11 = alloca {  }
    %var_12 = load {  }, ptr %var_11
    store {  } %var_12, ptr %var_11
    %var_18 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_19 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_18
    %var_20 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_19, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_21 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_20, {  } %var_12, 1
    store { void (i32*, {  }, i32)*, {  } } %var_21, ptr %var_18
    %var_23 = load i32, ptr @const_22
    %var_25 = load i32, ptr @const_24
    %var_27 = load i32, ptr @const_26
    %var_29 = load i32, ptr @const_28
    %var_30 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_21, 0
    %var_31 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_21, 1
    %var_32 = alloca i32
    call void %var_30(i32* %var_32, {  } %var_31, i32 %var_29)
    %var_33 = load i32, ptr %var_32
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %var_13, {  } %var_14, i32 %var_15) {
  entry16: 
    call void @printf(i8* @const_17, i32 %var_15)
    store i32 %var_15, ptr %var_13
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > sequence > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_17 = constant [3 x i8] c"%i\\00"
@const_22 = local_unnamed_addr constant i32 123
@const_24 = local_unnamed_addr constant i32 234
@const_26 = local_unnamed_addr constant i32 345
@const_28 = local_unnamed_addr constant i32 456
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_17, i32 456)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %var_13, {} %var_14, i32 %var_15) local_unnamed_addr {
entry16:
  tail call void @printf(ptr nonnull @const_17, i32 %var_15)
  store i32 %var_15, ptr %var_13, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > sequence > stderr 1`] = `[]`;

exports[`structured programming compilation > sequence > stdout 1`] = `
[
  "456",
]
`;

exports[`structured programming compilation > two prints > compiled 1`] = `
"@const_16 = constant [3 x i8] c"%s\\00"
@const_21 = constant [13 x i8] c"hello world!\\00"
@const_32 = constant [15 x i8] c"hello world 2!\\00"
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_10 = alloca {  }
    %var_11 = load {  }, ptr %var_10
    store {  } %var_11, ptr %var_10
    %var_17 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_18 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_17
    %var_19 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_18, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_20 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_19, {  } %var_11, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_20, ptr %var_17
    %var_22 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_20, 0
    %var_23 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_20, 1
    %var_24 = alloca i8*
    call void %var_22(i8** %var_24, {  } %var_23, i8* @const_21)
    %var_25 = load i8*, ptr %var_24
    %var_26 = alloca {  }
    %var_27 = load {  }, ptr %var_26
    store {  } %var_27, ptr %var_26
    %var_28 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_29 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_28
    %var_30 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_29, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_31 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_30, {  } %var_27, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_31, ptr %var_28
    %var_33 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_31, 0
    %var_34 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_31, 1
    %var_35 = alloca i8*
    call void %var_33(i8** %var_35, {  } %var_34, i8* @const_32)
    %var_36 = load i8*, ptr %var_35
    ret i32 0
}
define void @"generated_print_i8*"(ptr sret(i8*) %var_12, {  } %var_13, i8* %var_14) {
  entry15: 
    call void @printf(i8* @const_16, i8* %var_14)
    store i8* %var_14, ptr %var_12
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > two prints > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_16 = constant [3 x i8] c"%s\\00"
@const_21 = constant [13 x i8] c"hello world!\\00"
@const_32 = constant [15 x i8] c"hello world 2!\\00"
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_16, ptr nonnull @const_21)
  tail call void @printf(ptr nonnull @const_16, ptr nonnull @const_32)
  ret i32 0
}

define void @"generated_print_i8*"(ptr nocapture writeonly sret(ptr) %var_12, {} %var_13, ptr %var_14) local_unnamed_addr {
entry15:
  tail call void @printf(ptr nonnull @const_16, ptr %var_14)
  store ptr %var_14, ptr %var_12, align 8
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > two prints > stderr 1`] = `[]`;

exports[`structured programming compilation > two prints > stdout 1`] = `
[
  "hello world!hello world 2!",
]
`;
