// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`data structures compilation > atom (global symbol) > compiled 1`] = `
"@const_0 = constant i64 0
@const_1 = constant [7 x i8] c"atom_a\\00"
@symbols_metadata_array = constant [1 x { i8* }] [{ i8* } { i8* @const_1 }]
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_0 = alloca {  }
    %var_1 = load {  }, ptr %var_0
    store {  } %var_1, ptr %var_0
    %var_2 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_3 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_2
    %var_4 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_3, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_5 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_4, {  } %var_1, 1
    store { void (i64*, {  }, i64)*, {  } } %var_5, ptr %var_2
    %var_6 = load i64, ptr @const_0
    %var_7 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_5, 0
    %var_8 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_5, 1
    %var_9 = alloca i64
    call void %var_7(i64* %var_9, {  } %var_8, i64 %var_6)
    %var_10 = load i64, ptr %var_9
    ret i32 0
}
define void @"generated_print_symbol"(ptr sret(i64) %arg_0, {  } %arg_1, i64 %arg_2) {
  entry_0: 
    call void @print_symbol(i64 %arg_2)
    store i64 %arg_2, ptr %arg_0
    ret void
}
declare void @print_symbol(i64)
"
`;

exports[`data structures compilation > atom (global symbol) > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = local_unnamed_addr constant i64 0
@const_1 = constant [7 x i8] c"atom_a\\00"
@symbols_metadata_array = constant [1 x { ptr }] [{ ptr } { ptr @const_1 }]
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @print_symbol(i64 0)
  ret i32 0
}

define void @generated_print_symbol(ptr nocapture writeonly sret(i64) %arg_0, {} %arg_1, i64 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @print_symbol(i64 %arg_2)
  store i64 %arg_2, ptr %arg_0, align 8
  ret void
}

declare void @print_symbol(i64) local_unnamed_addr
"
`;

exports[`data structures compilation > atom (global symbol) > stderr 1`] = `[]`;

exports[`data structures compilation > atom (global symbol) > stdout 1`] = `
[
  "symbol(atom_a)",
]
`;

exports[`data structures compilation > boolean false > compiled 1`] = `
"@const_0 = constant [5 x i8] c"true\\00"
@const_1 = constant [6 x i8] c"false\\00"
@const_2 = constant [3 x i8] c"%s\\00"
@const_3 = constant i1 0
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_0 = alloca {  }
    %var_1 = load {  }, ptr %var_0
    store {  } %var_1, ptr %var_0
    %var_2 = alloca { void (i1*, {  }, i1)*, {  } }
    %var_3 = load { void (i1*, {  }, i1)*, {  } }, ptr %var_2
    %var_4 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_3, void (i1*, {  }, i1)* @"generated_print_i1", 0
    %var_5 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_4, {  } %var_1, 1
    store { void (i1*, {  }, i1)*, {  } } %var_5, ptr %var_2
    %var_6 = load i1, ptr @const_3
    %var_7 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_5, 0
    %var_8 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_5, 1
    %var_9 = alloca i1
    call void %var_7(i1* %var_9, {  } %var_8, i1 %var_6)
    %var_10 = load i1, ptr %var_9
    ret i32 0
}
define void @"generated_print_i1"(ptr sret(i1) %arg_0, {  } %arg_1, i1 %arg_2) {
  entry_0: 
    %var_0 = select i1 %arg_2, [5 x i8]* @const_0, [5 x i8]* @const_1
    call void @printf(i8* @const_2, [5 x i8]* %var_0)
    store i1 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`data structures compilation > boolean false > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [5 x i8] c"true\\00"
@const_1 = constant [6 x i8] c"false\\00"
@const_2 = constant [3 x i8] c"%s\\00"
@const_3 = local_unnamed_addr constant i1 false
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_2, ptr nonnull @const_1)
  ret i32 0
}

define void @generated_print_i1(ptr nocapture writeonly sret(i1) %arg_0, {} %arg_1, i1 %arg_2) local_unnamed_addr {
entry_0:
  %var_0 = select i1 %arg_2, ptr @const_0, ptr @const_1
  tail call void @printf(ptr nonnull @const_2, ptr nonnull %var_0)
  store i1 %arg_2, ptr %arg_0, align 1
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`data structures compilation > boolean false > stderr 1`] = `[]`;

exports[`data structures compilation > boolean false > stdout 1`] = `
[
  "false",
]
`;

exports[`data structures compilation > boolean true > compiled 1`] = `
"@const_0 = constant [5 x i8] c"true\\00"
@const_1 = constant [6 x i8] c"false\\00"
@const_2 = constant [3 x i8] c"%s\\00"
@const_3 = constant i1 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_0 = alloca {  }
    %var_1 = load {  }, ptr %var_0
    store {  } %var_1, ptr %var_0
    %var_2 = alloca { void (i1*, {  }, i1)*, {  } }
    %var_3 = load { void (i1*, {  }, i1)*, {  } }, ptr %var_2
    %var_4 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_3, void (i1*, {  }, i1)* @"generated_print_i1", 0
    %var_5 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_4, {  } %var_1, 1
    store { void (i1*, {  }, i1)*, {  } } %var_5, ptr %var_2
    %var_6 = load i1, ptr @const_3
    %var_7 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_5, 0
    %var_8 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_5, 1
    %var_9 = alloca i1
    call void %var_7(i1* %var_9, {  } %var_8, i1 %var_6)
    %var_10 = load i1, ptr %var_9
    ret i32 0
}
define void @"generated_print_i1"(ptr sret(i1) %arg_0, {  } %arg_1, i1 %arg_2) {
  entry_0: 
    %var_0 = select i1 %arg_2, [5 x i8]* @const_0, [5 x i8]* @const_1
    call void @printf(i8* @const_2, [5 x i8]* %var_0)
    store i1 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`data structures compilation > boolean true > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [5 x i8] c"true\\00"
@const_1 = constant [6 x i8] c"false\\00"
@const_2 = constant [3 x i8] c"%s\\00"
@const_3 = local_unnamed_addr constant i1 true
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_2, ptr nonnull @const_0)
  ret i32 0
}

define void @generated_print_i1(ptr nocapture writeonly sret(i1) %arg_0, {} %arg_1, i1 %arg_2) local_unnamed_addr {
entry_0:
  %var_0 = select i1 %arg_2, ptr @const_0, ptr @const_1
  tail call void @printf(ptr nonnull @const_2, ptr nonnull %var_0)
  store i1 %arg_2, ptr %arg_0, align 1
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`data structures compilation > boolean true > stderr 1`] = `[]`;

exports[`data structures compilation > boolean true > stdout 1`] = `
[
  "true",
]
`;

exports[`data structures compilation > symbol > compiled 1`] = `
"@const_0 = constant i64 0
@const_1 = constant [10 x i8] c"symbol_ab\\00"
@symbols_metadata_array = constant [1 x { i8* }] [{ i8* } { i8* @const_1 }]
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_0 = alloca {  }
    %var_1 = load {  }, ptr %var_0
    store {  } %var_1, ptr %var_0
    %var_2 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_3 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_2
    %var_4 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_3, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_5 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_4, {  } %var_1, 1
    store { void (i64*, {  }, i64)*, {  } } %var_5, ptr %var_2
    %var_6 = load i64, ptr @const_0
    %var_7 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_5, 0
    %var_8 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_5, 1
    %var_9 = alloca i64
    call void %var_7(i64* %var_9, {  } %var_8, i64 %var_6)
    %var_10 = load i64, ptr %var_9
    ret i32 0
}
define void @"generated_print_symbol"(ptr sret(i64) %arg_0, {  } %arg_1, i64 %arg_2) {
  entry_0: 
    call void @print_symbol(i64 %arg_2)
    store i64 %arg_2, ptr %arg_0
    ret void
}
declare void @print_symbol(i64)
"
`;

exports[`data structures compilation > symbol > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = local_unnamed_addr constant i64 0
@const_1 = constant [10 x i8] c"symbol_ab\\00"
@symbols_metadata_array = constant [1 x { ptr }] [{ ptr } { ptr @const_1 }]
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @print_symbol(i64 0)
  ret i32 0
}

define void @generated_print_symbol(ptr nocapture writeonly sret(i64) %arg_0, {} %arg_1, i64 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @print_symbol(i64 %arg_2)
  store i64 %arg_2, ptr %arg_0, align 8
  ret void
}

declare void @print_symbol(i64) local_unnamed_addr
"
`;

exports[`data structures compilation > symbol > stderr 1`] = `[]`;

exports[`data structures compilation > symbol > stdout 1`] = `
[
  "symbol(symbol_ab)",
]
`;

exports[`data structures compilation > tuple > compiled 1`] = `
"@const_0 = constant [7 x i8] c"tuple(\\00"
@const_1 = constant [3 x i8] c"%s\\00"
@const_2 = constant [3 x i8] c"%i\\00"
@const_3 = constant [3 x i8] c", \\00"
@const_4 = constant [2 x i8] c")\\00"
@const_5 = constant i32 1
@const_6 = constant [3 x i8] c"ab\\00"
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_0 = alloca {  }
    %var_1 = load {  }, ptr %var_0
    store {  } %var_1, ptr %var_0
    %var_2 = alloca { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } }
    %var_3 = load { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } }, ptr %var_2
    %var_4 = insertvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_3, void ({ i32, i8* }*, {  }, { i32, i8* })* @"generated_print_(i32, i8*)", 0
    %var_5 = insertvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_4, {  } %var_1, 1
    store { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_5, ptr %var_2
    %var_6 = load i32, ptr @const_5
    %var_7 = alloca { i32 }
    %var_8 = load { i32 }, ptr %var_7
    %var_9 = insertvalue { i32 } %var_8, i32 %var_6, 0
    store { i32 } %var_9, ptr %var_7
    %var_10 = extractvalue { i32 } %var_9, 0
    %var_11 = alloca { i32, [3 x i8]* }
    %var_12 = load { i32, [3 x i8]* }, ptr %var_11
    %var_13 = insertvalue { i32, [3 x i8]* } %var_12, i32 %var_10, 0
    %var_14 = insertvalue { i32, [3 x i8]* } %var_13, [3 x i8]* @const_6, 1
    store { i32, [3 x i8]* } %var_14, ptr %var_11
    %var_15 = extractvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_5, 0
    %var_16 = extractvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_5, 1
    %var_17 = alloca { i32, i8* }
    call void %var_15({ i32, i8* }* %var_17, {  } %var_16, { i32, i8* } %var_14)
    %var_18 = load { i32, i8* }, ptr %var_17
    ret i32 0
}
define void @"generated_print_(i32, i8*)"(ptr sret({ i32, i8* }) %arg_0, {  } %arg_1, { i32, i8* } %arg_2) {
  entry_0: 
    call void @printf(i8* @const_1, [7 x i8]* @const_0)
    %var_0 = extractvalue { i32, i8* } %arg_2, 0
    %var_1 = alloca {  }
    %var_2 = load {  }, ptr %var_1
    store {  } %var_2, ptr %var_1
    %var_3 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_4 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_3
    %var_5 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_4, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_6 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_5, {  } %var_2, 1
    store { void (i32*, {  }, i32)*, {  } } %var_6, ptr %var_3
    %var_7 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_6, 0
    %var_8 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_6, 1
    %var_9 = alloca i32
    call void %var_7(i32* %var_9, {  } %var_8, i32 %var_0)
    %var_10 = load i32, ptr %var_9
    call void @printf(i8* @const_1, [3 x i8]* @const_3)
    %var_11 = extractvalue { i32, i8* } %arg_2, 1
    %var_12 = alloca {  }
    %var_13 = load {  }, ptr %var_12
    store {  } %var_13, ptr %var_12
    %var_14 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_15 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_14
    %var_16 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_15, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_17 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_16, {  } %var_13, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_17, ptr %var_14
    %var_18 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_17, 0
    %var_19 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_17, 1
    %var_20 = alloca i8*
    call void %var_18(i8** %var_20, {  } %var_19, i8* %var_11)
    %var_21 = load i8*, ptr %var_20
    call void @printf(i8* @const_1, [2 x i8]* @const_4)
    store { i32, i8* } %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_2, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
define void @"generated_print_i8*"(ptr sret(i8*) %arg_0, {  } %arg_1, i8* %arg_2) {
  entry_0: 
    call void @printf(i8* @const_1, i8* %arg_2)
    store i8* %arg_2, ptr %arg_0
    ret void
}
"
`;

exports[`data structures compilation > tuple > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [7 x i8] c"tuple(\\00"
@const_1 = constant [3 x i8] c"%s\\00"
@const_2 = constant [3 x i8] c"%i\\00"
@const_3 = constant [3 x i8] c", \\00"
@const_4 = constant [2 x i8] c")\\00"
@const_5 = local_unnamed_addr constant i32 1
@const_6 = constant [3 x i8] c"ab\\00"
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_0)
  tail call void @printf(ptr nonnull @const_2, i32 1)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_3)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_6)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_4)
  ret i32 0
}

define void @"generated_print_(i32, i8*)"(ptr nocapture writeonly sret({ i32, ptr }) %arg_0, {} %arg_1, { i32, ptr } %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_0)
  %var_0 = extractvalue { i32, ptr } %arg_2, 0
  tail call void @printf(ptr nonnull @const_2, i32 %var_0)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_3)
  %var_11 = extractvalue { i32, ptr } %arg_2, 1
  tail call void @printf(ptr nonnull @const_1, ptr %var_11)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_4)
  store { i32, ptr } %arg_2, ptr %arg_0, align 8
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_2, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

define void @"generated_print_i8*"(ptr nocapture writeonly sret(ptr) %arg_0, {} %arg_1, ptr %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_1, ptr %arg_2)
  store ptr %arg_2, ptr %arg_0, align 8
  ret void
}

attributes #0 = { nofree nounwind }
"
`;

exports[`data structures compilation > tuple > stderr 1`] = `[]`;

exports[`data structures compilation > tuple > stdout 1`] = `
[
  "tuple(1, ab)",
]
`;

exports[`data structures compilation > unit > compiled 1`] = `
"@const_0 = constant i64 0
@const_1 = constant [5 x i8] c"unit\\00"
@symbols_metadata_array = constant [1 x { i8* }] [{ i8* } { i8* @const_1 }]
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_0 = alloca {  }
    %var_1 = load {  }, ptr %var_0
    store {  } %var_1, ptr %var_0
    %var_2 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_3 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_2
    %var_4 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_3, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_5 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_4, {  } %var_1, 1
    store { void (i64*, {  }, i64)*, {  } } %var_5, ptr %var_2
    %var_6 = load i64, ptr @const_0
    %var_7 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_5, 0
    %var_8 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_5, 1
    %var_9 = alloca i64
    call void %var_7(i64* %var_9, {  } %var_8, i64 %var_6)
    %var_10 = load i64, ptr %var_9
    ret i32 0
}
define void @"generated_print_symbol"(ptr sret(i64) %arg_0, {  } %arg_1, i64 %arg_2) {
  entry_0: 
    call void @print_symbol(i64 %arg_2)
    store i64 %arg_2, ptr %arg_0
    ret void
}
declare void @print_symbol(i64)
"
`;

exports[`data structures compilation > unit > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = local_unnamed_addr constant i64 0
@const_1 = constant [5 x i8] c"unit\\00"
@symbols_metadata_array = constant [1 x { ptr }] [{ ptr } { ptr @const_1 }]
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @print_symbol(i64 0)
  ret i32 0
}

define void @generated_print_symbol(ptr nocapture writeonly sret(i64) %arg_0, {} %arg_1, i64 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @print_symbol(i64 %arg_2)
  store i64 %arg_2, ptr %arg_0, align 8
  ret void
}

declare void @print_symbol(i64) local_unnamed_addr
"
`;

exports[`data structures compilation > unit > stderr 1`] = `[]`;

exports[`data structures compilation > unit > stdout 1`] = `
[
  "symbol(unit)",
]
`;

exports[`effect handlers compilation > inject > compiled 1`] = `
"@const_0 = constant [7 x i8] c"tuple(\\00"
@const_1 = constant [3 x i8] c"%s\\00"
@const_2 = constant [3 x i8] c"%i\\00"
@const_3 = constant [3 x i8] c", \\00"
@const_4 = constant [2 x i8] c")\\00"
@const_5 = constant i64 16
@const_6 = constant i64 0
@const_7 = constant i64 1
@const_8 = constant i64 2
@const_9 = constant { i64, i64 } { i64 0, i64 0 }
@const_10 = constant [2 x { i32, { i64, i64 }*, i64 (ptr, i64, i64)* }] [{ i32, { i64, i64 }*, i64 (ptr, i64, i64)* } { i32 7, { i64, i64 }* @const_9, i64 (ptr, i64, i64)* @handler_a }, { i32, { i64, i64 }*, i64 (ptr, i64, i64)* } zeroinitializer]
@const_11 = constant i64 40
@const_12 = constant i64 128
@const_13 = constant { i64, i64 } { i64 2, i64 0 }
@const_14 = constant [2 x { i32, { i64, i64 }*, i64 (ptr, i64, i64)* }] [{ i32, { i64, i64 }*, i64 (ptr, i64, i64)* } { i32 7, { i64, i64 }* @const_13, i64 (ptr, i64, i64)* @handler_b }, { i32, { i64, i64 }*, i64 (ptr, i64, i64)* } zeroinitializer]
@const_15 = constant [10 x i8] c"handler_a\\00"
@const_16 = constant [5 x i8] c"unit\\00"
@const_17 = constant [10 x i8] c"handler_b\\00"
@symbols_metadata_array = constant [3 x { i8* }] [{ i8* } { i8* @const_15 }, { i8* } { i8* @const_16 }, { i8* } { i8* @const_17 }]
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_0 = alloca {  }
    %var_1 = load {  }, ptr %var_0
    store {  } %var_1, ptr %var_0
    %var_2 = alloca { void ({ i64, i64 }*, {  }, { i64, i64 })*, {  } }
    %var_3 = load { void ({ i64, i64 }*, {  }, { i64, i64 })*, {  } }, ptr %var_2
    %var_4 = insertvalue { void ({ i64, i64 }*, {  }, { i64, i64 })*, {  } } %var_3, void ({ i64, i64 }*, {  }, { i64, i64 })* @"generated_print_(i64, i64)", 0
    %var_5 = insertvalue { void ({ i64, i64 }*, {  }, { i64, i64 })*, {  } } %var_4, {  } %var_1, 1
    store { void ({ i64, i64 }*, {  }, { i64, i64 })*, {  } } %var_5, ptr %var_2
    %var_6 = alloca { i64, ptr, ptr, i64 (i64, i64)*, [2 x { i32, { i64, i64 }*, i64 (ptr, i64, i64)* }]* }
    %var_7 = load { i64, ptr, ptr, i64 (i64, i64)*, [2 x { i32, { i64, i64 }*, i64 (ptr, i64, i64)* }]* }, ptr %var_6
    %var_8 = insertvalue { i64, ptr, ptr, i64 (i64, i64)*, [2 x { i32, { i64, i64 }*, i64 (ptr, i64, i64)* }]* } %var_7, i64 2, 0
    %var_9 = insertvalue { i64, ptr, ptr, i64 (i64, i64)*, [2 x { i32, { i64, i64 }*, i64 (ptr, i64, i64)* }]* } %var_8, ptr null, 1
    %var_10 = insertvalue { i64, ptr, ptr, i64 (i64, i64)*, [2 x { i32, { i64, i64 }*, i64 (ptr, i64, i64)* }]* } %var_9, ptr null, 2
    %var_11 = insertvalue { i64, ptr, ptr, i64 (i64, i64)*, [2 x { i32, { i64, i64 }*, i64 (ptr, i64, i64)* }]* } %var_10, i64 (i64, i64)* @identity_ret_handler, 3
    %var_12 = insertvalue { i64, ptr, ptr, i64 (i64, i64)*, [2 x { i32, { i64, i64 }*, i64 (ptr, i64, i64)* }]* } %var_11, [2 x { i32, { i64, i64 }*, i64 (ptr, i64, i64)* }]* @const_14, 4
    store { i64, ptr, ptr, i64 (i64, i64)*, [2 x { i32, { i64, i64 }*, i64 (ptr, i64, i64)* }]* } %var_12, ptr %var_6
    %var_13 = load i64, ptr @const_11
    %var_14 = call { ptr, ptr, ptr, ptr, ptr }* @malloc(i64 %var_13)
    store { i64, ptr, ptr, i64 (i64, i64)*, [2 x { i32, { i64, i64 }*, i64 (ptr, i64, i64)* }]* } %var_12, ptr %var_14
    %var_15 = load i64, ptr @const_12
    %var_16 = call { i64, i64 }* @malloc(i64 %var_15)
    %var_17 = ptrtoint ptr %var_16 to i64
    call void @lh_handle(ptr %var_14, i64 0, ptr @handleable_72, i64 %var_17)
    %var_18 = load { i64, i64 }, ptr %var_16
    call void @free(ptr %var_16)
    call void @free(ptr %var_14)
    %var_19 = extractvalue { void ({ i64, i64 }*, {  }, { i64, i64 })*, {  } } %var_5, 0
    %var_20 = extractvalue { void ({ i64, i64 }*, {  }, { i64, i64 })*, {  } } %var_5, 1
    %var_21 = alloca { i64, i64 }
    call void %var_19({ i64, i64 }* %var_21, {  } %var_20, { i64, i64 } %var_18)
    %var_22 = load { i64, i64 }, ptr %var_21
    ret i32 0
}
define void @"generated_print_(i64, i64)"(ptr sret({ i64, i64 }) %arg_0, {  } %arg_1, { i64, i64 } %arg_2) {
  entry_0: 
    call void @printf(i8* @const_1, [7 x i8]* @const_0)
    %var_0 = extractvalue { i64, i64 } %arg_2, 0
    %var_1 = alloca {  }
    %var_2 = load {  }, ptr %var_1
    store {  } %var_2, ptr %var_1
    %var_3 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_4 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_3
    %var_5 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_4, void (i64*, {  }, i64)* @"generated_print_i64", 0
    %var_6 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_5, {  } %var_2, 1
    store { void (i64*, {  }, i64)*, {  } } %var_6, ptr %var_3
    %var_7 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_6, 0
    %var_8 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_6, 1
    %var_9 = alloca i64
    call void %var_7(i64* %var_9, {  } %var_8, i64 %var_0)
    %var_10 = load i64, ptr %var_9
    call void @printf(i8* @const_1, [3 x i8]* @const_3)
    %var_11 = extractvalue { i64, i64 } %arg_2, 1
    %var_12 = alloca {  }
    %var_13 = load {  }, ptr %var_12
    store {  } %var_13, ptr %var_12
    %var_14 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_15 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_14
    %var_16 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_15, void (i64*, {  }, i64)* @"generated_print_i64", 0
    %var_17 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_16, {  } %var_13, 1
    store { void (i64*, {  }, i64)*, {  } } %var_17, ptr %var_14
    %var_18 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_17, 0
    %var_19 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_17, 1
    %var_20 = alloca i64
    call void %var_18(i64* %var_20, {  } %var_19, i64 %var_11)
    %var_21 = load i64, ptr %var_20
    call void @printf(i8* @const_1, [2 x i8]* @const_4)
    store { i64, i64 } %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @"generated_print_i64"(ptr sret(i64) %arg_0, {  } %arg_1, i64 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_2, i64 %arg_2)
    store i64 %arg_2, ptr %arg_0
    ret void
}
define void @handleable_72(ptr sret({ i64, i64 }) %arg_0) {
  entry_0: 
    %var_0 = alloca { i64, ptr, ptr, i64 (i64, i64)*, [2 x { i32, { i64, i64 }*, i64 (ptr, i64, i64)* }]* }
    %var_1 = load { i64, ptr, ptr, i64 (i64, i64)*, [2 x { i32, { i64, i64 }*, i64 (ptr, i64, i64)* }]* }, ptr %var_0
    %var_2 = insertvalue { i64, ptr, ptr, i64 (i64, i64)*, [2 x { i32, { i64, i64 }*, i64 (ptr, i64, i64)* }]* } %var_1, i64 0, 0
    %var_3 = insertvalue { i64, ptr, ptr, i64 (i64, i64)*, [2 x { i32, { i64, i64 }*, i64 (ptr, i64, i64)* }]* } %var_2, ptr null, 1
    %var_4 = insertvalue { i64, ptr, ptr, i64 (i64, i64)*, [2 x { i32, { i64, i64 }*, i64 (ptr, i64, i64)* }]* } %var_3, ptr null, 2
    %var_5 = insertvalue { i64, ptr, ptr, i64 (i64, i64)*, [2 x { i32, { i64, i64 }*, i64 (ptr, i64, i64)* }]* } %var_4, i64 (i64, i64)* @identity_ret_handler, 3
    %var_6 = insertvalue { i64, ptr, ptr, i64 (i64, i64)*, [2 x { i32, { i64, i64 }*, i64 (ptr, i64, i64)* }]* } %var_5, [2 x { i32, { i64, i64 }*, i64 (ptr, i64, i64)* }]* @const_10, 4
    store { i64, ptr, ptr, i64 (i64, i64)*, [2 x { i32, { i64, i64 }*, i64 (ptr, i64, i64)* }]* } %var_6, ptr %var_0
    %var_7 = load i64, ptr @const_11
    %var_8 = call { ptr, ptr, ptr, ptr, ptr }* @malloc(i64 %var_7)
    store { i64, ptr, ptr, i64 (i64, i64)*, [2 x { i32, { i64, i64 }*, i64 (ptr, i64, i64)* }]* } %var_6, ptr %var_8
    %var_9 = load i64, ptr @const_12
    %var_10 = call { i64, i64 }* @malloc(i64 %var_9)
    %var_11 = ptrtoint ptr %var_10 to i64
    call void @lh_handle(ptr %var_8, i64 0, ptr @handleable_63, i64 %var_11)
    %var_12 = load { i64, i64 }, ptr %var_10
    call void @free(ptr %var_10)
    call void @free(ptr %var_8)
    store { i64, i64 } %var_12, ptr %arg_0
    ret void
}
define void @handleable_63(ptr sret({ i64, i64 }) %arg_0) {
  entry_0: 
    %var_0 = alloca {  }
    %var_1 = load {  }, ptr %var_0
    store {  } %var_1, ptr %var_0
    %var_2 = alloca { void (ptr, {  }, i64)*, {  } }
    %var_3 = load { void (ptr, {  }, i64)*, {  } }, ptr %var_2
    %var_4 = insertvalue { void (ptr, {  }, i64)*, {  } } %var_3, void (ptr, {  }, i64)* @malloc_wrap, 0
    %var_5 = insertvalue { void (ptr, {  }, i64)*, {  } } %var_4, {  } %var_1, 1
    store { void (ptr, {  }, i64)*, {  } } %var_5, ptr %var_2
    %var_6 = load i64, ptr @const_5
    %var_7 = extractvalue { void (ptr, {  }, i64)*, {  } } %var_5, 0
    %var_8 = extractvalue { void (ptr, {  }, i64)*, {  } } %var_5, 1
    %var_9 = alloca ptr
    call void %var_7(ptr %var_9, {  } %var_8, i64 %var_6)
    %var_10 = load ptr, ptr %var_9
    %var_11 = load i64, ptr @const_6
    %var_12 = alloca { i64 }
    %var_13 = load { i64 }, ptr %var_12
    %var_14 = insertvalue { i64 } %var_13, i64 %var_11, 0
    store { i64 } %var_14, ptr %var_12
    %var_15 = load i64, ptr @const_6
    %var_16 = extractvalue { i64 } %var_14, 0
    %var_17 = alloca { i64, i64 }
    %var_18 = load { i64, i64 }, ptr %var_17
    %var_19 = insertvalue { i64, i64 } %var_18, i64 %var_16, 0
    %var_20 = insertvalue { i64, i64 } %var_19, i64 %var_15, 1
    store { i64, i64 } %var_20, ptr %var_17
    store { i64, i64 } %var_20, ptr %var_10
    %var_21 = alloca {  }
    %var_22 = load {  }, ptr %var_21
    store {  } %var_22, ptr %var_21
    %var_23 = alloca { void (i64*, {  }, ptr, i64)*, {  } }
    %var_24 = load { void (i64*, {  }, ptr, i64)*, {  } }, ptr %var_23
    %var_25 = insertvalue { void (i64*, {  }, ptr, i64)*, {  } } %var_24, void (i64*, {  }, ptr, i64)* @lh_yield_wrap, 0
    %var_26 = insertvalue { void (i64*, {  }, ptr, i64)*, {  } } %var_25, {  } %var_22, 1
    store { void (i64*, {  }, ptr, i64)*, {  } } %var_26, ptr %var_23
    %var_27 = load i64, ptr @const_7
    %var_28 = extractvalue { void (i64*, {  }, ptr, i64)*, {  } } %var_26, 0
    %var_29 = extractvalue { void (i64*, {  }, ptr, i64)*, {  } } %var_26, 1
    %var_30 = alloca i64
    call void %var_28(i64* %var_30, {  } %var_29, ptr %var_10, i64 %var_27)
    %var_31 = load i64, ptr %var_30
    %var_32 = alloca {  }
    %var_33 = load {  }, ptr %var_32
    store {  } %var_33, ptr %var_32
    %var_34 = alloca { void (i8*, {  }, ptr)*, {  } }
    %var_35 = load { void (i8*, {  }, ptr)*, {  } }, ptr %var_34
    %var_36 = insertvalue { void (i8*, {  }, ptr)*, {  } } %var_35, void (i8*, {  }, ptr)* @free_wrap, 0
    %var_37 = insertvalue { void (i8*, {  }, ptr)*, {  } } %var_36, {  } %var_33, 1
    store { void (i8*, {  }, ptr)*, {  } } %var_37, ptr %var_34
    %var_38 = extractvalue { void (i8*, {  }, ptr)*, {  } } %var_37, 0
    %var_39 = extractvalue { void (i8*, {  }, ptr)*, {  } } %var_37, 1
    %var_40 = alloca i8
    call void %var_38(i8* %var_40, {  } %var_39, ptr %var_10)
    %var_41 = load i8, ptr %var_40
    %var_42 = alloca { i64 }
    %var_43 = load { i64 }, ptr %var_42
    %var_44 = insertvalue { i64 } %var_43, i64 %var_31, 0
    store { i64 } %var_44, ptr %var_42
    %var_45 = alloca {  }
    %var_46 = load {  }, ptr %var_45
    store {  } %var_46, ptr %var_45
    %var_47 = alloca { void (ptr, {  }, i64)*, {  } }
    %var_48 = load { void (ptr, {  }, i64)*, {  } }, ptr %var_47
    %var_49 = insertvalue { void (ptr, {  }, i64)*, {  } } %var_48, void (ptr, {  }, i64)* @malloc_wrap, 0
    %var_50 = insertvalue { void (ptr, {  }, i64)*, {  } } %var_49, {  } %var_46, 1
    store { void (ptr, {  }, i64)*, {  } } %var_50, ptr %var_47
    %var_51 = load i64, ptr @const_5
    %var_52 = extractvalue { void (ptr, {  }, i64)*, {  } } %var_50, 0
    %var_53 = extractvalue { void (ptr, {  }, i64)*, {  } } %var_50, 1
    %var_54 = alloca ptr
    call void %var_52(ptr %var_54, {  } %var_53, i64 %var_51)
    %var_55 = load ptr, ptr %var_54
    %var_56 = load i64, ptr @const_8
    %var_57 = alloca { i64 }
    %var_58 = load { i64 }, ptr %var_57
    %var_59 = insertvalue { i64 } %var_58, i64 %var_56, 0
    store { i64 } %var_59, ptr %var_57
    %var_60 = load i64, ptr @const_6
    %var_61 = extractvalue { i64 } %var_59, 0
    %var_62 = alloca { i64, i64 }
    %var_63 = load { i64, i64 }, ptr %var_62
    %var_64 = insertvalue { i64, i64 } %var_63, i64 %var_61, 0
    %var_65 = insertvalue { i64, i64 } %var_64, i64 %var_60, 1
    store { i64, i64 } %var_65, ptr %var_62
    store { i64, i64 } %var_65, ptr %var_55
    %var_66 = alloca {  }
    %var_67 = load {  }, ptr %var_66
    store {  } %var_67, ptr %var_66
    %var_68 = alloca { void (i64*, {  }, ptr, i64)*, {  } }
    %var_69 = load { void (i64*, {  }, ptr, i64)*, {  } }, ptr %var_68
    %var_70 = insertvalue { void (i64*, {  }, ptr, i64)*, {  } } %var_69, void (i64*, {  }, ptr, i64)* @lh_yield_wrap, 0
    %var_71 = insertvalue { void (i64*, {  }, ptr, i64)*, {  } } %var_70, {  } %var_67, 1
    store { void (i64*, {  }, ptr, i64)*, {  } } %var_71, ptr %var_68
    %var_72 = load i64, ptr @const_7
    %var_73 = extractvalue { void (i64*, {  }, ptr, i64)*, {  } } %var_71, 0
    %var_74 = extractvalue { void (i64*, {  }, ptr, i64)*, {  } } %var_71, 1
    %var_75 = alloca i64
    call void %var_73(i64* %var_75, {  } %var_74, ptr %var_55, i64 %var_72)
    %var_76 = load i64, ptr %var_75
    %var_77 = extractvalue { i64 } %var_44, 0
    %var_78 = alloca { i64, i64 }
    %var_79 = load { i64, i64 }, ptr %var_78
    %var_80 = insertvalue { i64, i64 } %var_79, i64 %var_77, 0
    %var_81 = insertvalue { i64, i64 } %var_80, i64 %var_76, 1
    store { i64, i64 } %var_81, ptr %var_78
    store { i64, i64 } %var_81, ptr %arg_0
    ret void
}
declare ptr @malloc(i64)
define void @malloc_wrap(ptr sret(ptr) %arg_0, {  } %arg_1, i64 %arg_2) {
  entry_0: 
    %var_0 = call ptr @malloc(i64 %arg_2)
    store ptr %var_0, ptr %arg_0
    ret void
}
declare i64 @lh_yield(ptr, i64)
define void @lh_yield_wrap(ptr sret(i64) %arg_0, {  } %arg_1, ptr %arg_2, i64 %arg_3) {
  entry_0: 
    %var_0 = call i64 @lh_yield(ptr %arg_2, i64 %arg_3)
    store i64 %var_0, ptr %arg_0
    ret void
}
declare i8 @free(ptr)
define void @free_wrap(ptr sret(i8) %arg_0, {  } %arg_1, ptr %arg_2) {
  entry_0: 
    %var_0 = call i8 @free(ptr %arg_2)
    store i8 %var_0, ptr %arg_0
    ret void
}
define i64 @identity_ret_handler(i64 %arg_0, i64 %arg_1) {
  entry_0: 
    ret i64 %arg_1
}
define i64 @handler_a(ptr %arg_0, i64 %arg_1, i64 %arg_2) {
  entry_0: 
    %var_0 = alloca {  }
    %var_1 = load {  }, ptr %var_0
    store {  } %var_1, ptr %var_0
    %var_2 = alloca { void (i64*, {  }, ptr, i64, i64)*, {  } }
    %var_3 = load { void (i64*, {  }, ptr, i64, i64)*, {  } }, ptr %var_2
    %var_4 = insertvalue { void (i64*, {  }, ptr, i64, i64)*, {  } } %var_3, void (i64*, {  }, ptr, i64, i64)* @lh_release_resume_wrap, 0
    %var_5 = insertvalue { void (i64*, {  }, ptr, i64, i64)*, {  } } %var_4, {  } %var_1, 1
    store { void (i64*, {  }, ptr, i64, i64)*, {  } } %var_5, ptr %var_2
    %var_6 = alloca { { void (i64*, {  }, ptr, i64, i64)*, {  } } }
    %var_7 = load { { void (i64*, {  }, ptr, i64, i64)*, {  } } }, ptr %var_6
    %var_8 = insertvalue { { void (i64*, {  }, ptr, i64, i64)*, {  } } } %var_7, { void (i64*, {  }, ptr, i64, i64)*, {  } } %var_5, 0
    store { { void (i64*, {  }, ptr, i64, i64)*, {  } } } %var_8, ptr %var_6
    %var_9 = alloca { void (i64*, { { void (i64*, {  }, ptr, i64, i64)*, {  } } }, ptr, i64, i64)*, { { void (i64*, {  }, ptr, i64, i64)*, {  } } } }
    %var_10 = load { void (i64*, { { void (i64*, {  }, ptr, i64, i64)*, {  } } }, ptr, i64, i64)*, { { void (i64*, {  }, ptr, i64, i64)*, {  } } } }, ptr %var_9
    %var_11 = insertvalue { void (i64*, { { void (i64*, {  }, ptr, i64, i64)*, {  } } }, ptr, i64, i64)*, { { void (i64*, {  }, ptr, i64, i64)*, {  } } } } %var_10, void (i64*, { { void (i64*, {  }, ptr, i64, i64)*, {  } } }, ptr, i64, i64)* @fn_76, 0
    %var_12 = insertvalue { void (i64*, { { void (i64*, {  }, ptr, i64, i64)*, {  } } }, ptr, i64, i64)*, { { void (i64*, {  }, ptr, i64, i64)*, {  } } } } %var_11, { { void (i64*, {  }, ptr, i64, i64)*, {  } } } %var_8, 1
    store { void (i64*, { { void (i64*, {  }, ptr, i64, i64)*, {  } } }, ptr, i64, i64)*, { { void (i64*, {  }, ptr, i64, i64)*, {  } } } } %var_12, ptr %var_9
    %var_13 = extractvalue { void (i64*, { { void (i64*, {  }, ptr, i64, i64)*, {  } } }, ptr, i64, i64)*, { { void (i64*, {  }, ptr, i64, i64)*, {  } } } } %var_12, 0
    %var_14 = extractvalue { void (i64*, { { void (i64*, {  }, ptr, i64, i64)*, {  } } }, ptr, i64, i64)*, { { void (i64*, {  }, ptr, i64, i64)*, {  } } } } %var_12, 1
    %var_15 = alloca i64
    call void %var_13(i64* %var_15, { { void (i64*, {  }, ptr, i64, i64)*, {  } } } %var_14, ptr %arg_0, i64 %arg_1, i64 %arg_2)
    %var_16 = load i64, ptr %var_15
    ret i64 %var_16
}
declare i64 @lh_release_resume(ptr, i64, i64)
define void @lh_release_resume_wrap(ptr sret(i64) %arg_0, {  } %arg_1, ptr %arg_2, i64 %arg_3, i64 %arg_4) {
  entry_0: 
    %var_0 = call i64 @lh_release_resume(ptr %arg_2, i64 %arg_3, i64 %arg_4)
    store i64 %var_0, ptr %arg_0
    ret void
}
define void @fn_76(ptr sret(i64) %arg_0, { { void (i64*, {  }, ptr, i64, i64)*, {  } } } %arg_1, ptr %arg_2, i64 %arg_3, i64 %arg_4) {
  entry_0: 
    %var_0 = extractvalue { { void (i64*, {  }, ptr, i64, i64)*, {  } } } %arg_1, 0
    %var_1 = load i64, ptr @const_7
    %var_2 = extractvalue { void (i64*, {  }, ptr, i64, i64)*, {  } } %var_0, 0
    %var_3 = extractvalue { void (i64*, {  }, ptr, i64, i64)*, {  } } %var_0, 1
    %var_4 = alloca i64
    call void %var_2(i64* %var_4, {  } %var_3, ptr %arg_2, i64 %arg_3, i64 %var_1)
    %var_5 = load i64, ptr %var_4
    store i64 %var_5, ptr %arg_0
    ret void
}
declare i64 @lh_handle(ptr, i64, ptr, i64)
define i64 @handler_b(ptr %arg_0, i64 %arg_1, i64 %arg_2) {
  entry_0: 
    %var_0 = alloca {  }
    %var_1 = load {  }, ptr %var_0
    store {  } %var_1, ptr %var_0
    %var_2 = alloca { void (i64*, {  }, ptr, i64, i64)*, {  } }
    %var_3 = load { void (i64*, {  }, ptr, i64, i64)*, {  } }, ptr %var_2
    %var_4 = insertvalue { void (i64*, {  }, ptr, i64, i64)*, {  } } %var_3, void (i64*, {  }, ptr, i64, i64)* @lh_release_resume_wrap, 0
    %var_5 = insertvalue { void (i64*, {  }, ptr, i64, i64)*, {  } } %var_4, {  } %var_1, 1
    store { void (i64*, {  }, ptr, i64, i64)*, {  } } %var_5, ptr %var_2
    %var_6 = alloca { { void (i64*, {  }, ptr, i64, i64)*, {  } } }
    %var_7 = load { { void (i64*, {  }, ptr, i64, i64)*, {  } } }, ptr %var_6
    %var_8 = insertvalue { { void (i64*, {  }, ptr, i64, i64)*, {  } } } %var_7, { void (i64*, {  }, ptr, i64, i64)*, {  } } %var_5, 0
    store { { void (i64*, {  }, ptr, i64, i64)*, {  } } } %var_8, ptr %var_6
    %var_9 = alloca { void (i64*, { { void (i64*, {  }, ptr, i64, i64)*, {  } } }, ptr, i64, i64)*, { { void (i64*, {  }, ptr, i64, i64)*, {  } } } }
    %var_10 = load { void (i64*, { { void (i64*, {  }, ptr, i64, i64)*, {  } } }, ptr, i64, i64)*, { { void (i64*, {  }, ptr, i64, i64)*, {  } } } }, ptr %var_9
    %var_11 = insertvalue { void (i64*, { { void (i64*, {  }, ptr, i64, i64)*, {  } } }, ptr, i64, i64)*, { { void (i64*, {  }, ptr, i64, i64)*, {  } } } } %var_10, void (i64*, { { void (i64*, {  }, ptr, i64, i64)*, {  } } }, ptr, i64, i64)* @fn_77, 0
    %var_12 = insertvalue { void (i64*, { { void (i64*, {  }, ptr, i64, i64)*, {  } } }, ptr, i64, i64)*, { { void (i64*, {  }, ptr, i64, i64)*, {  } } } } %var_11, { { void (i64*, {  }, ptr, i64, i64)*, {  } } } %var_8, 1
    store { void (i64*, { { void (i64*, {  }, ptr, i64, i64)*, {  } } }, ptr, i64, i64)*, { { void (i64*, {  }, ptr, i64, i64)*, {  } } } } %var_12, ptr %var_9
    %var_13 = extractvalue { void (i64*, { { void (i64*, {  }, ptr, i64, i64)*, {  } } }, ptr, i64, i64)*, { { void (i64*, {  }, ptr, i64, i64)*, {  } } } } %var_12, 0
    %var_14 = extractvalue { void (i64*, { { void (i64*, {  }, ptr, i64, i64)*, {  } } }, ptr, i64, i64)*, { { void (i64*, {  }, ptr, i64, i64)*, {  } } } } %var_12, 1
    %var_15 = alloca i64
    call void %var_13(i64* %var_15, { { void (i64*, {  }, ptr, i64, i64)*, {  } } } %var_14, ptr %arg_0, i64 %arg_1, i64 %arg_2)
    %var_16 = load i64, ptr %var_15
    ret i64 %var_16
}
define void @fn_77(ptr sret(i64) %arg_0, { { void (i64*, {  }, ptr, i64, i64)*, {  } } } %arg_1, ptr %arg_2, i64 %arg_3, i64 %arg_4) {
  entry_0: 
    %var_0 = extractvalue { { void (i64*, {  }, ptr, i64, i64)*, {  } } } %arg_1, 0
    %var_1 = load i64, ptr @const_8
    %var_2 = extractvalue { void (i64*, {  }, ptr, i64, i64)*, {  } } %var_0, 0
    %var_3 = extractvalue { void (i64*, {  }, ptr, i64, i64)*, {  } } %var_0, 1
    %var_4 = alloca i64
    call void %var_2(i64* %var_4, {  } %var_3, ptr %arg_2, i64 %arg_3, i64 %var_1)
    %var_5 = load i64, ptr %var_4
    store i64 %var_5, ptr %arg_0
    ret void
}
"
`;

exports[`effect handlers compilation > inject > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [7 x i8] c"tuple(\\00"
@const_1 = constant [3 x i8] c"%s\\00"
@const_2 = constant [3 x i8] c"%i\\00"
@const_3 = constant [3 x i8] c", \\00"
@const_4 = constant [2 x i8] c")\\00"
@const_5 = local_unnamed_addr constant i64 16
@const_6 = local_unnamed_addr constant i64 0
@const_7 = local_unnamed_addr constant i64 1
@const_8 = local_unnamed_addr constant i64 2
@const_9 = constant { i64, i64 } zeroinitializer
@const_10 = constant [2 x { i32, ptr, ptr }] [{ i32, ptr, ptr } { i32 7, ptr @const_9, ptr @handler_a }, { i32, ptr, ptr } zeroinitializer]
@const_11 = local_unnamed_addr constant i64 40
@const_12 = local_unnamed_addr constant i64 128
@const_13 = constant { i64, i64 } { i64 2, i64 0 }
@const_14 = constant [2 x { i32, ptr, ptr }] [{ i32, ptr, ptr } { i32 7, ptr @const_13, ptr @handler_b }, { i32, ptr, ptr } zeroinitializer]
@const_15 = constant [10 x i8] c"handler_a\\00"
@const_16 = constant [5 x i8] c"unit\\00"
@const_17 = constant [10 x i8] c"handler_b\\00"
@symbols_metadata_array = constant [3 x { ptr }] [{ ptr } { ptr @const_15 }, { ptr } { ptr @const_16 }, { ptr } { ptr @const_17 }]
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  %var_14 = tail call dereferenceable_or_null(40) ptr @malloc(i64 40)
  store i64 2, ptr %var_14, align 8
  %var_14.repack1 = getelementptr inbounds { i64, ptr, ptr, ptr, ptr }, ptr %var_14, i64 0, i32 1
  %var_14.repack3 = getelementptr inbounds { i64, ptr, ptr, ptr, ptr }, ptr %var_14, i64 0, i32 3
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %var_14.repack1, i8 0, i64 16, i1 false)
  store ptr @identity_ret_handler, ptr %var_14.repack3, align 8
  %var_14.repack4 = getelementptr inbounds { i64, ptr, ptr, ptr, ptr }, ptr %var_14, i64 0, i32 4
  store ptr @const_14, ptr %var_14.repack4, align 8
  %var_16 = tail call dereferenceable_or_null(128) ptr @malloc(i64 128)
  %var_17 = ptrtoint ptr %var_16 to i64
  tail call void @lh_handle(ptr nonnull %var_14, i64 0, ptr nonnull @handleable_72, i64 %var_17)
  %var_18.unpack = load i64, ptr %var_16, align 4
  %var_18.elt5 = getelementptr inbounds { i64, i64 }, ptr %var_16, i64 0, i32 1
  %var_18.unpack6 = load i64, ptr %var_18.elt5, align 4
  tail call void @free(ptr nonnull %var_16)
  tail call void @free(ptr nonnull %var_14)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_0)
  tail call void @printf(ptr nonnull @const_2, i64 %var_18.unpack)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_3)
  tail call void @printf(ptr nonnull @const_2, i64 %var_18.unpack6)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_4)
  ret i32 0
}

define void @"generated_print_(i64, i64)"(ptr nocapture writeonly sret({ i64, i64 }) %arg_0, {} %arg_1, { i64, i64 } %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_0)
  %var_0 = extractvalue { i64, i64 } %arg_2, 0
  tail call void @printf(ptr nonnull @const_2, i64 %var_0)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_3)
  %var_11 = extractvalue { i64, i64 } %arg_2, 1
  tail call void @printf(ptr nonnull @const_2, i64 %var_11)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_4)
  store i64 %var_0, ptr %arg_0, align 8
  %arg_0.repack1 = getelementptr inbounds { i64, i64 }, ptr %arg_0, i64 0, i32 1
  store i64 %var_11, ptr %arg_0.repack1, align 8
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

define void @generated_print_i64(ptr nocapture writeonly sret(i64) %arg_0, {} %arg_1, i64 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_2, i64 %arg_2)
  store i64 %arg_2, ptr %arg_0, align 8
  ret void
}

define void @handleable_72(ptr nocapture writeonly sret({ i64, i64 }) %arg_0) {
entry_0:
  %var_8 = tail call dereferenceable_or_null(40) ptr @malloc(i64 40)
  %var_8.repack3 = getelementptr inbounds { i64, ptr, ptr, ptr, ptr }, ptr %var_8, i64 0, i32 3
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %var_8, i8 0, i64 24, i1 false)
  store ptr @identity_ret_handler, ptr %var_8.repack3, align 8
  %var_8.repack4 = getelementptr inbounds { i64, ptr, ptr, ptr, ptr }, ptr %var_8, i64 0, i32 4
  store ptr @const_10, ptr %var_8.repack4, align 8
  %var_10 = tail call dereferenceable_or_null(128) ptr @malloc(i64 128)
  %var_11 = ptrtoint ptr %var_10 to i64
  tail call void @lh_handle(ptr nonnull %var_8, i64 0, ptr nonnull @handleable_63, i64 %var_11)
  %0 = load <2 x i64>, ptr %var_10, align 4
  tail call void @free(ptr nonnull %var_10)
  tail call void @free(ptr nonnull %var_8)
  store <2 x i64> %0, ptr %arg_0, align 8
  ret void
}

define void @handleable_63(ptr nocapture writeonly sret({ i64, i64 }) %arg_0) {
entry_0:
  %calloc = tail call dereferenceable_or_null(16) ptr @calloc(i64 1, i64 16)
  %var_0.i5 = tail call i64 @lh_yield(ptr nonnull %calloc, i64 1)
  %var_0.i6 = tail call i8 @free(ptr nonnull %calloc)
  %var_0.i7 = tail call dereferenceable_or_null(16) ptr @malloc(i64 16)
  store i64 2, ptr %var_0.i7, align 4
  %var_55.repack2 = getelementptr inbounds { i64, i64 }, ptr %var_0.i7, i64 0, i32 1
  store i64 0, ptr %var_55.repack2, align 4
  %var_0.i8 = tail call i64 @lh_yield(ptr nonnull %var_0.i7, i64 1)
  store i64 %var_0.i5, ptr %arg_0, align 8
  %arg_0.repack3 = getelementptr inbounds { i64, i64 }, ptr %arg_0, i64 0, i32 1
  store i64 %var_0.i8, ptr %arg_0.repack3, align 8
  ret void
}

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite)
declare noalias noundef ptr @malloc(i64 noundef) local_unnamed_addr #1

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: write, inaccessiblemem: readwrite)
define void @malloc_wrap(ptr nocapture writeonly sret(ptr) %arg_0, {} %arg_1, i64 %arg_2) local_unnamed_addr #2 {
entry_0:
  %var_0 = tail call ptr @malloc(i64 %arg_2)
  store ptr %var_0, ptr %arg_0, align 8
  ret void
}

declare i64 @lh_yield(ptr, i64) local_unnamed_addr

define void @lh_yield_wrap(ptr nocapture writeonly sret(i64) %arg_0, {} %arg_1, ptr %arg_2, i64 %arg_3) local_unnamed_addr {
entry_0:
  %var_0 = tail call i64 @lh_yield(ptr %arg_2, i64 %arg_3)
  store i64 %var_0, ptr %arg_0, align 8
  ret void
}

declare i8 @free(ptr) local_unnamed_addr

define void @free_wrap(ptr nocapture writeonly sret(i8) %arg_0, {} %arg_1, ptr %arg_2) local_unnamed_addr {
entry_0:
  %var_0 = tail call i8 @free(ptr %arg_2)
  store i8 %var_0, ptr %arg_0, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define i64 @identity_ret_handler(i64 %arg_0, i64 returned %arg_1) #3 {
entry_0:
  ret i64 %arg_1
}

define i64 @handler_a(ptr %arg_0, i64 %arg_1, i64 %arg_2) {
entry_0:
  %var_0.i = tail call i64 @lh_release_resume(ptr %arg_0, i64 %arg_1, i64 1)
  ret i64 %var_0.i
}

declare i64 @lh_release_resume(ptr, i64, i64) local_unnamed_addr

define void @lh_release_resume_wrap(ptr nocapture writeonly sret(i64) %arg_0, {} %arg_1, ptr %arg_2, i64 %arg_3, i64 %arg_4) local_unnamed_addr {
entry_0:
  %var_0 = tail call i64 @lh_release_resume(ptr %arg_2, i64 %arg_3, i64 %arg_4)
  store i64 %var_0, ptr %arg_0, align 8
  ret void
}

define void @fn_76(ptr nocapture writeonly sret(i64) %arg_0, { { ptr, {} } } %arg_1, ptr %arg_2, i64 %arg_3, i64 %arg_4) local_unnamed_addr {
entry_0:
  %var_0 = extractvalue { { ptr, {} } } %arg_1, 0
  %var_2 = extractvalue { ptr, {} } %var_0, 0
  %var_4 = alloca i64, align 8
  call void %var_2(ptr nonnull %var_4, {} zeroinitializer, ptr %arg_2, i64 %arg_3, i64 1)
  %var_5 = load i64, ptr %var_4, align 8
  store i64 %var_5, ptr %arg_0, align 8
  ret void
}

declare i64 @lh_handle(ptr, i64, ptr, i64) local_unnamed_addr

define i64 @handler_b(ptr %arg_0, i64 %arg_1, i64 %arg_2) {
entry_0:
  %var_0.i = tail call i64 @lh_release_resume(ptr %arg_0, i64 %arg_1, i64 2)
  ret i64 %var_0.i
}

define void @fn_77(ptr nocapture writeonly sret(i64) %arg_0, { { ptr, {} } } %arg_1, ptr %arg_2, i64 %arg_3, i64 %arg_4) local_unnamed_addr {
entry_0:
  %var_0 = extractvalue { { ptr, {} } } %arg_1, 0
  %var_2 = extractvalue { ptr, {} } %var_0, 0
  %var_4 = alloca i64, align 8
  call void %var_2(ptr nonnull %var_4, {} zeroinitializer, ptr %arg_2, i64 %arg_3, i64 2)
  %var_5 = load i64, ptr %var_4, align 8
  store i64 %var_5, ptr %arg_0, align 8
  ret void
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #4

; Function Attrs: nofree nounwind willreturn allockind("alloc,zeroed") allocsize(0,1) memory(inaccessiblemem: readwrite)
declare noalias noundef ptr @calloc(i64 noundef, i64 noundef) local_unnamed_addr #5

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #2 = { mustprogress nofree nounwind willreturn memory(argmem: write, inaccessiblemem: readwrite) }
attributes #3 = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) }
attributes #4 = { nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #5 = { nofree nounwind willreturn allockind("alloc,zeroed") allocsize(0,1) memory(inaccessiblemem: readwrite) "alloc-family"="malloc" }
"
`;

exports[`effect handlers compilation > inject > stderr 1`] = `[]`;

exports[`effect handlers compilation > inject > stdout 1`] = `
[
  "tuple(1, 2)",
]
`;

exports[`generic print > compiled 1`] = `
"@const_0 = constant [4 x i8] c"fn[\\00"
@const_1 = constant [3 x i8] c"%s\\00"
@const_2 = constant [2 x i8] c"]\\00"
@const_3 = constant [2 x i8] c"
\\00"
@const_4 = constant [3 x i8] c"%i\\00"
@const_5 = constant i32 1
@const_6 = constant [7 x i8] c"tuple(\\00"
@const_7 = constant [3 x i8] c", \\00"
@const_8 = constant [2 x i8] c")\\00"
@const_9 = constant [3 x i8] c"ab\\00"
@const_10 = constant [3 x i8] c"%f\\00"
@const_11 = constant float 1.25
@const_12 = constant [5 x i8] c"true\\00"
@const_13 = constant [6 x i8] c"false\\00"
@const_14 = constant i1 1
@const_15 = constant i1 0
@const_16 = constant i64 0
@const_17 = constant i64 1
@const_18 = constant i64 2
@const_19 = constant [5 x i8] c"unit\\00"
@const_20 = constant [12 x i8] c"atom_atom_a\\00"
@const_21 = constant [16 x i8] c"symbol_symbol_a\\00"
@symbols_metadata_array = constant [3 x { i8* }] [{ i8* } { i8* @const_19 }, { i8* } { i8* @const_20 }, { i8* } { i8* @const_21 }]
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_0 = alloca {  }
    %var_1 = load {  }, ptr %var_0
    store {  } %var_1, ptr %var_0
    %var_2 = alloca { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } }
    %var_3 = load { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } }, ptr %var_2
    %var_4 = insertvalue { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_3, void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })* @"generated_print_i32[](i32)", 0
    %var_5 = insertvalue { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_4, {  } %var_1, 1
    store { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_5, ptr %var_2
    %var_6 = alloca {  }
    %var_7 = load {  }, ptr %var_6
    store {  } %var_7, ptr %var_6
    %var_8 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_9 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_8
    %var_10 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_9, void (i32*, {  }, i32)* @fn_93, 0
    %var_11 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_10, {  } %var_7, 1
    store { void (i32*, {  }, i32)*, {  } } %var_11, ptr %var_8
    %var_12 = extractvalue { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_5, 0
    %var_13 = extractvalue { void ({ void (i32*, {  }, i32)*, {  } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_5, 1
    %var_14 = alloca { void (i32*, {  }, i32)*, {  } }
    call void %var_12({ void (i32*, {  }, i32)*, {  } }* %var_14, {  } %var_13, { void (i32*, {  }, i32)*, {  } } %var_11)
    %var_15 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_14
    %var_16 = alloca {  }
    %var_17 = load {  }, ptr %var_16
    store {  } %var_17, ptr %var_16
    %var_18 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_19 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_18
    %var_20 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_19, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_21 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_20, {  } %var_17, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_21, ptr %var_18
    %var_22 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_21, 0
    %var_23 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_21, 1
    %var_24 = alloca i8*
    call void %var_22(i8** %var_24, {  } %var_23, i8* @const_3)
    %var_25 = load i8*, ptr %var_24
    %var_26 = alloca {  }
    %var_27 = load {  }, ptr %var_26
    store {  } %var_27, ptr %var_26
    %var_28 = alloca { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } }
    %var_29 = load { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } }, ptr %var_28
    %var_30 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } } %var_29, void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })* @"generated_print_i32[i32](i32)", 0
    %var_31 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } } %var_30, {  } %var_27, 1
    store { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } } %var_31, ptr %var_28
    %var_32 = alloca {  }
    %var_33 = load {  }, ptr %var_32
    store {  } %var_33, ptr %var_32
    %var_34 = alloca { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }
    %var_35 = load { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_34
    %var_36 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_35, void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)* @fn_94, 0
    %var_37 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_36, {  } %var_33, 1
    store { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_37, ptr %var_34
    %var_38 = load i32, ptr @const_5
    %var_39 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_37, 0
    %var_40 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_37, 1
    %var_41 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    call void %var_39({ void (i32*, { i32 }, i32)*, { i32 } }* %var_41, {  } %var_40, i32 %var_38)
    %var_42 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_41
    %var_43 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } } %var_31, 0
    %var_44 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, { void (i32*, { i32 }, i32)*, { i32 } })*, {  } } %var_31, 1
    %var_45 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    call void %var_43({ void (i32*, { i32 }, i32)*, { i32 } }* %var_45, {  } %var_44, { void (i32*, { i32 }, i32)*, { i32 } } %var_42)
    %var_46 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_45
    %var_47 = alloca {  }
    %var_48 = load {  }, ptr %var_47
    store {  } %var_48, ptr %var_47
    %var_49 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_50 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_49
    %var_51 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_50, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_52 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_51, {  } %var_48, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_52, ptr %var_49
    %var_53 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_52, 0
    %var_54 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_52, 1
    %var_55 = alloca i8*
    call void %var_53(i8** %var_55, {  } %var_54, i8* @const_3)
    %var_56 = load i8*, ptr %var_55
    %var_57 = alloca {  }
    %var_58 = load {  }, ptr %var_57
    store {  } %var_58, ptr %var_57
    %var_59 = alloca { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } }
    %var_60 = load { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } }, ptr %var_59
    %var_61 = insertvalue { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_60, void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })* @"generated_print_i32[](i32, i32)", 0
    %var_62 = insertvalue { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_61, {  } %var_58, 1
    store { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_62, ptr %var_59
    %var_63 = alloca {  }
    %var_64 = load {  }, ptr %var_63
    store {  } %var_64, ptr %var_63
    %var_65 = alloca { void (i32*, {  }, i32, i32)*, {  } }
    %var_66 = load { void (i32*, {  }, i32, i32)*, {  } }, ptr %var_65
    %var_67 = insertvalue { void (i32*, {  }, i32, i32)*, {  } } %var_66, void (i32*, {  }, i32, i32)* @fn_96, 0
    %var_68 = insertvalue { void (i32*, {  }, i32, i32)*, {  } } %var_67, {  } %var_64, 1
    store { void (i32*, {  }, i32, i32)*, {  } } %var_68, ptr %var_65
    %var_69 = extractvalue { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_62, 0
    %var_70 = extractvalue { void ({ void (i32*, {  }, i32, i32)*, {  } }*, {  }, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_62, 1
    %var_71 = alloca { void (i32*, {  }, i32, i32)*, {  } }
    call void %var_69({ void (i32*, {  }, i32, i32)*, {  } }* %var_71, {  } %var_70, { void (i32*, {  }, i32, i32)*, {  } } %var_68)
    %var_72 = load { void (i32*, {  }, i32, i32)*, {  } }, ptr %var_71
    %var_73 = alloca {  }
    %var_74 = load {  }, ptr %var_73
    store {  } %var_74, ptr %var_73
    %var_75 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_76 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_75
    %var_77 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_76, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_78 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_77, {  } %var_74, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_78, ptr %var_75
    %var_79 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_78, 0
    %var_80 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_78, 1
    %var_81 = alloca i8*
    call void %var_79(i8** %var_81, {  } %var_80, i8* @const_3)
    %var_82 = load i8*, ptr %var_81
    %var_83 = alloca {  }
    %var_84 = load {  }, ptr %var_83
    store {  } %var_84, ptr %var_83
    %var_85 = alloca { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } }
    %var_86 = load { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } }, ptr %var_85
    %var_87 = insertvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_86, void ({ i32, i8* }*, {  }, { i32, i8* })* @"generated_print_(i32, i8*)", 0
    %var_88 = insertvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_87, {  } %var_84, 1
    store { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_88, ptr %var_85
    %var_89 = load i32, ptr @const_5
    %var_90 = alloca { i32 }
    %var_91 = load { i32 }, ptr %var_90
    %var_92 = insertvalue { i32 } %var_91, i32 %var_89, 0
    store { i32 } %var_92, ptr %var_90
    %var_93 = extractvalue { i32 } %var_92, 0
    %var_94 = alloca { i32, [3 x i8]* }
    %var_95 = load { i32, [3 x i8]* }, ptr %var_94
    %var_96 = insertvalue { i32, [3 x i8]* } %var_95, i32 %var_93, 0
    %var_97 = insertvalue { i32, [3 x i8]* } %var_96, [3 x i8]* @const_9, 1
    store { i32, [3 x i8]* } %var_97, ptr %var_94
    %var_98 = extractvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_88, 0
    %var_99 = extractvalue { void ({ i32, i8* }*, {  }, { i32, i8* })*, {  } } %var_88, 1
    %var_100 = alloca { i32, i8* }
    call void %var_98({ i32, i8* }* %var_100, {  } %var_99, { i32, i8* } %var_97)
    %var_101 = load { i32, i8* }, ptr %var_100
    %var_102 = alloca {  }
    %var_103 = load {  }, ptr %var_102
    store {  } %var_103, ptr %var_102
    %var_104 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_105 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_104
    %var_106 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_105, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_107 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_106, {  } %var_103, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_107, ptr %var_104
    %var_108 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_107, 0
    %var_109 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_107, 1
    %var_110 = alloca i8*
    call void %var_108(i8** %var_110, {  } %var_109, i8* @const_3)
    %var_111 = load i8*, ptr %var_110
    %var_112 = alloca {  }
    %var_113 = load {  }, ptr %var_112
    store {  } %var_113, ptr %var_112
    %var_114 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_115 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_114
    %var_116 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_115, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_117 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_116, {  } %var_113, 1
    store { void (i32*, {  }, i32)*, {  } } %var_117, ptr %var_114
    %var_118 = load i32, ptr @const_5
    %var_119 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_117, 0
    %var_120 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_117, 1
    %var_121 = alloca i32
    call void %var_119(i32* %var_121, {  } %var_120, i32 %var_118)
    %var_122 = load i32, ptr %var_121
    %var_123 = alloca {  }
    %var_124 = load {  }, ptr %var_123
    store {  } %var_124, ptr %var_123
    %var_125 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_126 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_125
    %var_127 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_126, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_128 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_127, {  } %var_124, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_128, ptr %var_125
    %var_129 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_128, 0
    %var_130 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_128, 1
    %var_131 = alloca i8*
    call void %var_129(i8** %var_131, {  } %var_130, i8* @const_3)
    %var_132 = load i8*, ptr %var_131
    %var_133 = alloca {  }
    %var_134 = load {  }, ptr %var_133
    store {  } %var_134, ptr %var_133
    %var_135 = alloca { void (float*, {  }, float)*, {  } }
    %var_136 = load { void (float*, {  }, float)*, {  } }, ptr %var_135
    %var_137 = insertvalue { void (float*, {  }, float)*, {  } } %var_136, void (float*, {  }, float)* @"generated_print_f32", 0
    %var_138 = insertvalue { void (float*, {  }, float)*, {  } } %var_137, {  } %var_134, 1
    store { void (float*, {  }, float)*, {  } } %var_138, ptr %var_135
    %var_139 = load float, ptr @const_11
    %var_140 = extractvalue { void (float*, {  }, float)*, {  } } %var_138, 0
    %var_141 = extractvalue { void (float*, {  }, float)*, {  } } %var_138, 1
    %var_142 = alloca float
    call void %var_140(float* %var_142, {  } %var_141, float %var_139)
    %var_143 = load float, ptr %var_142
    %var_144 = alloca {  }
    %var_145 = load {  }, ptr %var_144
    store {  } %var_145, ptr %var_144
    %var_146 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_147 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_146
    %var_148 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_147, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_149 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_148, {  } %var_145, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_149, ptr %var_146
    %var_150 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_149, 0
    %var_151 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_149, 1
    %var_152 = alloca i8*
    call void %var_150(i8** %var_152, {  } %var_151, i8* @const_3)
    %var_153 = load i8*, ptr %var_152
    %var_154 = alloca {  }
    %var_155 = load {  }, ptr %var_154
    store {  } %var_155, ptr %var_154
    %var_156 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_157 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_156
    %var_158 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_157, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_159 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_158, {  } %var_155, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_159, ptr %var_156
    %var_160 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_159, 0
    %var_161 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_159, 1
    %var_162 = alloca i8*
    call void %var_160(i8** %var_162, {  } %var_161, i8* @const_9)
    %var_163 = load i8*, ptr %var_162
    %var_164 = alloca {  }
    %var_165 = load {  }, ptr %var_164
    store {  } %var_165, ptr %var_164
    %var_166 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_167 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_166
    %var_168 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_167, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_169 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_168, {  } %var_165, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_169, ptr %var_166
    %var_170 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_169, 0
    %var_171 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_169, 1
    %var_172 = alloca i8*
    call void %var_170(i8** %var_172, {  } %var_171, i8* @const_3)
    %var_173 = load i8*, ptr %var_172
    %var_174 = alloca {  }
    %var_175 = load {  }, ptr %var_174
    store {  } %var_175, ptr %var_174
    %var_176 = alloca { void (i1*, {  }, i1)*, {  } }
    %var_177 = load { void (i1*, {  }, i1)*, {  } }, ptr %var_176
    %var_178 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_177, void (i1*, {  }, i1)* @"generated_print_i1", 0
    %var_179 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_178, {  } %var_175, 1
    store { void (i1*, {  }, i1)*, {  } } %var_179, ptr %var_176
    %var_180 = load i1, ptr @const_14
    %var_181 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_179, 0
    %var_182 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_179, 1
    %var_183 = alloca i1
    call void %var_181(i1* %var_183, {  } %var_182, i1 %var_180)
    %var_184 = load i1, ptr %var_183
    %var_185 = alloca {  }
    %var_186 = load {  }, ptr %var_185
    store {  } %var_186, ptr %var_185
    %var_187 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_188 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_187
    %var_189 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_188, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_190 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_189, {  } %var_186, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_190, ptr %var_187
    %var_191 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_190, 0
    %var_192 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_190, 1
    %var_193 = alloca i8*
    call void %var_191(i8** %var_193, {  } %var_192, i8* @const_3)
    %var_194 = load i8*, ptr %var_193
    %var_195 = alloca {  }
    %var_196 = load {  }, ptr %var_195
    store {  } %var_196, ptr %var_195
    %var_197 = alloca { void (i1*, {  }, i1)*, {  } }
    %var_198 = load { void (i1*, {  }, i1)*, {  } }, ptr %var_197
    %var_199 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_198, void (i1*, {  }, i1)* @"generated_print_i1", 0
    %var_200 = insertvalue { void (i1*, {  }, i1)*, {  } } %var_199, {  } %var_196, 1
    store { void (i1*, {  }, i1)*, {  } } %var_200, ptr %var_197
    %var_201 = load i1, ptr @const_15
    %var_202 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_200, 0
    %var_203 = extractvalue { void (i1*, {  }, i1)*, {  } } %var_200, 1
    %var_204 = alloca i1
    call void %var_202(i1* %var_204, {  } %var_203, i1 %var_201)
    %var_205 = load i1, ptr %var_204
    %var_206 = alloca {  }
    %var_207 = load {  }, ptr %var_206
    store {  } %var_207, ptr %var_206
    %var_208 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_209 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_208
    %var_210 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_209, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_211 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_210, {  } %var_207, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_211, ptr %var_208
    %var_212 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_211, 0
    %var_213 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_211, 1
    %var_214 = alloca i8*
    call void %var_212(i8** %var_214, {  } %var_213, i8* @const_3)
    %var_215 = load i8*, ptr %var_214
    %var_216 = alloca {  }
    %var_217 = load {  }, ptr %var_216
    store {  } %var_217, ptr %var_216
    %var_218 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_219 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_218
    %var_220 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_219, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_221 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_220, {  } %var_217, 1
    store { void (i64*, {  }, i64)*, {  } } %var_221, ptr %var_218
    %var_222 = load i64, ptr @const_16
    %var_223 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_221, 0
    %var_224 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_221, 1
    %var_225 = alloca i64
    call void %var_223(i64* %var_225, {  } %var_224, i64 %var_222)
    %var_226 = load i64, ptr %var_225
    %var_227 = alloca {  }
    %var_228 = load {  }, ptr %var_227
    store {  } %var_228, ptr %var_227
    %var_229 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_230 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_229
    %var_231 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_230, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_232 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_231, {  } %var_228, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_232, ptr %var_229
    %var_233 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_232, 0
    %var_234 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_232, 1
    %var_235 = alloca i8*
    call void %var_233(i8** %var_235, {  } %var_234, i8* @const_3)
    %var_236 = load i8*, ptr %var_235
    %var_237 = alloca {  }
    %var_238 = load {  }, ptr %var_237
    store {  } %var_238, ptr %var_237
    %var_239 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_240 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_239
    %var_241 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_240, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_242 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_241, {  } %var_238, 1
    store { void (i64*, {  }, i64)*, {  } } %var_242, ptr %var_239
    %var_243 = load i64, ptr @const_17
    %var_244 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_242, 0
    %var_245 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_242, 1
    %var_246 = alloca i64
    call void %var_244(i64* %var_246, {  } %var_245, i64 %var_243)
    %var_247 = load i64, ptr %var_246
    %var_248 = alloca {  }
    %var_249 = load {  }, ptr %var_248
    store {  } %var_249, ptr %var_248
    %var_250 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_251 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_250
    %var_252 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_251, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_253 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_252, {  } %var_249, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_253, ptr %var_250
    %var_254 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_253, 0
    %var_255 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_253, 1
    %var_256 = alloca i8*
    call void %var_254(i8** %var_256, {  } %var_255, i8* @const_3)
    %var_257 = load i8*, ptr %var_256
    %var_258 = alloca {  }
    %var_259 = load {  }, ptr %var_258
    store {  } %var_259, ptr %var_258
    %var_260 = alloca { void (i64*, {  }, i64)*, {  } }
    %var_261 = load { void (i64*, {  }, i64)*, {  } }, ptr %var_260
    %var_262 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_261, void (i64*, {  }, i64)* @"generated_print_symbol", 0
    %var_263 = insertvalue { void (i64*, {  }, i64)*, {  } } %var_262, {  } %var_259, 1
    store { void (i64*, {  }, i64)*, {  } } %var_263, ptr %var_260
    %var_264 = load i64, ptr @const_18
    %var_265 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_263, 0
    %var_266 = extractvalue { void (i64*, {  }, i64)*, {  } } %var_263, 1
    %var_267 = alloca i64
    call void %var_265(i64* %var_267, {  } %var_266, i64 %var_264)
    %var_268 = load i64, ptr %var_267
    ret i32 0
}
define void @"generated_print_i32[](i32)"(ptr sret({ void (i32*, {  }, i32)*, {  } }) %arg_0, {  } %arg_1, { void (i32*, {  }, i32)*, {  } } %arg_2) {
  entry_0: 
    %var_0 = extractvalue { void (i32*, {  }, i32)*, {  } } %arg_2, 1
    call void @printf(i8* @const_1, [4 x i8]* @const_0)
    call void @printf(i8* @const_1, [2 x i8]* @const_2)
    store { void (i32*, {  }, i32)*, {  } } %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_93(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    store i32 %arg_2, ptr %arg_0
    ret void
}
define void @"generated_print_i8*"(ptr sret(i8*) %arg_0, {  } %arg_1, i8* %arg_2) {
  entry_0: 
    call void @printf(i8* @const_1, i8* %arg_2)
    store i8* %arg_2, ptr %arg_0
    ret void
}
define void @"generated_print_i32[i32](i32)"(ptr sret({ void (i32*, { i32 }, i32)*, { i32 } }) %arg_0, {  } %arg_1, { void (i32*, { i32 }, i32)*, { i32 } } %arg_2) {
  entry_0: 
    %var_0 = extractvalue { void (i32*, { i32 }, i32)*, { i32 } } %arg_2, 1
    call void @printf(i8* @const_1, [4 x i8]* @const_0)
    %var_1 = extractvalue { i32 } %var_0, 0
    %var_2 = alloca {  }
    %var_3 = load {  }, ptr %var_2
    store {  } %var_3, ptr %var_2
    %var_4 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_5 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_4
    %var_6 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_5, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_7 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_6, {  } %var_3, 1
    store { void (i32*, {  }, i32)*, {  } } %var_7, ptr %var_4
    %var_8 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_7, 0
    %var_9 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_7, 1
    %var_10 = alloca i32
    call void %var_8(i32* %var_10, {  } %var_9, i32 %var_1)
    %var_11 = load i32, ptr %var_10
    call void @printf(i8* @const_1, [2 x i8]* @const_2)
    store { void (i32*, { i32 }, i32)*, { i32 } } %arg_2, ptr %arg_0
    ret void
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_4, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
define void @fn_94(ptr sret({ void (i32*, { i32 }, i32)*, { i32 } }) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_0 = alloca { i32 }
    %var_1 = load { i32 }, ptr %var_0
    %var_2 = insertvalue { i32 } %var_1, i32 %arg_2, 0
    store { i32 } %var_2, ptr %var_0
    %var_3 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    %var_4 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_3
    %var_5 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_4, void (i32*, { i32 }, i32)* @fn_95, 0
    %var_6 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_5, { i32 } %var_2, 1
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_6, ptr %var_3
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_6, ptr %arg_0
    ret void
}
define void @fn_95(ptr sret(i32) %arg_0, { i32 } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_0 = extractvalue { i32 } %arg_1, 0
    store i32 %var_0, ptr %arg_0
    ret void
}
define void @"generated_print_i32[](i32, i32)"(ptr sret({ void (i32*, {  }, i32, i32)*, {  } }) %arg_0, {  } %arg_1, { void (i32*, {  }, i32, i32)*, {  } } %arg_2) {
  entry_0: 
    %var_0 = extractvalue { void (i32*, {  }, i32, i32)*, {  } } %arg_2, 1
    call void @printf(i8* @const_1, [4 x i8]* @const_0)
    call void @printf(i8* @const_1, [2 x i8]* @const_2)
    store { void (i32*, {  }, i32, i32)*, {  } } %arg_2, ptr %arg_0
    ret void
}
define void @fn_96(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2, i32 %arg_3) {
  entry_0: 
    store i32 %arg_2, ptr %arg_0
    ret void
}
define void @"generated_print_(i32, i8*)"(ptr sret({ i32, i8* }) %arg_0, {  } %arg_1, { i32, i8* } %arg_2) {
  entry_0: 
    call void @printf(i8* @const_1, [7 x i8]* @const_6)
    %var_0 = extractvalue { i32, i8* } %arg_2, 0
    %var_1 = alloca {  }
    %var_2 = load {  }, ptr %var_1
    store {  } %var_2, ptr %var_1
    %var_3 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_4 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_3
    %var_5 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_4, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_6 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_5, {  } %var_2, 1
    store { void (i32*, {  }, i32)*, {  } } %var_6, ptr %var_3
    %var_7 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_6, 0
    %var_8 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_6, 1
    %var_9 = alloca i32
    call void %var_7(i32* %var_9, {  } %var_8, i32 %var_0)
    %var_10 = load i32, ptr %var_9
    call void @printf(i8* @const_1, [3 x i8]* @const_7)
    %var_11 = extractvalue { i32, i8* } %arg_2, 1
    %var_12 = alloca {  }
    %var_13 = load {  }, ptr %var_12
    store {  } %var_13, ptr %var_12
    %var_14 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_15 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_14
    %var_16 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_15, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_17 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_16, {  } %var_13, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_17, ptr %var_14
    %var_18 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_17, 0
    %var_19 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_17, 1
    %var_20 = alloca i8*
    call void %var_18(i8** %var_20, {  } %var_19, i8* %var_11)
    %var_21 = load i8*, ptr %var_20
    call void @printf(i8* @const_1, [2 x i8]* @const_8)
    store { i32, i8* } %arg_2, ptr %arg_0
    ret void
}
define void @"generated_print_f32"(ptr sret(float) %arg_0, {  } %arg_1, float %arg_2) {
  entry_0: 
    call void @printf(i8* @const_10, float %arg_2)
    store float %arg_2, ptr %arg_0
    ret void
}
define void @"generated_print_i1"(ptr sret(i1) %arg_0, {  } %arg_1, i1 %arg_2) {
  entry_0: 
    %var_0 = select i1 %arg_2, [5 x i8]* @const_12, [5 x i8]* @const_13
    call void @printf(i8* @const_1, [5 x i8]* %var_0)
    store i1 %arg_2, ptr %arg_0
    ret void
}
define void @"generated_print_symbol"(ptr sret(i64) %arg_0, {  } %arg_1, i64 %arg_2) {
  entry_0: 
    call void @print_symbol(i64 %arg_2)
    store i64 %arg_2, ptr %arg_0
    ret void
}
declare void @print_symbol(i64)
"
`;

exports[`generic print > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [4 x i8] c"fn[\\00"
@const_1 = constant [3 x i8] c"%s\\00"
@const_2 = constant [2 x i8] c"]\\00"
@const_3 = constant [2 x i8] c"\\0A\\00"
@const_4 = constant [3 x i8] c"%i\\00"
@const_5 = local_unnamed_addr constant i32 1
@const_6 = constant [7 x i8] c"tuple(\\00"
@const_7 = constant [3 x i8] c", \\00"
@const_8 = constant [2 x i8] c")\\00"
@const_9 = constant [3 x i8] c"ab\\00"
@const_10 = constant [3 x i8] c"%f\\00"
@const_11 = local_unnamed_addr constant float 1.250000e+00
@const_12 = constant [5 x i8] c"true\\00"
@const_13 = constant [6 x i8] c"false\\00"
@const_14 = local_unnamed_addr constant i1 true
@const_15 = local_unnamed_addr constant i1 false
@const_16 = local_unnamed_addr constant i64 0
@const_17 = local_unnamed_addr constant i64 1
@const_18 = local_unnamed_addr constant i64 2
@const_19 = constant [5 x i8] c"unit\\00"
@const_20 = constant [12 x i8] c"atom_atom_a\\00"
@const_21 = constant [16 x i8] c"symbol_symbol_a\\00"
@symbols_metadata_array = constant [3 x { ptr }] [{ ptr } { ptr @const_19 }, { ptr } { ptr @const_20 }, { ptr } { ptr @const_21 }]
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_0)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_2)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_3)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_0)
  tail call void @printf(ptr nonnull @const_4, i32 1)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_2)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_3)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_0)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_2)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_3)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_6)
  tail call void @printf(ptr nonnull @const_4, i32 1)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_7)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_9)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_8)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_3)
  tail call void @printf(ptr nonnull @const_4, i32 1)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_3)
  tail call void @printf(ptr nonnull @const_10, float 1.250000e+00)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_3)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_9)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_3)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_12)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_3)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_13)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_3)
  tail call void @print_symbol(i64 0)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_3)
  tail call void @print_symbol(i64 1)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_3)
  tail call void @print_symbol(i64 2)
  ret i32 0
}

define void @"generated_print_i32[](i32)"(ptr nocapture writeonly sret({ ptr, {} }) %arg_0, {} %arg_1, { ptr, {} } %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_0)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_2)
  %arg_2.elt = extractvalue { ptr, {} } %arg_2, 0
  store ptr %arg_2.elt, ptr %arg_0, align 8
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_93(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

define void @"generated_print_i8*"(ptr nocapture writeonly sret(ptr) %arg_0, {} %arg_1, ptr %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_1, ptr %arg_2)
  store ptr %arg_2, ptr %arg_0, align 8
  ret void
}

define void @"generated_print_i32[i32](i32)"(ptr nocapture writeonly sret({ ptr, { i32 } }) %arg_0, {} %arg_1, { ptr, { i32 } } %arg_2) local_unnamed_addr {
entry_0:
  %var_0 = extractvalue { ptr, { i32 } } %arg_2, 1
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_0)
  %var_1 = extractvalue { i32 } %var_0, 0
  tail call void @printf(ptr nonnull @const_4, i32 %var_1)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_2)
  store { ptr, { i32 } } %arg_2, ptr %arg_0, align 8
  ret void
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_4, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_94(ptr nocapture writeonly sret({ ptr, { i32 } }) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  %var_2 = insertvalue { i32 } undef, i32 %arg_2, 0
  %var_6 = insertvalue { ptr, { i32 } } { ptr @fn_95, { i32 } undef }, { i32 } %var_2, 1
  store { ptr, { i32 } } %var_6, ptr %arg_0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_95(ptr nocapture writeonly sret(i32) %arg_0, { i32 } %arg_1, i32 %arg_2) #1 {
entry_0:
  %var_0 = extractvalue { i32 } %arg_1, 0
  store i32 %var_0, ptr %arg_0, align 4
  ret void
}

define void @"generated_print_i32[](i32, i32)"(ptr nocapture writeonly sret({ ptr, {} }) %arg_0, {} %arg_1, { ptr, {} } %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_0)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_2)
  %arg_2.elt = extractvalue { ptr, {} } %arg_2, 0
  store ptr %arg_2.elt, ptr %arg_0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_96(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2, i32 %arg_3) local_unnamed_addr #1 {
entry_0:
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

define void @"generated_print_(i32, i8*)"(ptr nocapture writeonly sret({ i32, ptr }) %arg_0, {} %arg_1, { i32, ptr } %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_6)
  %var_0 = extractvalue { i32, ptr } %arg_2, 0
  tail call void @printf(ptr nonnull @const_4, i32 %var_0)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_7)
  %var_11 = extractvalue { i32, ptr } %arg_2, 1
  tail call void @printf(ptr nonnull @const_1, ptr %var_11)
  tail call void @printf(ptr nonnull @const_1, ptr nonnull @const_8)
  store { i32, ptr } %arg_2, ptr %arg_0, align 8
  ret void
}

define void @generated_print_f32(ptr nocapture writeonly sret(float) %arg_0, {} %arg_1, float %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_10, float %arg_2)
  store float %arg_2, ptr %arg_0, align 4
  ret void
}

define void @generated_print_i1(ptr nocapture writeonly sret(i1) %arg_0, {} %arg_1, i1 %arg_2) local_unnamed_addr {
entry_0:
  %var_0 = select i1 %arg_2, ptr @const_12, ptr @const_13
  tail call void @printf(ptr nonnull @const_1, ptr nonnull %var_0)
  store i1 %arg_2, ptr %arg_0, align 1
  ret void
}

define void @generated_print_symbol(ptr nocapture writeonly sret(i64) %arg_0, {} %arg_1, i64 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @print_symbol(i64 %arg_2)
  store i64 %arg_2, ptr %arg_0, align 8
  ret void
}

declare void @print_symbol(i64) local_unnamed_addr

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`generic print > stderr 1`] = `[]`;

exports[`generic print > stdout 1`] = `
[
  "fn[]
fn[1]
fn[]
tuple(1, ab)
1
0.000000
ab
true
false
symbol(unit)
symbol(atom_atom_a)
symbol(symbol_symbol_a)",
]
`;

exports[`simply typed lambda calc compilation > apply > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = constant i32 2
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_0 = alloca {  }
    %var_1 = load {  }, ptr %var_0
    store {  } %var_1, ptr %var_0
    %var_2 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_3 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_2
    %var_4 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_3, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_5 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_4, {  } %var_1, 1
    store { void (i32*, {  }, i32)*, {  } } %var_5, ptr %var_2
    %var_6 = alloca {  }
    %var_7 = load {  }, ptr %var_6
    store {  } %var_7, ptr %var_6
    %var_8 = alloca { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } }
    %var_9 = load { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } }, ptr %var_8
    %var_10 = insertvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_9, void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })* @fn_25, 0
    %var_11 = insertvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_10, {  } %var_7, 1
    store { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_11, ptr %var_8
    %var_12 = alloca {  }
    %var_13 = load {  }, ptr %var_12
    store {  } %var_13, ptr %var_12
    %var_14 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_15 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_14
    %var_16 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_15, void (i32*, {  }, i32)* @fn_27, 0
    %var_17 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_16, {  } %var_13, 1
    store { void (i32*, {  }, i32)*, {  } } %var_17, ptr %var_14
    %var_18 = extractvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_11, 0
    %var_19 = extractvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }*, {  }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_11, 1
    %var_20 = alloca { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }
    call void %var_18({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }* %var_20, {  } %var_19, { void (i32*, {  }, i32)*, {  } } %var_17)
    %var_21 = load { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }, ptr %var_20
    %var_22 = load i32, ptr @const_1
    %var_23 = extractvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_21, 0
    %var_24 = extractvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_21, 1
    %var_25 = alloca i32
    call void %var_23(i32* %var_25, { { void (i32*, {  }, i32)*, {  } } } %var_24, i32 %var_22)
    %var_26 = load i32, ptr %var_25
    %var_27 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_5, 0
    %var_28 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_5, 1
    %var_29 = alloca i32
    call void %var_27(i32* %var_29, {  } %var_28, i32 %var_26)
    %var_30 = load i32, ptr %var_29
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_25(ptr sret({ void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }) %arg_0, {  } %arg_1, { void (i32*, {  }, i32)*, {  } } %arg_2) {
  entry_0: 
    %var_0 = alloca { { void (i32*, {  }, i32)*, {  } } }
    %var_1 = load { { void (i32*, {  }, i32)*, {  } } }, ptr %var_0
    %var_2 = insertvalue { { void (i32*, {  }, i32)*, {  } } } %var_1, { void (i32*, {  }, i32)*, {  } } %arg_2, 0
    store { { void (i32*, {  }, i32)*, {  } } } %var_2, ptr %var_0
    %var_3 = alloca { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }
    %var_4 = load { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } }, ptr %var_3
    %var_5 = insertvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_4, void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)* @fn_26, 0
    %var_6 = insertvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_5, { { void (i32*, {  }, i32)*, {  } } } %var_2, 1
    store { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_6, ptr %var_3
    store { void (i32*, { { void (i32*, {  }, i32)*, {  } } }, i32)*, { { void (i32*, {  }, i32)*, {  } } } } %var_6, ptr %arg_0
    ret void
}
define void @fn_26(ptr sret(i32) %arg_0, { { void (i32*, {  }, i32)*, {  } } } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_0 = extractvalue { { void (i32*, {  }, i32)*, {  } } } %arg_1, 0
    %var_1 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_0, 0
    %var_2 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_0, 1
    %var_3 = alloca i32
    call void %var_1(i32* %var_3, {  } %var_2, i32 %arg_2)
    %var_4 = load i32, ptr %var_3
    store i32 %var_4, ptr %arg_0
    ret void
}
define void @fn_27(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    store i32 %arg_2, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > apply > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = local_unnamed_addr constant i32 2
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, i32 2)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_25(ptr nocapture writeonly sret({ ptr, { { ptr, {} } } }) %arg_0, {} %arg_1, { ptr, {} } %arg_2) local_unnamed_addr #1 {
entry_0:
  store ptr @fn_26, ptr %arg_0, align 8
  %arg_0.repack1 = getelementptr inbounds { ptr, { { ptr, {} } } }, ptr %arg_0, i64 0, i32 1
  %arg_2.elt = extractvalue { ptr, {} } %arg_2, 0
  store ptr %arg_2.elt, ptr %arg_0.repack1, align 8
  ret void
}

define void @fn_26(ptr nocapture writeonly sret(i32) %arg_0, { { ptr, {} } } %arg_1, i32 %arg_2) {
entry_0:
  %var_0 = extractvalue { { ptr, {} } } %arg_1, 0
  %var_1 = extractvalue { ptr, {} } %var_0, 0
  %var_3 = alloca i32, align 4
  call void %var_1(ptr nonnull %var_3, {} zeroinitializer, i32 %arg_2)
  %var_4 = load i32, ptr %var_3, align 4
  store i32 %var_4, ptr %arg_0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_27(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > apply > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > apply > stdout 1`] = `
[
  "2",
]
`;

exports[`simply typed lambda calc compilation > church tuple > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = constant i32 1
@const_2 = constant i32 2
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_0 = alloca {  }
    %var_1 = load {  }, ptr %var_0
    store {  } %var_1, ptr %var_0
    %var_2 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_3 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_2
    %var_4 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_3, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_5 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_4, {  } %var_1, 1
    store { void (i32*, {  }, i32)*, {  } } %var_5, ptr %var_2
    %var_6 = alloca {  }
    %var_7 = load {  }, ptr %var_6
    store {  } %var_7, ptr %var_6
    %var_8 = alloca { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }
    %var_9 = load { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_8
    %var_10 = insertvalue { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_9, void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)* @fn_33, 0
    %var_11 = insertvalue { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_10, {  } %var_7, 1
    store { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_11, ptr %var_8
    %var_12 = load i32, ptr @const_1
    %var_13 = extractvalue { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_11, 0
    %var_14 = extractvalue { void ({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_11, 1
    %var_15 = alloca { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }
    call void %var_13({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }* %var_15, {  } %var_14, i32 %var_12)
    %var_16 = load { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }, ptr %var_15
    %var_17 = load i32, ptr @const_2
    %var_18 = extractvalue { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_16, 0
    %var_19 = extractvalue { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_16, 1
    %var_20 = alloca { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }
    call void %var_18({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }* %var_20, { i32 } %var_19, i32 %var_17)
    %var_21 = load { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }, ptr %var_20
    %var_22 = alloca {  }
    %var_23 = load {  }, ptr %var_22
    store {  } %var_23, ptr %var_22
    %var_24 = alloca { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }
    %var_25 = load { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_24
    %var_26 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_25, void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)* @fn_36, 0
    %var_27 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_26, {  } %var_23, 1
    store { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_27, ptr %var_24
    %var_28 = extractvalue { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_21, 0
    %var_29 = extractvalue { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_21, 1
    %var_30 = alloca i32
    call void %var_28(i32* %var_30, { i32, i32 } %var_29, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_27)
    %var_31 = load i32, ptr %var_30
    %var_32 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_5, 0
    %var_33 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_5, 1
    %var_34 = alloca i32
    call void %var_32(i32* %var_34, {  } %var_33, i32 %var_31)
    %var_35 = load i32, ptr %var_34
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_33(ptr sret({ void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_0 = alloca { i32 }
    %var_1 = load { i32 }, ptr %var_0
    %var_2 = insertvalue { i32 } %var_1, i32 %arg_2, 0
    store { i32 } %var_2, ptr %var_0
    %var_3 = alloca { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }
    %var_4 = load { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }, ptr %var_3
    %var_5 = insertvalue { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_4, void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)* @fn_34, 0
    %var_6 = insertvalue { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_5, { i32 } %var_2, 1
    store { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_6, ptr %var_3
    store { void ({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_6, ptr %arg_0
    ret void
}
define void @fn_34(ptr sret({ void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }) %arg_0, { i32 } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_0 = extractvalue { i32 } %arg_1, 0
    %var_1 = alloca { i32, i32 }
    %var_2 = load { i32, i32 }, ptr %var_1
    %var_3 = insertvalue { i32, i32 } %var_2, i32 %var_0, 0
    %var_4 = insertvalue { i32, i32 } %var_3, i32 %arg_2, 1
    store { i32, i32 } %var_4, ptr %var_1
    %var_5 = alloca { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }
    %var_6 = load { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } }, ptr %var_5
    %var_7 = insertvalue { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_6, void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })* @fn_35, 0
    %var_8 = insertvalue { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_7, { i32, i32 } %var_4, 1
    store { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_8, ptr %var_5
    store { void (i32*, { i32, i32 }, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } })*, { i32, i32 } } %var_8, ptr %arg_0
    ret void
}
define void @fn_35(ptr sret(i32) %arg_0, { i32, i32 } %arg_1, { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %arg_2) {
  entry_0: 
    %var_0 = extractvalue { i32, i32 } %arg_1, 0
    %var_1 = extractvalue { i32, i32 } %arg_1, 1
    %var_2 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %arg_2, 0
    %var_3 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %arg_2, 1
    %var_4 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    call void %var_2({ void (i32*, { i32 }, i32)*, { i32 } }* %var_4, {  } %var_3, i32 %var_0)
    %var_5 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_4
    %var_6 = extractvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_5, 0
    %var_7 = extractvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_5, 1
    %var_8 = alloca i32
    call void %var_6(i32* %var_8, { i32 } %var_7, i32 %var_1)
    %var_9 = load i32, ptr %var_8
    store i32 %var_9, ptr %arg_0
    ret void
}
define void @fn_36(ptr sret({ void (i32*, { i32 }, i32)*, { i32 } }) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_0 = alloca { i32 }
    %var_1 = load { i32 }, ptr %var_0
    %var_2 = insertvalue { i32 } %var_1, i32 %arg_2, 0
    store { i32 } %var_2, ptr %var_0
    %var_3 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    %var_4 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_3
    %var_5 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_4, void (i32*, { i32 }, i32)* @fn_37, 0
    %var_6 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_5, { i32 } %var_2, 1
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_6, ptr %var_3
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_6, ptr %arg_0
    ret void
}
define void @fn_37(ptr sret(i32) %arg_0, { i32 } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_0 = extractvalue { i32 } %arg_1, 0
    store i32 %var_0, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > church tuple > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = local_unnamed_addr constant i32 1
@const_2 = local_unnamed_addr constant i32 2
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, i32 1)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_33(ptr nocapture writeonly sret({ ptr, { i32 } }) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  %var_2 = insertvalue { i32 } undef, i32 %arg_2, 0
  %var_6 = insertvalue { ptr, { i32 } } { ptr @fn_34, { i32 } undef }, { i32 } %var_2, 1
  store { ptr, { i32 } } %var_6, ptr %arg_0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_34(ptr nocapture writeonly sret({ ptr, { i32, i32 } }) %arg_0, { i32 } %arg_1, i32 %arg_2) #1 {
entry_0:
  %var_0 = extractvalue { i32 } %arg_1, 0
  store ptr @fn_35, ptr %arg_0, align 8
  %arg_0.repack1 = getelementptr inbounds { ptr, { i32, i32 } }, ptr %arg_0, i64 0, i32 1
  store i32 %var_0, ptr %arg_0.repack1, align 8
  %arg_0.repack1.repack3 = getelementptr inbounds { ptr, { i32, i32 } }, ptr %arg_0, i64 0, i32 1, i32 1
  store i32 %arg_2, ptr %arg_0.repack1.repack3, align 4
  ret void
}

define void @fn_35(ptr nocapture writeonly sret(i32) %arg_0, { i32, i32 } %arg_1, { ptr, {} } %arg_2) {
entry_0:
  %var_0 = extractvalue { i32, i32 } %arg_1, 0
  %var_1 = extractvalue { i32, i32 } %arg_1, 1
  %var_2 = extractvalue { ptr, {} } %arg_2, 0
  %var_4 = alloca { ptr, { i32 } }, align 8
  call void %var_2(ptr nonnull %var_4, {} zeroinitializer, i32 %var_0)
  %var_5.fca.0.load = load ptr, ptr %var_4, align 8
  %var_5.fca.1.0.gep = getelementptr inbounds { ptr, { i32 } }, ptr %var_4, i64 0, i32 1, i32 0
  %var_5.fca.1.0.load = load i32, ptr %var_5.fca.1.0.gep, align 8
  %var_7 = insertvalue { i32 } poison, i32 %var_5.fca.1.0.load, 0
  %var_8 = alloca i32, align 4
  call void %var_5.fca.0.load(ptr nonnull %var_8, { i32 } %var_7, i32 %var_1)
  %var_9 = load i32, ptr %var_8, align 4
  store i32 %var_9, ptr %arg_0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_36(ptr nocapture writeonly sret({ ptr, { i32 } }) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  %var_2 = insertvalue { i32 } undef, i32 %arg_2, 0
  %var_6 = insertvalue { ptr, { i32 } } { ptr @fn_37, { i32 } undef }, { i32 } %var_2, 1
  store { ptr, { i32 } } %var_6, ptr %arg_0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_37(ptr nocapture writeonly sret(i32) %arg_0, { i32 } %arg_1, i32 %arg_2) #1 {
entry_0:
  %var_0 = extractvalue { i32 } %arg_1, 0
  store i32 %var_0, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > church tuple > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > church tuple > stdout 1`] = `
[
  "1",
]
`;

exports[`simply typed lambda calc compilation > church tuple 2 > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = constant i32 1
@const_2 = constant i32 2
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_0 = alloca {  }
    %var_1 = load {  }, ptr %var_0
    store {  } %var_1, ptr %var_0
    %var_2 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_3 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_2
    %var_4 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_3, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_5 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_4, {  } %var_1, 1
    store { void (i32*, {  }, i32)*, {  } } %var_5, ptr %var_2
    %var_6 = alloca {  }
    %var_7 = load {  }, ptr %var_6
    store {  } %var_7, ptr %var_6
    %var_8 = alloca { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } }
    %var_9 = load { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } }, ptr %var_8
    %var_10 = insertvalue { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_9, void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })* @fn_26, 0
    %var_11 = insertvalue { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_10, {  } %var_7, 1
    store { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_11, ptr %var_8
    %var_12 = load i32, ptr @const_1
    %var_13 = load i32, ptr @const_2
    %var_14 = alloca {  }
    %var_15 = load {  }, ptr %var_14
    store {  } %var_15, ptr %var_14
    %var_16 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_17 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_16
    %var_18 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_17, void (i32*, {  }, i32)* @fn_27, 0
    %var_19 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_18, {  } %var_15, 1
    store { void (i32*, {  }, i32)*, {  } } %var_19, ptr %var_16
    %var_20 = extractvalue { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_11, 0
    %var_21 = extractvalue { void (i32*, {  }, i32, i32, { void (i32*, {  }, i32, i32)*, {  } })*, {  } } %var_11, 1
    %var_22 = alloca i32
    call void %var_20(i32* %var_22, {  } %var_21, i32 %var_12, i32 %var_13, { void (i32*, {  }, i32, i32)*, {  } } %var_19)
    %var_23 = load i32, ptr %var_22
    %var_24 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_5, 0
    %var_25 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_5, 1
    %var_26 = alloca i32
    call void %var_24(i32* %var_26, {  } %var_25, i32 %var_23)
    %var_27 = load i32, ptr %var_26
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_26(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2, i32 %arg_3, { void (i32*, {  }, i32, i32)*, {  } } %arg_4) {
  entry_0: 
    %var_0 = extractvalue { void (i32*, {  }, i32, i32)*, {  } } %arg_4, 0
    %var_1 = extractvalue { void (i32*, {  }, i32, i32)*, {  } } %arg_4, 1
    %var_2 = alloca i32
    call void %var_0(i32* %var_2, {  } %var_1, i32 %arg_2, i32 %arg_3)
    %var_3 = load i32, ptr %var_2
    store i32 %var_3, ptr %arg_0
    ret void
}
define void @fn_27(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    store i32 %arg_2, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > church tuple 2 > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = local_unnamed_addr constant i32 1
@const_2 = local_unnamed_addr constant i32 2
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, i32 1)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

define void @fn_26(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2, i32 %arg_3, { ptr, {} } %arg_4) local_unnamed_addr {
entry_0:
  %var_0 = extractvalue { ptr, {} } %arg_4, 0
  %var_2 = alloca i32, align 4
  call void %var_0(ptr nonnull %var_2, {} zeroinitializer, i32 %arg_2, i32 %arg_3)
  %var_3 = load i32, ptr %var_2, align 4
  store i32 %var_3, ptr %arg_0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_27(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > church tuple 2 > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > church tuple 2 > stdout 1`] = `
[
  "1",
]
`;

exports[`simply typed lambda calc compilation > either > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_0 = alloca {  }
    %var_1 = load {  }, ptr %var_0
    store {  } %var_1, ptr %var_0
    %var_2 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_3 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_2
    %var_4 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_3, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_5 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_4, {  } %var_1, 1
    store { void (i32*, {  }, i32)*, {  } } %var_5, ptr %var_2
    %var_6 = alloca {  }
    %var_7 = load {  }, ptr %var_6
    store {  } %var_7, ptr %var_6
    %var_8 = alloca { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } }
    %var_9 = load { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_8
    %var_10 = insertvalue { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } } %var_9, void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)* @fn_31, 0
    %var_11 = insertvalue { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } } %var_10, {  } %var_7, 1
    store { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } } %var_11, ptr %var_8
    %var_12 = load i32, ptr @const_1
    %var_13 = extractvalue { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } } %var_11, 0
    %var_14 = extractvalue { void ({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }*, {  }, i32)*, {  } } %var_11, 1
    %var_15 = alloca { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }
    call void %var_13({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }* %var_15, {  } %var_14, i32 %var_12)
    %var_16 = load { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }, ptr %var_15
    %var_17 = alloca {  }
    %var_18 = load {  }, ptr %var_17
    store {  } %var_18, ptr %var_17
    %var_19 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_20 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_19
    %var_21 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_20, void (i32*, {  }, i32)* @fn_34, 0
    %var_22 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_21, {  } %var_18, 1
    store { void (i32*, {  }, i32)*, {  } } %var_22, ptr %var_19
    %var_23 = extractvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_16, 0
    %var_24 = extractvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_16, 1
    %var_25 = alloca { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }
    call void %var_23({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }* %var_25, { i32 } %var_24, { void (i32*, {  }, i32)*, {  } } %var_22)
    %var_26 = load { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }, ptr %var_25
    %var_27 = alloca {  }
    %var_28 = load {  }, ptr %var_27
    store {  } %var_28, ptr %var_27
    %var_29 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_30 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_29
    %var_31 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_30, void (i32*, {  }, i32)* @fn_35, 0
    %var_32 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_31, {  } %var_28, 1
    store { void (i32*, {  }, i32)*, {  } } %var_32, ptr %var_29
    %var_33 = extractvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_26, 0
    %var_34 = extractvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_26, 1
    %var_35 = alloca i32
    call void %var_33(i32* %var_35, { { void (i32*, {  }, i32)*, {  } }, i32 } %var_34, { void (i32*, {  }, i32)*, {  } } %var_32)
    %var_36 = load i32, ptr %var_35
    %var_37 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_5, 0
    %var_38 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_5, 1
    %var_39 = alloca i32
    call void %var_37(i32* %var_39, {  } %var_38, i32 %var_36)
    %var_40 = load i32, ptr %var_39
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_31(ptr sret({ void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_0 = alloca { i32 }
    %var_1 = load { i32 }, ptr %var_0
    %var_2 = insertvalue { i32 } %var_1, i32 %arg_2, 0
    store { i32 } %var_2, ptr %var_0
    %var_3 = alloca { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }
    %var_4 = load { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } }, ptr %var_3
    %var_5 = insertvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_4, void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })* @fn_32, 0
    %var_6 = insertvalue { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_5, { i32 } %var_2, 1
    store { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_6, ptr %var_3
    store { void ({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }*, { i32 }, { void (i32*, {  }, i32)*, {  } })*, { i32 } } %var_6, ptr %arg_0
    ret void
}
define void @fn_32(ptr sret({ void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }) %arg_0, { i32 } %arg_1, { void (i32*, {  }, i32)*, {  } } %arg_2) {
  entry_0: 
    %var_0 = extractvalue { i32 } %arg_1, 0
    %var_1 = alloca { { void (i32*, {  }, i32)*, {  } }, i32 }
    %var_2 = load { { void (i32*, {  }, i32)*, {  } }, i32 }, ptr %var_1
    %var_3 = insertvalue { { void (i32*, {  }, i32)*, {  } }, i32 } %var_2, { void (i32*, {  }, i32)*, {  } } %arg_2, 0
    %var_4 = insertvalue { { void (i32*, {  }, i32)*, {  } }, i32 } %var_3, i32 %var_0, 1
    store { { void (i32*, {  }, i32)*, {  } }, i32 } %var_4, ptr %var_1
    %var_5 = alloca { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }
    %var_6 = load { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } }, ptr %var_5
    %var_7 = insertvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_6, void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })* @fn_33, 0
    %var_8 = insertvalue { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_7, { { void (i32*, {  }, i32)*, {  } }, i32 } %var_4, 1
    store { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_8, ptr %var_5
    store { void (i32*, { { void (i32*, {  }, i32)*, {  } }, i32 }, { void (i32*, {  }, i32)*, {  } })*, { { void (i32*, {  }, i32)*, {  } }, i32 } } %var_8, ptr %arg_0
    ret void
}
define void @fn_33(ptr sret(i32) %arg_0, { { void (i32*, {  }, i32)*, {  } }, i32 } %arg_1, { void (i32*, {  }, i32)*, {  } } %arg_2) {
  entry_0: 
    %var_0 = extractvalue { { void (i32*, {  }, i32)*, {  } }, i32 } %arg_1, 0
    %var_1 = extractvalue { { void (i32*, {  }, i32)*, {  } }, i32 } %arg_1, 1
    %var_2 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_0, 0
    %var_3 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_0, 1
    %var_4 = alloca i32
    call void %var_2(i32* %var_4, {  } %var_3, i32 %var_1)
    %var_5 = load i32, ptr %var_4
    store i32 %var_5, ptr %arg_0
    ret void
}
define void @fn_34(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    store i32 %arg_2, ptr %arg_0
    ret void
}
define void @fn_35(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    store i32 %arg_2, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > either > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, i32 1)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_31(ptr nocapture writeonly sret({ ptr, { i32 } }) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  %var_2 = insertvalue { i32 } undef, i32 %arg_2, 0
  %var_6 = insertvalue { ptr, { i32 } } { ptr @fn_32, { i32 } undef }, { i32 } %var_2, 1
  store { ptr, { i32 } } %var_6, ptr %arg_0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_32(ptr nocapture writeonly sret({ ptr, { { ptr, {} }, i32 } }) %arg_0, { i32 } %arg_1, { ptr, {} } %arg_2) #1 {
entry_0:
  %var_0 = extractvalue { i32 } %arg_1, 0
  %var_3 = insertvalue { { ptr, {} }, i32 } { { ptr, {} } { ptr undef, {} poison }, i32 undef }, { ptr, {} } %arg_2, 0
  %var_4 = insertvalue { { ptr, {} }, i32 } %var_3, i32 %var_0, 1
  store ptr @fn_33, ptr %arg_0, align 8
  %arg_0.repack1 = getelementptr inbounds { ptr, { { ptr, {} }, i32 } }, ptr %arg_0, i64 0, i32 1
  store { { ptr, {} }, i32 } %var_4, ptr %arg_0.repack1, align 8
  ret void
}

define void @fn_33(ptr nocapture writeonly sret(i32) %arg_0, { { ptr, {} }, i32 } %arg_1, { ptr, {} } %arg_2) {
entry_0:
  %var_0 = extractvalue { { ptr, {} }, i32 } %arg_1, 0
  %var_1 = extractvalue { { ptr, {} }, i32 } %arg_1, 1
  %var_2 = extractvalue { ptr, {} } %var_0, 0
  %var_4 = alloca i32, align 4
  call void %var_2(ptr nonnull %var_4, {} zeroinitializer, i32 %var_1)
  %var_5 = load i32, ptr %var_4, align 4
  store i32 %var_5, ptr %arg_0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_34(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_35(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > either > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > either > stdout 1`] = `
[
  "1",
]
`;

exports[`simply typed lambda calc compilation > either 2 > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_0 = alloca {  }
    %var_1 = load {  }, ptr %var_0
    store {  } %var_1, ptr %var_0
    %var_2 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_3 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_2
    %var_4 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_3, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_5 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_4, {  } %var_1, 1
    store { void (i32*, {  }, i32)*, {  } } %var_5, ptr %var_2
    %var_6 = alloca {  }
    %var_7 = load {  }, ptr %var_6
    store {  } %var_7, ptr %var_6
    %var_8 = alloca { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } }
    %var_9 = load { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } }, ptr %var_8
    %var_10 = insertvalue { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_9, void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })* @fn_27, 0
    %var_11 = insertvalue { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_10, {  } %var_7, 1
    store { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_11, ptr %var_8
    %var_12 = load i32, ptr @const_1
    %var_13 = alloca {  }
    %var_14 = load {  }, ptr %var_13
    store {  } %var_14, ptr %var_13
    %var_15 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_16 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_15
    %var_17 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_16, void (i32*, {  }, i32)* @fn_28, 0
    %var_18 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_17, {  } %var_14, 1
    store { void (i32*, {  }, i32)*, {  } } %var_18, ptr %var_15
    %var_19 = alloca {  }
    %var_20 = load {  }, ptr %var_19
    store {  } %var_20, ptr %var_19
    %var_21 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_22 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_21
    %var_23 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_22, void (i32*, {  }, i32)* @fn_29, 0
    %var_24 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_23, {  } %var_20, 1
    store { void (i32*, {  }, i32)*, {  } } %var_24, ptr %var_21
    %var_25 = extractvalue { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_11, 0
    %var_26 = extractvalue { void (i32*, {  }, i32, { void (i32*, {  }, i32)*, {  } }, { void (i32*, {  }, i32)*, {  } })*, {  } } %var_11, 1
    %var_27 = alloca i32
    call void %var_25(i32* %var_27, {  } %var_26, i32 %var_12, { void (i32*, {  }, i32)*, {  } } %var_18, { void (i32*, {  }, i32)*, {  } } %var_24)
    %var_28 = load i32, ptr %var_27
    %var_29 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_5, 0
    %var_30 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_5, 1
    %var_31 = alloca i32
    call void %var_29(i32* %var_31, {  } %var_30, i32 %var_28)
    %var_32 = load i32, ptr %var_31
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_27(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2, { void (i32*, {  }, i32)*, {  } } %arg_3, { void (i32*, {  }, i32)*, {  } } %arg_4) {
  entry_0: 
    %var_0 = extractvalue { void (i32*, {  }, i32)*, {  } } %arg_3, 0
    %var_1 = extractvalue { void (i32*, {  }, i32)*, {  } } %arg_3, 1
    %var_2 = alloca i32
    call void %var_0(i32* %var_2, {  } %var_1, i32 %arg_2)
    %var_3 = load i32, ptr %var_2
    store i32 %var_3, ptr %arg_0
    ret void
}
define void @fn_28(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    store i32 %arg_2, ptr %arg_0
    ret void
}
define void @fn_29(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    store i32 %arg_2, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > either 2 > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, i32 1)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

define void @fn_27(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2, { ptr, {} } %arg_3, { ptr, {} } %arg_4) local_unnamed_addr {
entry_0:
  %var_0 = extractvalue { ptr, {} } %arg_3, 0
  %var_2 = alloca i32, align 4
  call void %var_0(ptr nonnull %var_2, {} zeroinitializer, i32 %arg_2)
  %var_3 = load i32, ptr %var_2, align 4
  store i32 %var_3, ptr %arg_0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_28(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_29(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > either 2 > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > either 2 > stdout 1`] = `
[
  "1",
]
`;

exports[`simply typed lambda calc compilation > function application and literal print > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = constant i32 2
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_0 = alloca {  }
    %var_1 = load {  }, ptr %var_0
    store {  } %var_1, ptr %var_0
    %var_2 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_3 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_2
    %var_4 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_3, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_5 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_4, {  } %var_1, 1
    store { void (i32*, {  }, i32)*, {  } } %var_5, ptr %var_2
    %var_6 = alloca {  }
    %var_7 = load {  }, ptr %var_6
    store {  } %var_7, ptr %var_6
    %var_8 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_9 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_8
    %var_10 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_9, void (i32*, {  }, i32)* @fn_19, 0
    %var_11 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_10, {  } %var_7, 1
    store { void (i32*, {  }, i32)*, {  } } %var_11, ptr %var_8
    %var_12 = load i32, ptr @const_1
    %var_13 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_11, 0
    %var_14 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_11, 1
    %var_15 = alloca i32
    call void %var_13(i32* %var_15, {  } %var_14, i32 %var_12)
    %var_16 = load i32, ptr %var_15
    %var_17 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_5, 0
    %var_18 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_5, 1
    %var_19 = alloca i32
    call void %var_17(i32* %var_19, {  } %var_18, i32 %var_16)
    %var_20 = load i32, ptr %var_19
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_19(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_0 = add i32 %arg_2, %arg_2
    store i32 %var_0, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > function application and literal print > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = local_unnamed_addr constant i32 2
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, i32 4)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_19(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  %var_0 = shl i32 %arg_2, 1
  store i32 %var_0, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > function application and literal print > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > function application and literal print > stdout 1`] = `
[
  "4",
]
`;

exports[`simply typed lambda calc compilation > function closure > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = constant i32 2
@const_2 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_0 = alloca {  }
    %var_1 = load {  }, ptr %var_0
    store {  } %var_1, ptr %var_0
    %var_2 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_3 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_2
    %var_4 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_3, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_5 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_4, {  } %var_1, 1
    store { void (i32*, {  }, i32)*, {  } } %var_5, ptr %var_2
    %var_6 = alloca {  }
    %var_7 = load {  }, ptr %var_6
    store {  } %var_7, ptr %var_6
    %var_8 = alloca { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }
    %var_9 = load { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_8
    %var_10 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_9, void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)* @fn_25, 0
    %var_11 = insertvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_10, {  } %var_7, 1
    store { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_11, ptr %var_8
    %var_12 = load i32, ptr @const_2
    %var_13 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_11, 0
    %var_14 = extractvalue { void ({ void (i32*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_11, 1
    %var_15 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    call void %var_13({ void (i32*, { i32 }, i32)*, { i32 } }* %var_15, {  } %var_14, i32 %var_12)
    %var_16 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_15
    %var_17 = load i32, ptr @const_1
    %var_18 = extractvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_16, 0
    %var_19 = extractvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_16, 1
    %var_20 = alloca i32
    call void %var_18(i32* %var_20, { i32 } %var_19, i32 %var_17)
    %var_21 = load i32, ptr %var_20
    %var_22 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_5, 0
    %var_23 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_5, 1
    %var_24 = alloca i32
    call void %var_22(i32* %var_24, {  } %var_23, i32 %var_21)
    %var_25 = load i32, ptr %var_24
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_25(ptr sret({ void (i32*, { i32 }, i32)*, { i32 } }) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_0 = alloca { i32 }
    %var_1 = load { i32 }, ptr %var_0
    %var_2 = insertvalue { i32 } %var_1, i32 %arg_2, 0
    store { i32 } %var_2, ptr %var_0
    %var_3 = alloca { void (i32*, { i32 }, i32)*, { i32 } }
    %var_4 = load { void (i32*, { i32 }, i32)*, { i32 } }, ptr %var_3
    %var_5 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_4, void (i32*, { i32 }, i32)* @fn_26, 0
    %var_6 = insertvalue { void (i32*, { i32 }, i32)*, { i32 } } %var_5, { i32 } %var_2, 1
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_6, ptr %var_3
    store { void (i32*, { i32 }, i32)*, { i32 } } %var_6, ptr %arg_0
    ret void
}
define void @fn_26(ptr sret(i32) %arg_0, { i32 } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_0 = extractvalue { i32 } %arg_1, 0
    %var_1 = load i32, ptr @const_1
    %var_2 = mul i32 %var_1, %var_0
    %var_3 = add i32 %arg_2, %var_2
    store i32 %var_3, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > function closure > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = local_unnamed_addr constant i32 2
@const_2 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, i32 4)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_25(ptr nocapture writeonly sret({ ptr, { i32 } }) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  %var_2 = insertvalue { i32 } undef, i32 %arg_2, 0
  %var_6 = insertvalue { ptr, { i32 } } { ptr @fn_26, { i32 } undef }, { i32 } %var_2, 1
  store { ptr, { i32 } } %var_6, ptr %arg_0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_26(ptr nocapture writeonly sret(i32) %arg_0, { i32 } %arg_1, i32 %arg_2) #1 {
entry_0:
  %var_0 = extractvalue { i32 } %arg_1, 0
  %var_2 = shl i32 %var_0, 1
  %var_3 = add i32 %var_2, %arg_2
  store i32 %var_3, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > function closure > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > function closure > stdout 1`] = `
[
  "4",
]
`;

exports[`simply typed lambda calc compilation > function deep closure > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = constant i32 1
@const_2 = constant i32 3
@const_3 = constant i32 5
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_0 = alloca {  }
    %var_1 = load {  }, ptr %var_0
    store {  } %var_1, ptr %var_0
    %var_2 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_3 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_2
    %var_4 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_3, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_5 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_4, {  } %var_1, 1
    store { void (i32*, {  }, i32)*, {  } } %var_5, ptr %var_2
    %var_6 = alloca {  }
    %var_7 = load {  }, ptr %var_6
    store {  } %var_7, ptr %var_6
    %var_8 = alloca { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }
    %var_9 = load { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } }, ptr %var_8
    %var_10 = insertvalue { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_9, void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)* @fn_29, 0
    %var_11 = insertvalue { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_10, {  } %var_7, 1
    store { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_11, ptr %var_8
    %var_12 = load i32, ptr @const_1
    %var_13 = extractvalue { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_11, 0
    %var_14 = extractvalue { void ({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }*, {  }, i32)*, {  } } %var_11, 1
    %var_15 = alloca { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }
    call void %var_13({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }* %var_15, {  } %var_14, i32 %var_12)
    %var_16 = load { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }, ptr %var_15
    %var_17 = load i32, ptr @const_2
    %var_18 = extractvalue { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_16, 0
    %var_19 = extractvalue { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_16, 1
    %var_20 = alloca { void (i32*, { i32, i32 }, i32)*, { i32, i32 } }
    call void %var_18({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }* %var_20, { i32 } %var_19, i32 %var_17)
    %var_21 = load { void (i32*, { i32, i32 }, i32)*, { i32, i32 } }, ptr %var_20
    %var_22 = load i32, ptr @const_3
    %var_23 = extractvalue { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_21, 0
    %var_24 = extractvalue { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_21, 1
    %var_25 = alloca i32
    call void %var_23(i32* %var_25, { i32, i32 } %var_24, i32 %var_22)
    %var_26 = load i32, ptr %var_25
    %var_27 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_5, 0
    %var_28 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_5, 1
    %var_29 = alloca i32
    call void %var_27(i32* %var_29, {  } %var_28, i32 %var_26)
    %var_30 = load i32, ptr %var_29
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_29(ptr sret({ void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_0 = alloca { i32 }
    %var_1 = load { i32 }, ptr %var_0
    %var_2 = insertvalue { i32 } %var_1, i32 %arg_2, 0
    store { i32 } %var_2, ptr %var_0
    %var_3 = alloca { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }
    %var_4 = load { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } }, ptr %var_3
    %var_5 = insertvalue { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_4, void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)* @fn_30, 0
    %var_6 = insertvalue { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_5, { i32 } %var_2, 1
    store { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_6, ptr %var_3
    store { void ({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }*, { i32 }, i32)*, { i32 } } %var_6, ptr %arg_0
    ret void
}
define void @fn_30(ptr sret({ void (i32*, { i32, i32 }, i32)*, { i32, i32 } }) %arg_0, { i32 } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_0 = extractvalue { i32 } %arg_1, 0
    %var_1 = alloca { i32, i32 }
    %var_2 = load { i32, i32 }, ptr %var_1
    %var_3 = insertvalue { i32, i32 } %var_2, i32 %var_0, 0
    %var_4 = insertvalue { i32, i32 } %var_3, i32 %arg_2, 1
    store { i32, i32 } %var_4, ptr %var_1
    %var_5 = alloca { void (i32*, { i32, i32 }, i32)*, { i32, i32 } }
    %var_6 = load { void (i32*, { i32, i32 }, i32)*, { i32, i32 } }, ptr %var_5
    %var_7 = insertvalue { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_6, void (i32*, { i32, i32 }, i32)* @fn_31, 0
    %var_8 = insertvalue { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_7, { i32, i32 } %var_4, 1
    store { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_8, ptr %var_5
    store { void (i32*, { i32, i32 }, i32)*, { i32, i32 } } %var_8, ptr %arg_0
    ret void
}
define void @fn_31(ptr sret(i32) %arg_0, { i32, i32 } %arg_1, i32 %arg_2) {
  entry_0: 
    %var_0 = extractvalue { i32, i32 } %arg_1, 0
    %var_1 = extractvalue { i32, i32 } %arg_1, 1
    %var_2 = add i32 %var_1, %arg_2
    %var_3 = add i32 %var_0, %var_2
    store i32 %var_3, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > function deep closure > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = local_unnamed_addr constant i32 1
@const_2 = local_unnamed_addr constant i32 3
@const_3 = local_unnamed_addr constant i32 5
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, i32 9)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_29(ptr nocapture writeonly sret({ ptr, { i32 } }) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr #1 {
entry_0:
  %var_2 = insertvalue { i32 } undef, i32 %arg_2, 0
  %var_6 = insertvalue { ptr, { i32 } } { ptr @fn_30, { i32 } undef }, { i32 } %var_2, 1
  store { ptr, { i32 } } %var_6, ptr %arg_0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_30(ptr nocapture writeonly sret({ ptr, { i32, i32 } }) %arg_0, { i32 } %arg_1, i32 %arg_2) #1 {
entry_0:
  %var_0 = extractvalue { i32 } %arg_1, 0
  store ptr @fn_31, ptr %arg_0, align 8
  %arg_0.repack1 = getelementptr inbounds { ptr, { i32, i32 } }, ptr %arg_0, i64 0, i32 1
  store i32 %var_0, ptr %arg_0.repack1, align 8
  %arg_0.repack1.repack3 = getelementptr inbounds { ptr, { i32, i32 } }, ptr %arg_0, i64 0, i32 1, i32 1
  store i32 %arg_2, ptr %arg_0.repack1.repack3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_31(ptr nocapture writeonly sret(i32) %arg_0, { i32, i32 } %arg_1, i32 %arg_2) #1 {
entry_0:
  %var_0 = extractvalue { i32, i32 } %arg_1, 0
  %var_1 = extractvalue { i32, i32 } %arg_1, 1
  %var_2 = add i32 %var_1, %arg_2
  %var_3 = add i32 %var_2, %var_0
  store i32 %var_3, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > function deep closure > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > function deep closure > stdout 1`] = `
[
  "9",
]
`;

exports[`simply typed lambda calc compilation > function multiple args > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = constant i32 2
@const_2 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_0 = alloca {  }
    %var_1 = load {  }, ptr %var_0
    store {  } %var_1, ptr %var_0
    %var_2 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_3 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_2
    %var_4 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_3, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_5 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_4, {  } %var_1, 1
    store { void (i32*, {  }, i32)*, {  } } %var_5, ptr %var_2
    %var_6 = alloca {  }
    %var_7 = load {  }, ptr %var_6
    store {  } %var_7, ptr %var_6
    %var_8 = alloca { void (i32*, {  }, i32, i32)*, {  } }
    %var_9 = load { void (i32*, {  }, i32, i32)*, {  } }, ptr %var_8
    %var_10 = insertvalue { void (i32*, {  }, i32, i32)*, {  } } %var_9, void (i32*, {  }, i32, i32)* @fn_23, 0
    %var_11 = insertvalue { void (i32*, {  }, i32, i32)*, {  } } %var_10, {  } %var_7, 1
    store { void (i32*, {  }, i32, i32)*, {  } } %var_11, ptr %var_8
    %var_12 = load i32, ptr @const_2
    %var_13 = load i32, ptr @const_1
    %var_14 = extractvalue { void (i32*, {  }, i32, i32)*, {  } } %var_11, 0
    %var_15 = extractvalue { void (i32*, {  }, i32, i32)*, {  } } %var_11, 1
    %var_16 = alloca i32
    call void %var_14(i32* %var_16, {  } %var_15, i32 %var_12, i32 %var_13)
    %var_17 = load i32, ptr %var_16
    %var_18 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_5, 0
    %var_19 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_5, 1
    %var_20 = alloca i32
    call void %var_18(i32* %var_20, {  } %var_19, i32 %var_17)
    %var_21 = load i32, ptr %var_20
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
define void @fn_23(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2, i32 %arg_3) {
  entry_0: 
    %var_0 = load i32, ptr @const_1
    %var_1 = mul i32 %var_0, %arg_2
    %var_2 = add i32 %arg_3, %var_1
    store i32 %var_2, ptr %arg_0
    ret void
}
"
`;

exports[`simply typed lambda calc compilation > function multiple args > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = local_unnamed_addr constant i32 2
@const_2 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, i32 4)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @fn_23(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2, i32 %arg_3) local_unnamed_addr #1 {
entry_0:
  %var_1 = shl i32 %arg_2, 1
  %var_2 = add i32 %var_1, %arg_3
  store i32 %var_2, ptr %arg_0, align 4
  ret void
}

attributes #0 = { nofree nounwind }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
"
`;

exports[`simply typed lambda calc compilation > function multiple args > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > function multiple args > stdout 1`] = `
[
  "4",
]
`;

exports[`simply typed lambda calc compilation > hello world > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%s\\00"
@const_1 = constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_0 = alloca {  }
    %var_1 = load {  }, ptr %var_0
    store {  } %var_1, ptr %var_0
    %var_2 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_3 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_2
    %var_4 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_3, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_5 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_4, {  } %var_1, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_5, ptr %var_2
    %var_6 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_5, 0
    %var_7 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_5, 1
    %var_8 = alloca i8*
    call void %var_6(i8** %var_8, {  } %var_7, i8* @const_1)
    %var_9 = load i8*, ptr %var_8
    ret i32 0
}
define void @"generated_print_i8*"(ptr sret(i8*) %arg_0, {  } %arg_1, i8* %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i8* %arg_2)
    store i8* %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`simply typed lambda calc compilation > hello world > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%s\\00"
@const_1 = constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, ptr nonnull @const_1)
  ret i32 0
}

define void @"generated_print_i8*"(ptr nocapture writeonly sret(ptr) %arg_0, {} %arg_1, ptr %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, ptr %arg_2)
  store ptr %arg_2, ptr %arg_0, align 8
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`simply typed lambda calc compilation > hello world > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > hello world > stdout 1`] = `
[
  "hello world!",
]
`;

exports[`simply typed lambda calc compilation > hello world string > compiled 1`] = `
"@const_0 = constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    ret i32 0
}
"
`;

exports[`simply typed lambda calc compilation > hello world string > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = local_unnamed_addr constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef i32 @main() local_unnamed_addr #0 {
main:
  ret i32 0
}

attributes #0 = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) }
"
`;

exports[`simply typed lambda calc compilation > hello world string > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > hello world string > stdout 1`] = `[]`;

exports[`simply typed lambda calc compilation > print number > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_0 = alloca {  }
    %var_1 = load {  }, ptr %var_0
    store {  } %var_1, ptr %var_0
    %var_2 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_3 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_2
    %var_4 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_3, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_5 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_4, {  } %var_1, 1
    store { void (i32*, {  }, i32)*, {  } } %var_5, ptr %var_2
    %var_6 = load i32, ptr @const_1
    %var_7 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_5, 0
    %var_8 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_5, 1
    %var_9 = alloca i32
    call void %var_7(i32* %var_9, {  } %var_8, i32 %var_6)
    %var_10 = load i32, ptr %var_9
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`simply typed lambda calc compilation > print number > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, i32 1)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`simply typed lambda calc compilation > print number > stderr 1`] = `[]`;

exports[`simply typed lambda calc compilation > print number > stdout 1`] = `
[
  "1",
]
`;

exports[`structured programming compilation > block > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = constant i32 123
@const_2 = constant i32 234
@const_3 = constant i32 345
@const_4 = constant i32 456
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_0 = alloca {  }
    %var_1 = load {  }, ptr %var_0
    store {  } %var_1, ptr %var_0
    %var_2 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_3 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_2
    %var_4 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_3, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_5 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_4, {  } %var_1, 1
    store { void (i32*, {  }, i32)*, {  } } %var_5, ptr %var_2
    %var_6 = load i32, ptr @const_1
    %var_7 = load i32, ptr @const_2
    %var_8 = load i32, ptr @const_3
    %var_9 = load i32, ptr @const_4
    %var_10 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_5, 0
    %var_11 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_5, 1
    %var_12 = alloca i32
    call void %var_10(i32* %var_12, {  } %var_11, i32 %var_9)
    %var_13 = load i32, ptr %var_12
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > block > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = local_unnamed_addr constant i32 123
@const_2 = local_unnamed_addr constant i32 234
@const_3 = local_unnamed_addr constant i32 345
@const_4 = local_unnamed_addr constant i32 456
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, i32 456)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > block > stderr 1`] = `[]`;

exports[`structured programming compilation > block > stdout 1`] = `
[
  "456",
]
`;

exports[`structured programming compilation > block variable assingment > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = constant i32 123
@const_2 = constant i32 1
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_0 = alloca {  }
    %var_1 = load {  }, ptr %var_0
    store {  } %var_1, ptr %var_0
    %var_2 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_3 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_2
    %var_4 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_3, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_5 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_4, {  } %var_1, 1
    store { void (i32*, {  }, i32)*, {  } } %var_5, ptr %var_2
    %var_6 = load i32, ptr @const_1
    %var_7 = load i32, ptr @const_2
    %var_8 = add i32 %var_6, %var_7
    %var_9 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_5, 0
    %var_10 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_5, 1
    %var_11 = alloca i32
    call void %var_9(i32* %var_11, {  } %var_10, i32 %var_8)
    %var_12 = load i32, ptr %var_11
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > block variable assingment > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = local_unnamed_addr constant i32 123
@const_2 = local_unnamed_addr constant i32 1
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, i32 124)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > block variable assingment > stderr 1`] = `[]`;

exports[`structured programming compilation > block variable assingment > stdout 1`] = `
[
  "124",
]
`;

exports[`structured programming compilation > block variable declaration > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = constant i32 123
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_0 = alloca {  }
    %var_1 = load {  }, ptr %var_0
    store {  } %var_1, ptr %var_0
    %var_2 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_3 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_2
    %var_4 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_3, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_5 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_4, {  } %var_1, 1
    store { void (i32*, {  }, i32)*, {  } } %var_5, ptr %var_2
    %var_6 = load i32, ptr @const_1
    %var_7 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_5, 0
    %var_8 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_5, 1
    %var_9 = alloca i32
    call void %var_7(i32* %var_9, {  } %var_8, i32 %var_6)
    %var_10 = load i32, ptr %var_9
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > block variable declaration > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = local_unnamed_addr constant i32 123
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, i32 123)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > block variable declaration > stderr 1`] = `[]`;

exports[`structured programming compilation > block variable declaration > stdout 1`] = `
[
  "123",
]
`;

exports[`structured programming compilation > block variable shadowing > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = constant i32 123
@const_2 = constant i32 234
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_0 = alloca {  }
    %var_1 = load {  }, ptr %var_0
    store {  } %var_1, ptr %var_0
    %var_2 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_3 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_2
    %var_4 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_3, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_5 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_4, {  } %var_1, 1
    store { void (i32*, {  }, i32)*, {  } } %var_5, ptr %var_2
    %var_6 = load i32, ptr @const_1
    %var_7 = load i32, ptr @const_2
    %var_8 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_5, 0
    %var_9 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_5, 1
    %var_10 = alloca i32
    call void %var_8(i32* %var_10, {  } %var_9, i32 %var_7)
    %var_11 = load i32, ptr %var_10
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > block variable shadowing > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = local_unnamed_addr constant i32 123
@const_2 = local_unnamed_addr constant i32 234
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, i32 234)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > block variable shadowing > stderr 1`] = `[]`;

exports[`structured programming compilation > block variable shadowing > stdout 1`] = `
[
  "234",
]
`;

exports[`structured programming compilation > hello world twice > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%s\\00"
@const_1 = constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_0 = alloca {  }
    %var_1 = load {  }, ptr %var_0
    store {  } %var_1, ptr %var_0
    %var_2 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_3 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_2
    %var_4 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_3, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_5 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_4, {  } %var_1, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_5, ptr %var_2
    %var_6 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_5, 0
    %var_7 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_5, 1
    %var_8 = alloca i8*
    call void %var_6(i8** %var_8, {  } %var_7, i8* @const_1)
    %var_9 = load i8*, ptr %var_8
    %var_10 = alloca {  }
    %var_11 = load {  }, ptr %var_10
    store {  } %var_11, ptr %var_10
    %var_12 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_13 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_12
    %var_14 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_13, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_15 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_14, {  } %var_11, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_15, ptr %var_12
    %var_16 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_15, 0
    %var_17 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_15, 1
    %var_18 = alloca i8*
    call void %var_16(i8** %var_18, {  } %var_17, i8* @const_1)
    %var_19 = load i8*, ptr %var_18
    ret i32 0
}
define void @"generated_print_i8*"(ptr sret(i8*) %arg_0, {  } %arg_1, i8* %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i8* %arg_2)
    store i8* %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > hello world twice > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%s\\00"
@const_1 = constant [13 x i8] c"hello world!\\00"
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, ptr nonnull @const_1)
  tail call void @printf(ptr nonnull @const_0, ptr nonnull @const_1)
  ret i32 0
}

define void @"generated_print_i8*"(ptr nocapture writeonly sret(ptr) %arg_0, {} %arg_1, ptr %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, ptr %arg_2)
  store ptr %arg_2, ptr %arg_0, align 8
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > hello world twice > stderr 1`] = `[]`;

exports[`structured programming compilation > hello world twice > stdout 1`] = `
[
  "hello world!hello world!",
]
`;

exports[`structured programming compilation > if-then > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = constant i1 1
@const_2 = constant i32 123
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_0 = alloca {  }
    %var_1 = load {  }, ptr %var_0
    store {  } %var_1, ptr %var_0
    %var_2 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_3 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_2
    %var_4 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_3, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_5 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_4, {  } %var_1, 1
    store { void (i32*, {  }, i32)*, {  } } %var_5, ptr %var_2
    %var_6 = load i1, ptr @const_1
    br i1 %var_6, label %then_1, label %if_rest17
  then_1: 
    %var_7 = load i32, ptr @const_2
    br label %if_rest17
  if_rest17: 
    %var_8 = phi i32 [%var_7, %then_1], [undef, %main]
    %var_9 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_5, 0
    %var_10 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_5, 1
    %var_11 = alloca i32
    call void %var_9(i32* %var_11, {  } %var_10, i32 %var_8)
    %var_12 = load i32, ptr %var_11
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > if-then > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = local_unnamed_addr constant i1 true
@const_2 = local_unnamed_addr constant i32 123
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, i32 123)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > if-then > stderr 1`] = `[]`;

exports[`structured programming compilation > if-then > stdout 1`] = `
[
  "123",
]
`;

exports[`structured programming compilation > if-then-else > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = constant i1 0
@const_2 = constant i32 123
@const_3 = constant i32 456
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_0 = alloca {  }
    %var_1 = load {  }, ptr %var_0
    store {  } %var_1, ptr %var_0
    %var_2 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_3 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_2
    %var_4 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_3, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_5 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_4, {  } %var_1, 1
    store { void (i32*, {  }, i32)*, {  } } %var_5, ptr %var_2
    %var_6 = load i1, ptr @const_1
    br i1 %var_6, label %then_1, label %else_2
  then_1: 
    %var_7 = load i32, ptr @const_2
    br label %if_rest20
  else_2: 
    %var_8 = load i32, ptr @const_3
    br label %if_rest20
  if_rest20: 
    %var_9 = phi i32 [%var_7, %then_1], [%var_8, %else_2]
    %var_10 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_5, 0
    %var_11 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_5, 1
    %var_12 = alloca i32
    call void %var_10(i32* %var_12, {  } %var_11, i32 %var_9)
    %var_13 = load i32, ptr %var_12
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > if-then-else > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = local_unnamed_addr constant i1 false
@const_2 = local_unnamed_addr constant i32 123
@const_3 = local_unnamed_addr constant i32 456
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, i32 456)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > if-then-else > stderr 1`] = `[]`;

exports[`structured programming compilation > if-then-else > stdout 1`] = `
[
  "456",
]
`;

exports[`structured programming compilation > sequence > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = constant i32 123
@const_2 = constant i32 234
@const_3 = constant i32 345
@const_4 = constant i32 456
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_0 = alloca {  }
    %var_1 = load {  }, ptr %var_0
    store {  } %var_1, ptr %var_0
    %var_2 = alloca { void (i32*, {  }, i32)*, {  } }
    %var_3 = load { void (i32*, {  }, i32)*, {  } }, ptr %var_2
    %var_4 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_3, void (i32*, {  }, i32)* @"generated_print_i32", 0
    %var_5 = insertvalue { void (i32*, {  }, i32)*, {  } } %var_4, {  } %var_1, 1
    store { void (i32*, {  }, i32)*, {  } } %var_5, ptr %var_2
    %var_6 = load i32, ptr @const_1
    %var_7 = load i32, ptr @const_2
    %var_8 = load i32, ptr @const_3
    %var_9 = load i32, ptr @const_4
    %var_10 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_5, 0
    %var_11 = extractvalue { void (i32*, {  }, i32)*, {  } } %var_5, 1
    %var_12 = alloca i32
    call void %var_10(i32* %var_12, {  } %var_11, i32 %var_9)
    %var_13 = load i32, ptr %var_12
    ret i32 0
}
define void @"generated_print_i32"(ptr sret(i32) %arg_0, {  } %arg_1, i32 %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i32 %arg_2)
    store i32 %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > sequence > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%i\\00"
@const_1 = local_unnamed_addr constant i32 123
@const_2 = local_unnamed_addr constant i32 234
@const_3 = local_unnamed_addr constant i32 345
@const_4 = local_unnamed_addr constant i32 456
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, i32 456)
  ret i32 0
}

define void @generated_print_i32(ptr nocapture writeonly sret(i32) %arg_0, {} %arg_1, i32 %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, i32 %arg_2)
  store i32 %arg_2, ptr %arg_0, align 4
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > sequence > stderr 1`] = `[]`;

exports[`structured programming compilation > sequence > stdout 1`] = `
[
  "456",
]
`;

exports[`structured programming compilation > two prints > compiled 1`] = `
"@const_0 = constant [3 x i8] c"%s\\00"
@const_1 = constant [13 x i8] c"hello world!\\00"
@const_2 = constant [15 x i8] c"hello world 2!\\00"
@symbols_metadata_array = constant [0 x { i8* }] []
@symbols_metadata = constant ptr @symbols_metadata_array
define i32 @main() {
  main: 
    %var_0 = alloca {  }
    %var_1 = load {  }, ptr %var_0
    store {  } %var_1, ptr %var_0
    %var_2 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_3 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_2
    %var_4 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_3, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_5 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_4, {  } %var_1, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_5, ptr %var_2
    %var_6 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_5, 0
    %var_7 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_5, 1
    %var_8 = alloca i8*
    call void %var_6(i8** %var_8, {  } %var_7, i8* @const_1)
    %var_9 = load i8*, ptr %var_8
    %var_10 = alloca {  }
    %var_11 = load {  }, ptr %var_10
    store {  } %var_11, ptr %var_10
    %var_12 = alloca { void (i8**, {  }, i8*)*, {  } }
    %var_13 = load { void (i8**, {  }, i8*)*, {  } }, ptr %var_12
    %var_14 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_13, void (i8**, {  }, i8*)* @"generated_print_i8*", 0
    %var_15 = insertvalue { void (i8**, {  }, i8*)*, {  } } %var_14, {  } %var_11, 1
    store { void (i8**, {  }, i8*)*, {  } } %var_15, ptr %var_12
    %var_16 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_15, 0
    %var_17 = extractvalue { void (i8**, {  }, i8*)*, {  } } %var_15, 1
    %var_18 = alloca i8*
    call void %var_16(i8** %var_18, {  } %var_17, i8* @const_2)
    %var_19 = load i8*, ptr %var_18
    ret i32 0
}
define void @"generated_print_i8*"(ptr sret(i8*) %arg_0, {  } %arg_1, i8* %arg_2) {
  entry_0: 
    call void @printf(i8* @const_0, i8* %arg_2)
    store i8* %arg_2, ptr %arg_0
    ret void
}
declare i32 @printf(i8*, ...)
"
`;

exports[`structured programming compilation > two prints > optimized 1`] = `
"; ModuleID = '<stdin>'
source_filename = "<stdin>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@const_0 = constant [3 x i8] c"%s\\00"
@const_1 = constant [13 x i8] c"hello world!\\00"
@const_2 = constant [15 x i8] c"hello world 2!\\00"
@symbols_metadata_array = constant [0 x { ptr }] undef
@symbols_metadata = local_unnamed_addr constant ptr @symbols_metadata_array

define noundef i32 @main() local_unnamed_addr {
main:
  tail call void @printf(ptr nonnull @const_0, ptr nonnull @const_1)
  tail call void @printf(ptr nonnull @const_0, ptr nonnull @const_2)
  ret i32 0
}

define void @"generated_print_i8*"(ptr nocapture writeonly sret(ptr) %arg_0, {} %arg_1, ptr %arg_2) local_unnamed_addr {
entry_0:
  tail call void @printf(ptr nonnull @const_0, ptr %arg_2)
  store ptr %arg_2, ptr %arg_0, align 8
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #0

attributes #0 = { nofree nounwind }
"
`;

exports[`structured programming compilation > two prints > stderr 1`] = `[]`;

exports[`structured programming compilation > two prints > stdout 1`] = `
[
  "hello world!hello world 2!",
]
`;
